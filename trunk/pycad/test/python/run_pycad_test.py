# $Id: run_visualization_interface.py 798 2006-08-04 01:05:36Z gross $

__copyright__="""  Copyright (c) 2006 by ACcESS MNRF
                    http://www.access.edu.au
                Primary Business: Queensland, Australia"""
__license__="""Licensed under the Open Software License version 3.0
             http://www.opensource.org/licenses/osl-3.0.php"""
import sys
import unittest
import math
import numarray
from esys.pycad import *

try:
     PYCAD_TEST_DATA=os.environ['PYCAD_TEST_DATA']
except KeyError:
     PYCAD_TEST_DATA='.'

try:
     PYCAD_WORKDIR=os.environ['PYCAD_WORKDIR']
except KeyError:
     PYCAD_WORKDIR='.'

PYCAD_TEST_MESH_PATH=PYCAD_TEST_DATA+"/data_meshes/"
PYCAD_WORKDIR_PATH=PYCAD_WORKDIR+"/"

def _cross(x, y):
    return numarray.array([x[1] * y[2] - x[2] * y[1], x[2] * y[0] - x[0] * y[2], x[0] * y[1] - x[1] * y[0]])


class Test_PyCAD_Transformations(unittest.TestCase):
   ABS_TOL=1.e-8
   def __distance(self,x,y):
       return math.sqrt(numarray.dot(x-y,x-y))
   def test_Translation_x(self):
        t=Translation([1,0,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([1,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([1,0,1]))<self.ABS_TOL,"s2 is wrong.")
   def test_Translation_y(self):
        t=Translation([0,1,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1,1,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,2,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,1,1]))<self.ABS_TOL,"s2 is wrong.")
   def test_Translation_z(self):
        t=Translation([0,0,1])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1,0,1]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,1]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_0_two(self):
        t=Dilation(2.)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,2,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_0_half(self):
        t=Dilation(0.5)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.5,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,0.5,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,0.5]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_x_two(self):
        t=Dilation(2.,[1.,0.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s0_1=t([0,0,0])
        self.failUnless(isinstance(s0_1,numarray.NumArray),"s0_1 is not a numarray object.")
        self.failUnless(self.__distance(s0_1,numarray.array([-1.,0,0]))<self.ABS_TOL,"s0_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([-1,2,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([-1.,0,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_x_half(self):
        t=Dilation(0.5,[1.,0.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s0_1=t([0,0,0])
        self.failUnless(isinstance(s0_1,numarray.NumArray),"s0_1 is not a numarray object.")
        self.failUnless(self.__distance(s0_1,numarray.array([.5,0,0]))<self.ABS_TOL,"s0_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.5,0.5,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.5,0,0.5]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_y_two(self):
        t=Dilation(2.,[0.,1.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2.,-1.,0]))<self.ABS_TOL,"s0 is wrong.")
        s1_1=t([0,0,0])
        self.failUnless(isinstance(s1_1,numarray.NumArray),"s1_1 is not a numarray object.")
        self.failUnless(self.__distance(s1_1,numarray.array([0.,-1.,0]))<self.ABS_TOL,"s1_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1.,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,-1.,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_y_half(self):
        t=Dilation(0.5,[0.,1.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.5,0.5,0]))<self.ABS_TOL,"s0 is wrong.")
        s1_1=t([0,0,0])
        self.failUnless(isinstance(s1_1,numarray.NumArray),"s1_1 is not a numarray object.")
        self.failUnless(self.__distance(s1_1,numarray.array([0,0.5,0]))<self.ABS_TOL,"s1_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1.,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0.5,0.5]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_z_two(self):
        t=Dilation(2.,[0.,0.,1.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2.,0.,-1.]))<self.ABS_TOL,"s0 is wrong.")
        s2_1=t([0,0,0])
        self.failUnless(isinstance(s2_1,numarray.NumArray),"s2_1 is not a numarray object.")
        self.failUnless(self.__distance(s2_1,numarray.array([0.,0.,-1.]))<self.ABS_TOL,"s2_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,2.,-1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0.,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_z_half(self):
        t=Dilation(0.5,[0.,0.,1.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.5,0.,0.5]))<self.ABS_TOL,"s0 is wrong.")
        s2_1=t([0,0,0])
        self.failUnless(isinstance(s2_1,numarray.NumArray),"s2_1 is not a numarray object.")
        self.failUnless(self.__distance(s2_1,numarray.array([0,0,0.5]))<self.ABS_TOL,"s2_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,0.5,0.5]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0.,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Reflection_x_offset0(self):
        t=Reflection([1.,0.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([-1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([-1.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_x_offset2(self):
        t=Reflection([-2.,0.,0.],offset=-4)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([3.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([4,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([4,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([3.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_x_offset2_vector(self):
        t=Reflection([1.,0.,0.],offset=[2,0,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([3.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([4,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([4,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([3.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_y_offset0(self):
        t=Reflection([0.,1.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,-1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,-2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_y_offset2(self):
        t=Reflection([0.,-2.,0.],offset=-4)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,4,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,3,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,4,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_y_offset2_vector(self):
        t=Reflection([0.,1.,0.],offset=[0,2,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,4,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,3,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,4,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_z_offset0(self):
        t=Reflection([0.,0.,1.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,-1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,-3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_z_offset2(self):
        t=Reflection([0.,0.,-2.],offset=-4)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,4.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,4]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,3]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,1]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_z_offset2_vector(self):
        t=Reflection([0.,0.,1.],offset=[0,0,2])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,4.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,4]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,3]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,1]))<self.ABS_TOL,"s is wrong.")
   def test_Rotatation_x_90_0(self):
        t=Rotatation(axis=[1.,0.,0.],point=[1.,0.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,0,1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,-1.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_x_30_0(self):
        t=Rotatation(axis=[1.,0.,0.],point=[1.,0.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([1.,0.,0.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([1.,0.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_x_330_0(self):
        t=Rotatation(axis=[1.,0.,0.],point=[1.,0.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(330*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([1.,0.,0.]))>0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([1.,0.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_x_90(self):
        t=Rotatation(axis=[-1.,0.,0.],point=[2.,0.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,0,-1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,1.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_x_30(self):
        t=Rotatation(axis=[-1.,0.,0.],point=[1.,0.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([-1.,0.,0.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([-1.,0.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_x_330(self):
        t=Rotatation(axis=[-1.,0.,0.],point=[1.,0.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(330*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([-1.,0.,0.]))>0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([-1.,0.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_y_90_0(self):
        t=Rotatation(axis=[0.,1.,0.],point=[0.,1.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,0,-1.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,5,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([1,0.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_y_30_0(self):
        t=Rotatation(axis=[0.,1.,0.],point=[0.,1.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,1.,0.]))<0.,"s0 has wrong orientation.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,5,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,1.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_y_330_0(self):
        t=Rotatation(axis=[0.,1.,0.],point=[0.,1.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,1.,0.]))>0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,1.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_y_90(self):
        t=Rotatation(axis=[0.,-1.,0.],point=[0.,2.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,0,1.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,5,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([-1,0.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_y_30(self):
        t=Rotatation(axis=[0.,-1.,0.],point=[0.,2.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,-1.,0.]))<0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,-1.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_y_330(self):
        t=Rotatation(axis=[0.,-1.,0.],point=[0.,2.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,-1.,0.]))>0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,-1.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_z_90_0(self):
        t=Rotatation(axis=[0.,0.,1.],point=[0.,0.,1.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,1,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([-5.,0,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_30_0(self):
        t=Rotatation(axis=[0.,0.,1.],point=[0.,0.,1.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,1.]))<0.,"s0 has wrong orientation.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-5.**2)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]/5.-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,5,0]),numarray.array([0.,0.,1.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_330_0(self):
        t=Rotatation(axis=[0.,0.,1.],point=[0.,0.,1.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,1.]))>0.,"s0 has wrong orientation.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-5.**2)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]/5.-math.cos(330*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([0.,0.,1.]))>0.,"s1 has wrong orientation.")
   def test_Rotatation_z_90(self):
        t=Rotatation(axis=[0.,0.,-1.],point=[0.,0.,2.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,-1,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([5.,0,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_30(self):
        t=Rotatation(axis=[0.,0.,-1.],point=[0.,0.,2.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,-1.]))<0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([0.,0.,-1.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_330(self):
        t=Rotatation(axis=[0.,0.,-1.],point=[0.,0.,2.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,-1.]))>0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([0.,0.,-1.]))>0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_x_90_1(self):
        t=Rotatation(point=[0.,0.,1.],axis=[1.,0.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,1,1.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,2.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_y_90_1(self):
        t=Rotatation(point=[1.,0.,0.],axis=[0.,1.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([1.,1,1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([2.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_90_1(self):
        t=Rotatation(point=[0.,1.,0.],axis=[0.,0.,1.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,2,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([1.,1,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_diag_90_0(self):
        t=Rotatation(axis=[1.,1.,1.],angle=90*DEG)
        s0=t([1,-1,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-2.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(numarray.dot(s0,numarray.array([1,-1,0])))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,-1,0]),numarray.array([1.,1.,1.]))<0.,"s0 has wrong orientation.")
        s1=t([0,1,-1])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-2.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(numarray.dot(s1,numarray.array([0,1,-1])))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,-1]),numarray.array([1.,1.,1.]))<0.,"s1 has wrong orientation.")
        s2=t([-1,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-2.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(numarray.dot(s2,numarray.array([-1,0,1])))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[-1,0,1]),numarray.array([1.,1.,1.]))<0.,"s2 has wrong orientation.")
        s3=t([1,1,1])
        self.failUnless(isinstance(s3,numarray.NumArray),"s3 is not a numarray object.")
        self.failUnless(self.__distance(s3,numarray.array([1.,1,1.]))<self.ABS_TOL,"s3 is wrong.")

class Test_PyCAD_Primitives(unittest.TestCase):
   def setUp(self):
         resetGlobalPrimitiveIdCounter()

   def test_Primitive(self):
         p=Primitive()

         id=p.getID()
         self.failUnless(isinstance(id,int),"id number is not an integer")
         self.failUnless(not id==Primitive().getID(),"id number is not unique")

         self.failUnless(p==p.getUnderlyingPrimitive(),"getUnderlyingPrimitive does not return self.")

   def test_ReversePrimitive(self):
         p=Primitive()
      
         rp=ReversePrimitive(p)
         self.failUnless(p.getID()==rp.getID(),"reverse primitive does not have same id like source")
         self.failUnless(p==rp.getUnderlyingPrimitive(),"getUnderlyingPrimitive does return source.")
         self.failUnless(p == -rp,"reverse or reverse does not return source.")
           
   def test_Point(self):
       p=Point(1.,2.,3.,local_scale=9.)
       
       id=p.getID()
       self.failUnless(isinstance(id,int),"id number is not an integer")
       self.failUnless(not id==Primitive().getID(),"id number is not unique")
           
       # check reverse point 
       self.failUnless(p == -p,"reverse is not working.")
       
       # check history:
       hs=p.getPrimitives()
       self.failUnless(len(hs)==1,"history must have length 1.")
       self.failUnless(p in hs,"history must contain point p")

       # check incolved points:
       ps=p.getConstructionPoints()
       self.failUnless(len(ps)==1,"point set must have length 1.")
       self.failUnless(p in ps,"point set must contain point p")

       # check coordinates:
       c=p.getCoordinates()
       self.failUnless(isinstance(c,numarray.NumArray),"coordinates are not a numarray object.")
       self.failUnless(c[0]==1.,"x coordinate is not 1.")
       self.failUnless(c[1]==2.,"y coordinate is not 2.")
       self.failUnless(c[2]==3.,"z coordinate is not 3.")
 
       # reset coordinates:
       p.setCoordinates([-1.,-2.,-3.])
       c=p.getCoordinates()
       self.failUnless(isinstance(c,numarray.NumArray),"new coordinates are not a numarray object.")
       self.failUnless(c[0]==-1.,"new x coordinate is not -1.")
       self.failUnless(c[1]==-2.,"new y coordinate is not -2.")
       self.failUnless(c[2]==-3.,"new z coordinate is not -3.")

       # check for a colocated point:
       self.failUnless(p.isColocated(Point(-1.,-2.,-3.)),"colocation not detected.")
       self.failUnless(not p.isColocated(numarray.array([-1.,-2.,-3.])),"colocation with numarray representation not detected.")
       self.failUnless(not p.isColocated(Point(1.,-2.,-3.)),"false colocation detected.")
       self.failUnless(not p.isColocated(Point(0.,0.,0.)),"false colocation with origin detected.")

       # check for local length scale
       l=p.getLocalScale()
       self.failUnless(l==9.,"refinement scale is not 9.")

       # check for new local length scale
       p.setLocalScale(3.)
       l=p.getLocalScale()
       self.failUnless(l==3.,"new refinement scale is not 3.")

       # negative value shouldn't work.
       self.failUnlessRaises(ValueError,p.setLocalScale,-3.)

       # copy:
       an_other_p=p.copy()
       self.failUnless(isinstance(an_other_p ,Point),"copy is not a point")
       self.failUnless(not an_other_p.getID() == p.getID(),"copy has same Id")
       self.failUnless(p.isColocated(an_other_p),"p is not colocated with its copy.")
       self.failUnless(an_other_p.isColocated(p),"the copy is not colocated with p.")
       self.failUnless(an_other_p.getLocalScale()==3.,"copy has wrong local scale.")
      
       # modify by Transformation:
       p.modifyBy(Dilation(-1))
       self.failUnless(p.isColocated(Point(1.,2.,3.)),"in-place transformation failed")
       
       # apply Transformation:
       dil_p=p.apply(Dilation(4))
       self.failUnless(dil_p.isColocated(Point(4.,8.,12.)),"applying transformation failed")
       self.failUnless(not dil_p.getID() == p.getID(),"transformed point has same Id")
       self.failUnless(dil_p.getLocalScale()==3.,"transformed point  has wrong local scale.")
        
       # overloaded add:
       shift_p=p+[1,1,1]
       self.failUnless(shift_p.isColocated(Point(2,3.,4)),"applying shift by list failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by list has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by list has wrong local scale.")

       shift_p=p+numarray.array([1,1,1])
       self.failUnless(shift_p.isColocated(Point(2,3.,4)),"applying shift by numarray failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by numarray has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by numarray has wrong local scale.")
       # overloaded minus
       shift_p=p-[1,1,1]
       self.failUnless(shift_p.isColocated(Point(0,1,2.)),"applying shift by -list failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by -list has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by -list has wrong local scale.")

       shift_p=p-numarray.array([1,1,1])
       self.failUnless(shift_p.isColocated(Point(0,1,2.)),"applying shift by -numarray failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by -numarray has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by -numarray has wrong local scale.")
       # overloaded inplace add:
       p+=[1,1,1]
       self.failUnless(p.isColocated(Point(2,3.,4)),"modification by list shift failed")

       p+=numarray.array([1,1,1])
       self.failUnless(p.isColocated(Point(3,4,5)),"modification by numarray shift failed")

       # overloaded inplace add:
       p-=[1,1,1]
       self.failUnless(p.isColocated(Point(2,3,4)),"modification by -list shift failed")

       p-=numarray.array([1,1,1])
       self.failUnless(p.isColocated(Point(1,2.,3)),"modification by -numarray shift failed")

       #overloaded multiplication:
       mult_p=2*p
       self.failUnless(mult_p.isColocated(Point(2,4,6)),"applying int factor failed")
       self.failUnless(not mult_p.getID() == p.getID(),"shift by int factor has same Id")
       self.failUnless(mult_p.getLocalScale()==3.,"shift by int factor has wrong local scale.")

       mult_p=2.*p
       self.failUnless(mult_p.isColocated(Point(2,4,6)),"applying float factor failed")
       self.failUnless(not mult_p.getID() == p.getID(),"shift by float factor has same Id")
       self.failUnless(mult_p.getLocalScale()==3.,"shift by float factor has wrong local scale.")

       mult_p=Dilation(2)*p
       self.failUnless(mult_p.isColocated(Point(2,4,6)),"applying Dilation factor failed")
       self.failUnless(not mult_p.getID() == p.getID(),"shift by Dilation factor has same Id")
       self.failUnless(mult_p.getLocalScale()==3.,"shift by Dilation factor has wrong local scale.")

       #overloaded inplace multiplication:
       p*=2
       self.failUnless(p.isColocated(Point(2,4,6)),"applying in-place int factor failed")

       p*=2.
       self.failUnless(p.isColocated(Point(4,8,12)),"applying in-place float factor failed")

       p*=Dilation(2)
       self.failUnless(p.isColocated(Point(8,16,24)),"applying in-place Dilation factor failed")

       # get gmsh code
       code=p.getGmshCommand(2.)
       self.failUnless("Point(1) = {8.0 , 16.0, 24.0 , 6.0 };"== code, "wrong gmsh code")
 
   def test_Spline(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,Spline,p0)
        c=Spline(p0,p1,p2,p3)

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p3, "wrong end point of spline curve")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        self.failUnless(not c.isColocated(p1),"spline is colocated with point.")
        self.failUnless(not c.isColocated(Spline(p0,p1,p2)),"spline is colocated with spline of different length.")
        self.failUnless(not c.isColocated(Spline(p0,p1,p4,p3)),"spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(Spline(p0,p1,p2,p3)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(Spline(p3,p2,p1,p0)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")
        self.failUnless(co[2]==p2, "3rd control point is wrong.")
        self.failUnless(co[3]==p3, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Spline(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p0 == cpcp[0],"1st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[1],"2st point of deep copy and source are the same.")
        self.failUnless(not p2 == cpcp[2],"3st point of deep copy and source are the same.")
        self.failUnless(not p3 == cpcp[3],"4st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(Spline(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p2 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p3 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(Spline(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(dccp[0].isColocated(Point(0,0,0)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(dccp[1].isColocated(Point(1,1,1)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(dccp[2].isColocated(Point(2,2,2)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")
        self.failUnless(dccp[3].isColocated(Point(3,3,3)),"1st point of Dilation is is wrongly located.")
   
   def test_ReverseSpline(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        CC0=Spline(p0,p1,p2,p3)
        c=-CC0

        self.failUnless(len(c) == 4, "wrong reverse spline curve length")
        self.failUnless(c.getStartPoint()==p3, "wrong start point of reverse spline curve")
        self.failUnless(c.getEndPoint()==p0, "wrong end point of reverse spline curve")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        self.failUnless(not c.isColocated(p1),"reverse spline is colocated with point.")
        self.failUnless(not c.isColocated(Spline(p0,p1,p2)),"reverse spline is colocated with spline of different length.")
        self.failUnless(not c.isColocated(Spline(p0,p1,p4,p3)),"reverse spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(Spline(p0,p1,p2,p3)),"reverse spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(c.isColocated(Spline(p3,p2,p1,p0)),"reverse spline is not colocated with spline with same points.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p3, "1st control point is wrong.")
        self.failUnless(co[1]==p2, "2nd control point is wrong.")
        self.failUnless(co[2]==p1, "3rd control point is wrong.")
        self.failUnless(co[3]==p0, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Spline(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(CC0 in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(not cp == CC0, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p3 == cpcp[0],"1st point of deep copy and souce are the same.")
        self.failUnless(not p2 == cpcp[1],"2st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[2],"3st point of deep copy and source are the same.")
        self.failUnless(not p0 == cpcp[3],"4st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(Spline(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p3 == cp[0],"1st new point after Dilation.")
        self.failUnless(p2 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p1 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p0 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(Spline(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        self.failUnless(dccp[0].isColocated(Point(3,3,3)),"1st point of Dilation is is wrongly located.")
        self.failUnless(dccp[1].isColocated(Point(2,2,2)),"1st point of Dilation is is wrongly located.")
        self.failUnless(dccp[2].isColocated(Point(1,1,1)),"1st point of Dilation is is wrongly located.")
        self.failUnless(dccp[3].isColocated(Point(0,0,0)),"1st point of Dilation is is wrongly located.")

   def test_BezierCurve(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,BezierCurve,p0)
        c=BezierCurve(p0,p1,p2,p3)

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p3, "wrong end point of spline curve")

        self.failUnless(not c.isColocated(p1),"spline is colocated with point.")
        self.failUnless(not c.isColocated(BezierCurve(p0,p1,p2)),"spline is colocated with spline of different length.")
        self.failUnless(not c.isColocated(BezierCurve(p0,p1,p4,p3)),"spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(BezierCurve(p0,p1,p2,p3)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(BezierCurve(p3,p2,p1,p0)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")
        self.failUnless(co[2]==p2, "3rd control point is wrong.")
        self.failUnless(co[3]==p3, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Bezier(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p0 == cpcp[0],"1st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[1],"2st point of deep copy and source are the same.")
        self.failUnless(not p2 == cpcp[2],"3st point of deep copy and source are the same.")
        self.failUnless(not p3 == cpcp[3],"4st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(BezierCurve(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p2 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p3 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(BezierCurve(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")

   def test_BSpline(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,BSpline,p0)
        c=BSpline(p0,p1,p2,p3)

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p3, "wrong end point of spline curve")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        self.failUnless(not c.isColocated(p1),"spline is colocated with point.")
        self.failUnless(not c.isColocated(BSpline(p0,p1,p2)),"spline is colocated with spline of different length.")
        self.failUnless(not c.isColocated(BSpline(p0,p1,p4,p3)),"spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(BSpline(p0,p1,p2,p3)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(BSpline(p3,p2,p1,p0)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")
        self.failUnless(co[2]==p2, "3rd control point is wrong.")
        self.failUnless(co[3]==p3, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "BSpline(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p0 == cpcp[0],"1st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[1],"2st point of deep copy and source are the same.")
        self.failUnless(not p2 == cpcp[2],"3st point of deep copy and source are the same.")
        self.failUnless(not p3 == cpcp[3],"4st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(BSpline(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p2 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p3 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(BSpline(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(dccp[0].isColocated(Point(0,0,0)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(dccp[1].isColocated(Point(1,1,1)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(dccp[2].isColocated(Point(2,2,2)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")
        self.failUnless(dccp[3].isColocated(Point(3,3,3)),"1st point of Dilation is is wrongly located.")

   def test_ReverseBSpline(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        CC0=BSpline(p0,p1,p2,p3)
        c=-CC0

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p3, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p0, "wrong end point of spline curve")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        self.failUnless(not c.isColocated(p1),"spline is colocated with point.")
        self.failUnless(not c.isColocated(BSpline(p0,p1,p2)),"spline is colocated with spline of different length.")
        self.failUnless(not c.isColocated(BSpline(p0,p1,p4,p3)),"spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(BSpline(p0,p1,p2,p3)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(BSpline(p3,p2,p1,p0)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p3, "1st control point is wrong.")
        self.failUnless(co[1]==p2, "2nd control point is wrong.")
        self.failUnless(co[2]==p1, "3rd control point is wrong.")
        self.failUnless(co[3]==p0, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "BSpline(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(CC0 in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p0 == cpcp[0],"1st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[1],"2st point of deep copy and source are the same.")
        self.failUnless(not p2 == cpcp[2],"3st point of deep copy and source are the same.")
        self.failUnless(not p3 == cpcp[3],"4st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(BSpline(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p3 == cp[0],"1st new point after Dilation.")
        self.failUnless(p2 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p1 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p0 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(BSpline(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(dccp[0].isColocated(Point(3,3,3)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(dccp[1].isColocated(Point(2,2,2)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(dccp[2].isColocated(Point(1,1,1)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")
        self.failUnless(dccp[3].isColocated(Point(0,0,0)),"1st point of Dilation is is wrongly located.")

   def test_LineSegment(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,Line,p0)
        self.failUnlessRaises(TypeError,Line,p0,p1,p4)

        c=Line(p0,p1)

        self.failUnless(len(c) == 2, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p1, "wrong end point of spline curve")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        self.failUnless(not c.isColocated(p1),"spline is colocated with point.")
        self.failUnless(not c.isColocated(Line(p0,p4)),"spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(Line(p0,p1)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(Line(p1,p0)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p4)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Line(4) = {1, 2};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 3, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p0 == cpcp[0],"1st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[1],"2st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(Line(Point(0,0,0),Point(-1,-1,-1))),"inplace dilation is wrong.")
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(Line(Point(0,0,0),Point(1,1,1))),"dilation is wrong.")
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(dccp[0].isColocated(Point(0,0,0)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(dccp[1].isColocated(Point(1,1,1)),"2st point of Dilation is is wrongly located.")

   def test_ReverseLineSegment(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,Line,p0)
        self.failUnlessRaises(TypeError,Line,p0,p1,p4)

        CC0=Line(p0,p1)
        c=-CC0

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        self.failUnless(len(c) == 2, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p1, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p0, "wrong end point of spline curve")

        self.failUnless(not c.isColocated(p1),"spline is colocated with point.")
        self.failUnless(not c.isColocated(Line(p0,p4)),"spline is colocated with spline with different point.")
        self.failUnless(c.isColocated(Line(p0,p1)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(Line(p1,p0)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p4)),"spline curve is identified with curve.")

        co=c.getControlPoints()
        self.failUnless(co[0]==p1, "1st control point is wrong.")
        self.failUnless(co[1]==p0, "2nd control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Line(4) = {1, 2};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 3, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(CC0 in h, "missing spline curve in history.")

        cp=c.copy()
        cpcp=cp.getControlPoints()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        self.failUnless(c.isColocated(cp),"spline curve is not colocated with its copy.")
        self.failUnless(not p0 == cpcp[0],"1st point of deep copy and source are the same.")
        self.failUnless(not p1 == cpcp[1],"2st point of deep copy and source are the same.")

        c.modifyBy(Dilation(-1.))
        cp=c.getControlPoints()
        self.failUnless(c.isColocated(Line(Point(0,0,0),Point(-1,-1,-1))),"inplace dilation is wrong.")
        self.failUnless(p1 == cp[0],"1st new point after Dilation.")
        self.failUnless(p0 == cp[1],"2nd new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        dccp=dc.getControlPoints()
        self.failUnless(dc.isColocated(Line(Point(0,0,0),Point(1,1,1))),"dilation is wrong.")
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(dccp[0].isColocated(Point(1,1,1)),"1st point of Dilation is is wrongly located.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(dccp[1].isColocated(Point(0,0,0)),"2st point of Dilation is is wrongly located.")

   def test_Arc(self):
        center=Point(0,0,0,0.1)
        p_start=Point(1,1,1,0.2)
        p_end=Point(1,2,3)
        p4=Point(10,2,3)
 
        self.failUnlessRaises(TypeError,Arc,Primitive())

        c=Arc(center,p_start,p_end)

        self.failUnless(c.getCenterPoint()==center, "wrong center point")
        self.failUnless(c.getStartPoint()==p_start, "wrong start point")
        self.failUnless(c.getEndPoint()==p_end, "wrong end point")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        code=c.getGmshCommand() 
        self.failUnless(code == "Circle(6) = {2, 1, 3};", "gmsh command wrong.")

        self.failUnless(not c.isColocated(p4),"spline is colocated with point.")
        self.failUnless(not c.isColocated(Arc(p4,p_start,p_end)),"spline is colocated with spline with differnt center point.")
        self.failUnless(not c.isColocated(Arc(center,p4,p_end)),"spline is colocated with spline with differnt start point.")
        self.failUnless(not c.isColocated(Arc(center,p_start,p4)),"spline is colocated with spline with differnt end point.")
        self.failUnless(c.isColocated(Arc(center,p_start,p_end)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(Arc(center,p_end,p_start)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(center,p_start,p_end)),"spline curve is identified with curve.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 4, "number of primitives in history is wrong.")
        self.failUnless(center in h, "missing center in history.")
        self.failUnless(p_start in h, "missing p_start in history.")
        self.failUnless(p_end in h, "missing p_end in history.")
        self.failUnless(c in h, "missing spline curve in history.")


        c.setLocalScale(3.)
        self.failUnless(c.getCenterPoint().getLocalScale() == 3., "new local scale of center point is wrong.")
        self.failUnless(c.getStartPoint().getLocalScale() == 3., "new local scale of start point is wrong.")
        self.failUnless(c.getEndPoint().getLocalScale() == 3., "new local scale of end point is wrong.")

        cp=c.copy()
        self.failUnless(isinstance(cp,Arc), "copy returns is not an arc.")
        self.failUnless(not cp == c, "copy returns same arc.")
        self.failUnless(cp.isColocated(Arc(center,p_start,p_end)),"arc is not colocated with its copy.")
        self.failUnless(not cp.getCenterPoint()==center, "deep copy has same center point like source")
        self.failUnless(not cp.getStartPoint()==p_start, "deep copy has same start point like source")
        self.failUnless(not cp.getEndPoint()==p_end, "deep copy has same end point like source")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(Arc(Point(0,0,0),Point(-1,-1,-1),Point(-1,-2,-3))),"inplace dilation is wrong.")
        self.failUnless(c.getCenterPoint() == center,"wrong center point after dilation.")
        self.failUnless(c.getStartPoint() == p_start,"wrong start point after dilation.")
        self.failUnless(c.getEndPoint() == p_end,"wrong end point after dilation.")

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(Arc(Point(0,0,0),Point(1,1,1),Point(1,2,3))),"dilation is wrong.")
        self.failUnless(not dc.getCenterPoint() == center,"center point of dilation is identical to source.")
        self.failUnless(dc.getCenterPoint().isColocated(Point(0,0,0)),"center point of dilation is wrong.")
        self.failUnless(not dc.getStartPoint() == p_start,"start point of dilation is identical to source.")
        self.failUnless(dc.getStartPoint().isColocated(Point(1,1,1)),"start point of dilation is wrong.")
        self.failUnless(not dc.getEndPoint() == p_end,"end point of dilation is identical to source.")
        self.failUnless(dc.getEndPoint().isColocated(Point(1,2,3)),"end point of dilation is wrong.")

   def test_ReverseArc(self):
        center=Point(0,0,0,0.1)
        p_start=Point(1,1,1,0.2)
        p_end=Point(1,2,3)
        p4=Point(10,2,3)
 
        self.failUnlessRaises(TypeError,Arc,Primitive())

        CC0=Arc(center,p_start,p_end)
        c=-CC0

        self.failUnless(c.getCenterPoint()==center, "wrong center point")
        self.failUnless(c.getStartPoint()==p_end, "wrong start point")
        self.failUnless(c.getEndPoint()==p_start, "wrong end point")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        code=c.getGmshCommand() 
        self.failUnless(code == "Circle(6) = {2, 1, 3};", "gmsh command wrong.")

        self.failUnless(not c.isColocated(p4),"spline is colocated with point.")
        self.failUnless(not c.isColocated(Arc(p4,p_start,p_end)),"spline is colocated with spline with differnt center point.")
        self.failUnless(not c.isColocated(Arc(center,p4,p_end)),"spline is colocated with spline with differnt start point.")
        self.failUnless(not c.isColocated(Arc(center,p_start,p4)),"spline is colocated with spline with differnt end point.")
        self.failUnless(c.isColocated(Arc(center,p_start,p_end)),"spline is not colocated with spline with same points.")
        self.failUnless(c.isColocated(Arc(center,p_end,p_start)),"spline is not colocated with spline with same points but opposite direction.")
        self.failUnless(not c.isColocated(Curve(center,p_start,p_end)),"spline curve is identified with curve.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 4, "number of primitives in history is wrong.")
        self.failUnless(center in h, "missing center in history.")
        self.failUnless(p_start in h, "missing p_start in history.")
        self.failUnless(p_end in h, "missing p_end in history.")
        self.failUnless(CC0 in h, "missing spline curve in history.")


        c.setLocalScale(3.)
        self.failUnless(c.getCenterPoint().getLocalScale() == 3., "new local scale of center point is wrong.")
        self.failUnless(c.getStartPoint().getLocalScale() == 3., "new local scale of start point is wrong.")
        self.failUnless(c.getEndPoint().getLocalScale() == 3., "new local scale of end point is wrong.")

        cp=c.copy()
        self.failUnless(isinstance(cp,ReverseArc), "copy returns is not an arc.")
        self.failUnless(not cp == c, "copy returns same arc.")
        self.failUnless(cp.isColocated(Arc(center,p_end,p_start)),"arc is not colocated with its copy.")
        self.failUnless(not cp.getCenterPoint()==center, "deep copy has same center point like source")
        self.failUnless(not cp.getStartPoint()==p_start, "deep copy has same start point like source")
        self.failUnless(not cp.getEndPoint()==p_end, "deep copy has same end point like source")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(Arc(Point(0,0,0),Point(-1,-1,-1),Point(-1,-2,-3))),"inplace dilation is wrong.")
        self.failUnless(c.getCenterPoint() == center,"wrong center point after dilation.")
        self.failUnless(c.getStartPoint() == p_end,"wrong start point after dilation.")
        self.failUnless(c.getEndPoint() == p_start,"wrong end point after dilation.")

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(Arc(Point(0,0,0),Point(1,1,1),Point(1,2,3))),"dilation is wrong.")
        self.failUnless(not dc.getCenterPoint() == center,"center point of dilation is identical to source.")
        self.failUnless(dc.getCenterPoint().isColocated(Point(0,0,0)),"center point of dilation is wrong.")
        self.failUnless(not dc.getStartPoint() == p_start,"start point of dilation is identical to source.")
        self.failUnless(dc.getStartPoint().isColocated(Point(1,2,3)),"start point of dilation is wrong.")
        self.failUnless(not dc.getEndPoint() == p_end,"end point of dilation is identical to source.")
        self.failUnless(dc.getEndPoint().isColocated(Point(1,1,1)),"end point of dilation is wrong.")

   def test_CurveLoop(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
        p5=Point(10,20,3)
        p6=Point(1,2,30)

        l01=Line(p0,p1)
        l12=Arc(p3,p1,p2)
        l20=Spline(p2,p4,p0)

        lx=Line(p2,p3)
        ly=Line(p3,p1)

        c=CurveLoop(l01,l12,l20)
        c=CurveLoop(l01,l20,l12)
        self.failUnlessRaises(TypeError,ValueError,CurveLoop,l01,lx,l20,msg="loop detected.")
        self.failUnlessRaises(TypeError,ValueError,CurveLoop,l01,l20,l20,msg="douple not detected.")
        self.failUnlessRaises(TypeError,ValueError,CurveLoop,l01,l20,ly,msg="loop detected.")

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        code=c.getGmshCommand() 
        self.failUnless(code == "Line Loop(14) = {8, 9, 10};", "gmsh command wrong.")

        self.failUnless(not c.isColocated(p4),"CurveLoop is colocated with point.")
        self.failUnless(c.isColocated(c),"CurveLoop is not colocated with its self.")
        self.failUnless(c.isColocated(CurveLoop(l01,l12,l20)),"CurveLoop is not colocated with its copy.")
        self.failUnless(c.isColocated(CurveLoop(l20,l01,l12)),"CurveLoop is not colocated with its copy with shifted points.")
        self.failUnless(c.isColocated(CurveLoop(l20,l12,l01)),"CurveLoop is not colocated with its copy with shuffled points.")
        self.failUnless(not c.isColocated(CurveLoop(lx,ly,l12)),"CurveLoop is colocated with different CurveLoop.")

        self.failUnless(len(c) == 3, "wrong length")

        c.setLocalScale(3.)
        self.failUnless(p0.getLocalScale()==3., "p0 has wrong local scale.")
        self.failUnless(p1.getLocalScale()==3., "p1 has wrong local scale.")
        self.failUnless(p2.getLocalScale()==3., "p2 has wrong local scale.")
        self.failUnless(p4.getLocalScale()==3., "p4 has wrong local scale.")


        cc=c.getCurves()
        self.failUnless(len(cc) == 3, "too many curves.")
        self.failUnless(l01 in cc, "l01 is missing")
        self.failUnless(l12 in cc, "l12 is missing")
        self.failUnless(l20 in cc, "l20 is missing")

        p=c.getPrimitives()
        self.failUnless(len(p) == 9, "too many primitives.")
        self.failUnless(l01 in p, "l01 is missing")
        self.failUnless(l12 in p, "l21 is missing")
        self.failUnless(l20 in p, "l20 is missing")
        self.failUnless(p0 in p, "p0 is missing")
        self.failUnless(p1 in p, "p1 is missing")
        self.failUnless(p2 in p, "p2 is missing")
        self.failUnless(p3 in p, "p3 is missing")
        self.failUnless(p4 in p, "p4 is missing")

        cp=c.copy()
        self.failUnless(isinstance(cp,CurveLoop), "copy returns is not an arc.")
        self.failUnless(not cp == c, "copy equals source")
        self.failUnless(cp.isColocated(c),"copy is not colocated with its source.")
        cc=cp.getCurves()
        self.failUnless(len(cc) == 3, "too many primitives in copy.")
        self.failUnless(not l01 in cc,"copy uses l01.")
        self.failUnless(not l12 in cc,"copy uses l12.")
        self.failUnless(not l20 in cc,"copy uses l20.")
         
        p0_m=Point(0,0,0)
        p1_m=Point(-1,-1,-1)
        p2_m=Point(-2,-2,-2)
        p3_m=Point(-3,-3,-3)
        p4_m=Point(-1,-2,-3)

        l01_m=Line(p0_m,p1_m)
        l12_m=Arc(p3_m,p1_m,p2_m)
        l20_m=Spline(p2_m,p4_m,p0_m)

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(CurveLoop(l01_m,l12_m,l20_m)),"dilation is wrong.")
        cc=dc.getCurves()
        self.failUnless(len(cc) == 3, "too many primitives in dilation result.")
        self.failUnless(not l01 in cc,"l01 is in dilation result.")
        self.failUnless(not l12 in cc,"l12 is in dilation result.")
        self.failUnless(not l20 in cc,"l20 is in dilation result.")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(CurveLoop(l01_m,l12_m,l20_m)),"inplace dilation is wrong.")
        cc=c.getCurves()
        self.failUnless(len(cc) == 3, "too many primitives in modified object.")
        self.failUnless(l01 in cc,"l01 missed in  modified object.")
        self.failUnless(cc[cc.index(l01)].hasSameOrientation(l01),"l01 in modified object has wrong orientation.")
        self.failUnless(l12 in cc,"l12 missed in  modified object.")
        self.failUnless(cc[cc.index(l12)].hasSameOrientation(l12),"l12 in modified object has wrong orientation.")
        self.failUnless(l20 in cc,"l20 missed in  modified object.")
        self.failUnless(cc[cc.index(l20)].hasSameOrientation(l20),"l20 in modified object has wrong orientation.")
      
   def test_ReverseCurveLoop(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
        p5=Point(10,20,3)
        p6=Point(1,2,30)

        l01=Line(p0,p1)
        l12=Arc(p3,p1,p2)
        l20=Spline(p2,p4,p0)

        lx=Line(p2,p3)
        ly=Line(p3,p1)

        CC0=CurveLoop(l01,l20,l12)
        c=-CC0

        self.failUnless(c.hasSameOrientation(c),"has not same orientation like itself")
        self.failUnless(not c.hasSameOrientation(-c),"has same orientation like -itself")

        code=c.getGmshCommand() 
        self.failUnless(code == "Line Loop(13) = {8, 9, 10};", "gmsh command wrong.")


        self.failUnless(not c.isColocated(p4),"-CurveLoop is colocated with point.")
        self.failUnless(c.isColocated(c),"-CurveLoop is not colocated with its self.")
        self.failUnless(c.isColocated(CurveLoop(l01,l12,l20)),"-CurveLoop is not colocated with its copy.")
        self.failUnless(c.isColocated(CurveLoop(l20,l01,l12)),"-CurveLoop is not colocated with its copy with shifted points.")
        self.failUnless(c.isColocated(CurveLoop(l20,l12,l01)),"-CurveLoop is not colocated with its copy with shuffled points.")
        self.failUnless(not c.isColocated(CurveLoop(lx,ly,l12)),"-CurveLoop is colocated with different CurveLoop.")

        self.failUnless(len(c) == 3, "wrong length")

        c.setLocalScale(3.)
        self.failUnless(p0.getLocalScale()==3., "p0 has wrong local scale.")
        self.failUnless(p1.getLocalScale()==3., "p1 has wrong local scale.")
        self.failUnless(p2.getLocalScale()==3., "p2 has wrong local scale.")
        self.failUnless(p4.getLocalScale()==3., "p4 has wrong local scale.")


        cc=c.getCurves()
        self.failUnless(len(cc) == 3, "too many curves.")
        self.failUnless(l01 in cc, "l01 is missing")
        self.failUnless(l12 in cc, "l12 is missing")
        self.failUnless(l20 in cc, "l20 is missing")

        p=c.getPrimitives()
        self.failUnless(len(p) == 9, "too many primitives.")
        self.failUnless(l01 in p, "l01 is missing")
        self.failUnless(l12 in p, "l21 is missing")
        self.failUnless(l20 in p, "l20 is missing")
        self.failUnless(p0 in p, "p0 is missing")
        self.failUnless(p1 in p, "p1 is missing")
        self.failUnless(p2 in p, "p2 is missing")
        self.failUnless(p3 in p, "p3 is missing")
        self.failUnless(p4 in p, "p4 is missing")

        cp=c.copy()
        self.failUnless(isinstance(cp,ReverseCurveLoop), "copy returns is not an ReverseCurveLoop.")
        self.failUnless(not cp == c, "copy equals source")
        self.failUnless(cp.isColocated(c),"copy is not colocated with its source.")
        cc=cp.getCurves()
        self.failUnless(len(cc) == 3, "too many primitives in copy.")
        self.failUnless(not l01 in cc,"copy uses l01.")
        self.failUnless(not l12 in cc,"copy uses l12.")
        self.failUnless(not l20 in cc,"copy uses l20.")
         
        p0_m=Point(0,0,0)
        p1_m=Point(-1,-1,-1)
        p2_m=Point(-2,-2,-2)
        p3_m=Point(-3,-3,-3)
        p4_m=Point(-1,-2,-3)

        l01_m=Line(p0_m,p1_m)
        l12_m=Arc(p3_m,p1_m,p2_m)
        l20_m=Spline(p2_m,p4_m,p0_m)

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(CurveLoop(l01_m,l12_m,l20_m)),"dilation is wrong.")
        cc=dc.getCurves()
        self.failUnless(len(cc) == 3, "too many primitives in dilation result.")
        self.failUnless(not l01 in cc,"l01 is in dilation result.")
        self.failUnless(not l12 in cc,"l12 is in dilation result.")
        self.failUnless(not l20 in cc,"l20 is in dilation result.")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(CurveLoop(l01_m,l12_m,l20_m)),"inplace dilation is wrong.")
        cc=c.getCurves()
        self.failUnless(len(cc) == 3, "too many primitives in modified object.")
        self.failUnless(l01 in cc,"l01 missed in  modified object.")
        self.failUnless(cc[cc.index(l01)].hasSameOrientation(-l01),"l01 in modified object has wrong orientation.")
        self.failUnless(l12 in cc,"l12 missed in  modified object.")
        self.failUnless(cc[cc.index(l12)].hasSameOrientation(-l12),"l12 in modified object has wrong orientation.")
        self.failUnless(l20 in cc,"l20 missed in  modified object.")
        self.failUnless(cc[cc.index(l20)].hasSameOrientation(-l20),"l20 in modified object has wrong orientation.")
      
   def test_RuledSurface(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
        p5=Point(10,20,3)
        p6=Point(1,2,30)

        l01=Line(p0,p1)
        l12_1=Arc(p3,p1,p2)
        l12_2_1=Spline(p1,p3,p4)
        l12_2_2=Spline(p4,p5,p2)
        l12_3=Line(p1,p2)
        l20=Spline(p2,p4,p0)

        cl1=CurveLoop(l01,l12_1,l20) 
        cl2=CurveLoop(l01,l12_2_1,l12_2_2,l20)
        cl3=CurveLoop(l01,l12_3,l20)

        self.failUnlessRaises(TypeError,ValueError,RuledSurface,l01,msg="non CurveLoop argument accepted.")

        s=RuledSurface(cl1)

        cl=s.getBoundaryLoop()
        self.failUnless(cl == cl1, " wrong boundary loops")
        self.failUnless(cl.hasSameOrientation(cl1),"cl1 has incorrect orientation.")

        self.failUnless(s.hasSameOrientation(s),"has not same orientation like itself")
        self.failUnless(not s.hasSameOrientation(-s),"has same orientation like -itself")

        crvs=s.getBoundary()
        self.failUnless(len(crvs) == 3, "too many boundary corves.")
        self.failUnless(l01 in crvs, "l01 is missing in boundary")
        self.failUnless(crvs[crvs.index(l01)].hasSameOrientation(l01),"l01 has incorrect orientation.")
        self.failUnless(l12_1 in crvs, "l21 is missing in boundary")
        self.failUnless(crvs[crvs.index(l12_1)].hasSameOrientation(l12_1),"l12_1 has incorrect orientation.")
        self.failUnless(l20 in crvs, "l20 is missing in boundary")
        self.failUnless(crvs[crvs.index(l20)].hasSameOrientation(l20),"l12_1 has incorrect orientation.")
               

        code=s.getGmshCommand() 
        self.failUnless(code == "Ruled Surface(17) = {14};", "gmsh command wrong.")

        self.failUnless(not s.isColocated(p4),"RuledSurface is colocated with point.")
        self.failUnless(s.isColocated(s),"RuledSurface is not colocated with its self.")
        self.failUnless(s.isColocated(RuledSurface(cl1)),"RuledSurface is not colocated with its copy.")
        self.failUnless(not s.isColocated(RuledSurface(cl2)),"RuledSurface is colocated with different length")
        self.failUnless(not s.isColocated(RuledSurface(cl3)),"RuledSurface is colocated with same length.")

        s.setLocalScale(3.)
        self.failUnless(p0.getLocalScale()==3., "p0 has wrong local scale.")
        self.failUnless(p1.getLocalScale()==3., "p1 has wrong local scale.")
        self.failUnless(p2.getLocalScale()==3., "p2 has wrong local scale.")
        self.failUnless(p4.getLocalScale()==3., "p4 has wrong local scale.")

        p=s.getPrimitives()
        self.failUnless(len(p) == 10, "too many primitives.")
        self.failUnless(cl1 in p, "cl1 is missing")
        self.failUnless(l01 in p, "l01 is missing")
        self.failUnless(l12_1 in p, "l21 is missing")
        self.failUnless(l20 in p, "l20 is missing")
        self.failUnless(p0 in p, "p0 is missing")
        self.failUnless(p1 in p, "p1 is missing")
        self.failUnless(p2 in p, "p2 is missing")
        self.failUnless(p3 in p, "p3 is missing")
        self.failUnless(p4 in p, "p4 is missing")

        sp=s.copy()
        self.failUnless(isinstance(sp,RuledSurface), "copy returns is not a RuledSurface.")
        self.failUnless(not sp == s, "copy equals source")
        self.failUnless(sp.isColocated(s),"copy is not colocated with its source.")
        cbl=sp.getBoundaryLoop()
        self.failUnless(not cbl == cl1,"copy uses cl1.")
        cp=sp.getPrimitives()
        self.failUnless(len(cp) == 10, "copy as too many primitives.")
        self.failUnless(not cl1 in cp, "copy is using cl1")
        self.failUnless(not l01 in cp, "copy is using l01")
        self.failUnless(not l12_1 in cp, "copy is using l21")
        self.failUnless(not l20 in cp, "copy is using l20")
        self.failUnless(not p0 in cp, "copy is using p0")
        self.failUnless(not p1 in cp, "copy is using p1")
        self.failUnless(not p2 in cp, "copy is using p2")
        self.failUnless(not p3 in cp, "copy is using p3")
        self.failUnless(not p4 in cp, "copy is using p4")
        del cp
         
        p0_m=Point(0,0,0)
        p1_m=Point(-1,-1,-1)
        p2_m=Point(-2,-2,-2)
        p3_m=Point(-3,-3,-3)
        p4_m=Point(-1,-2,-3)

        l01_m=Line(p0_m,p1_m)
        l12_m=Arc(p3_m,p1_m,p2_m)
        l20_m=Spline(p2_m,p4_m,p0_m)

        ds=s.apply(Dilation(-1.))
        self.failUnless(ds.isColocated(RuledSurface(CurveLoop(l01_m,l12_m,l20_m))),"dilation is wrong.")
        cbl=ds.getBoundaryLoop()
        self.failUnless(not cbl == cl1,"dilation uses cl1.")
        cp=ds.getPrimitives()
        self.failUnless(len(cp) == 10, "dilation as too many primitives.")
        self.failUnless(not cl1 in cp, "dilation is using cl1")
        self.failUnless(not l01 in cp, "dilation is using l01")
        self.failUnless(not l12_1 in cp, "dilation is using l21")
        self.failUnless(not l20 in cp, "dilation is using l20")
        self.failUnless(not p0 in cp, "dilation is using p0")
        self.failUnless(not p1 in cp, "dilation is using p1")
        self.failUnless(not p2 in cp, "dilation is using p2")
        self.failUnless(not p3 in cp, "dilation is using p3")
        self.failUnless(not p4 in cp, "dilation is using p4")

        s.modifyBy(Dilation(-1.))
        self.failUnless(s.isColocated(RuledSurface(CurveLoop(l01_m,l12_m,l20_m))),"inplace dilation is wrong.")

        p=s.getPrimitives()
        self.failUnless(len(p) == 10, "inplace dilation has too many primitives.")
        self.failUnless(cl1 in p, "inplace dilation cl1 is missing")
        self.failUnless(l01 in p, "inplace dilation l01 is missing")
        self.failUnless(l12_1 in p, "inplace dilation l21 is missing")
        self.failUnless(l20 in p, "inplace dilation l20 is missing")
        self.failUnless(p0 in p, "inplace dilation p0 is missing")
        self.failUnless(p1 in p, "inplace dilation p1 is missing")
        self.failUnless(p2 in p, "inplace dilation p2 is missing")
        self.failUnless(p3 in p, "inplace dilation p3 is missing")
        self.failUnless(p4 in p, "inplace dilation p4 is missing")

        p=s.getBoundary()
        self.failUnless(len(p) == 3, "inplace dilation has too many boundary curves.")
        self.failUnless(l01 in p, "inplace dilation l01 is missing in boundary curves.")
        self.failUnless(p[p.index(l01)].hasSameOrientation(l01),"l01 in getBoundary after dilation has incorrect orientation.")
        self.failUnless(l12_1 in p, "inplace dilation l21 is missing")
        self.failUnless(p[p.index(l12_1)].hasSameOrientation(l12_1),"l12_1 in getBoundary after dilation has incorrect orientation.")
        self.failUnless(l20 in p, "inplace dilation l20 is missing")
        self.failUnless(p[p.index(l20)].hasSameOrientation(l20),"l20 in getBoundary after dilation has incorrect orientation.")

        p=s.getBoundaryLoop()
        self.failUnless(cl1 == p, "inplace dilation s.getBoundaryLoop does not return cl1")
        self.failUnless(p.hasSameOrientation(cl1),"cl1 in getBoundaryLoop after dilation has incorrect orientation.")

   def test_ReverseRuledSurface(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
        p5=Point(10,20,3)
        p6=Point(1,2,30)

        l01=Line(p0,p1)
        l12_1=Arc(p3,p1,p2)
        l12_2_1=Spline(p1,p3,p4)
        l12_2_2=Spline(p4,p5,p2)
        l12_3=Line(p1,p2)
        l20=Spline(p2,p4,p0)

        cl1=CurveLoop(l01,l12_1,l20) 
        cl2=CurveLoop(l01,l12_2_1,l12_2_2,l20)
        cl3=CurveLoop(l01,l12_3,l20)

        self.failUnlessRaises(TypeError,ValueError,RuledSurface,l01,msg="non CurveLoop argument accepted.")

        CC0=RuledSurface(cl1)
        s=-CC0

        cl=s.getBoundaryLoop()
        self.failUnless(cl == cl1, " wrong boundary loops")
        self.failUnless(cl.hasSameOrientation(-cl1),"cl1 has incorrect orientation.")

        self.failUnless(s.hasSameOrientation(s),"has not same orientation like itself")
        self.failUnless(not s.hasSameOrientation(-s),"has same orientation like -itself")

        crvs=s.getBoundary()
        self.failUnless(len(crvs) == 3, "too many boundary corves.")
        self.failUnless(l01 in crvs, "l01 is missing in boundary")
        self.failUnless(crvs[crvs.index(l01)].hasSameOrientation(-l01),"l01 has incorrect orientation.")
        self.failUnless(l12_1 in crvs, "l21 is missing in boundary")
        self.failUnless(crvs[crvs.index(l12_1)].hasSameOrientation(-l12_1),"l12_1 has incorrect orientation.")
        self.failUnless(l20 in crvs, "l20 is missing in boundary")
        self.failUnless(crvs[crvs.index(l20)].hasSameOrientation(-l20),"l12_1 has incorrect orientation.")
               

        code=s.getGmshCommand() 
        self.failUnless(code == "Ruled Surface(17) = {14};", "gmsh command wrong.")

        self.failUnless(not s.isColocated(p4),"RuledSurface is colocated with point.")
        self.failUnless(s.isColocated(s),"RuledSurface is not colocated with its self.")
        self.failUnless(s.isColocated(RuledSurface(cl1)),"RuledSurface is not colocated with its copy.")
        self.failUnless(not s.isColocated(RuledSurface(cl2)),"RuledSurface is colocated with different length")
        self.failUnless(not s.isColocated(RuledSurface(cl3)),"RuledSurface is colocated with same length.")

        s.setLocalScale(3.)
        self.failUnless(p0.getLocalScale()==3., "p0 has wrong local scale.")
        self.failUnless(p1.getLocalScale()==3., "p1 has wrong local scale.")
        self.failUnless(p2.getLocalScale()==3., "p2 has wrong local scale.")
        self.failUnless(p4.getLocalScale()==3., "p4 has wrong local scale.")

        p=s.getPrimitives()
        self.failUnless(len(p) == 10, "too many primitives.")
        self.failUnless(cl1 in p, "cl1 is missing")
        self.failUnless(l01 in p, "l01 is missing")
        self.failUnless(l12_1 in p, "l21 is missing")
        self.failUnless(l20 in p, "l20 is missing")
        self.failUnless(p0 in p, "p0 is missing")
        self.failUnless(p1 in p, "p1 is missing")
        self.failUnless(p2 in p, "p2 is missing")
        self.failUnless(p3 in p, "p3 is missing")
        self.failUnless(p4 in p, "p4 is missing")

        sp=s.copy()
        self.failUnless(isinstance(sp,ReverseRuledSurface), "copy returns is not a RuledSurface.")
        self.failUnless(not sp == s, "copy equals source")
        self.failUnless(sp.isColocated(s),"copy is not colocated with its source.")
        cbl=sp.getBoundaryLoop()
        self.failUnless(not cbl == cl1,"copy uses cl1.")
        cp=sp.getPrimitives()
        self.failUnless(len(cp) == 10, "copy as too many primitives.")
        self.failUnless(not cl1 in cp, "copy is using cl1")
        self.failUnless(not l01 in cp, "copy is using l01")
        self.failUnless(not l12_1 in cp, "copy is using l21")
        self.failUnless(not l20 in cp, "copy is using l20")
        self.failUnless(not p0 in cp, "copy is using p0")
        self.failUnless(not p1 in cp, "copy is using p1")
        self.failUnless(not p2 in cp, "copy is using p2")
        self.failUnless(not p3 in cp, "copy is using p3")
        self.failUnless(not p4 in cp, "copy is using p4")
        del cp
         
        p0_m=Point(0,0,0)
        p1_m=Point(-1,-1,-1)
        p2_m=Point(-2,-2,-2)
        p3_m=Point(-3,-3,-3)
        p4_m=Point(-1,-2,-3)

        l01_m=Line(p0_m,p1_m)
        l12_m=Arc(p3_m,p1_m,p2_m)
        l20_m=Spline(p2_m,p4_m,p0_m)

        ds=s.apply(Dilation(-1.))
        self.failUnless(ds.isColocated(RuledSurface(CurveLoop(l01_m,l12_m,l20_m))),"dilation is wrong.")
        cbl=ds.getBoundaryLoop()
        self.failUnless(not cbl == cl1,"dilation uses cl1.")
        cp=ds.getPrimitives()
        self.failUnless(len(cp) == 10, "dilation as too many primitives.")
        self.failUnless(not cl1 in cp, "dilation is using cl1")
        self.failUnless(not l01 in cp, "dilation is using l01")
        self.failUnless(not l12_1 in cp, "dilation is using l21")
        self.failUnless(not l20 in cp, "dilation is using l20")
        self.failUnless(not p0 in cp, "dilation is using p0")
        self.failUnless(not p1 in cp, "dilation is using p1")
        self.failUnless(not p2 in cp, "dilation is using p2")
        self.failUnless(not p3 in cp, "dilation is using p3")
        self.failUnless(not p4 in cp, "dilation is using p4")

        s.modifyBy(Dilation(-1.))
        self.failUnless(s.isColocated(RuledSurface(CurveLoop(l01_m,l12_m,l20_m))),"inplace dilation is wrong.")

        p=s.getPrimitives()
        self.failUnless(len(p) == 10, "inplace dilation has too many primitives.")
        self.failUnless(cl1 in p, "inplace dilation cl1 is missing")
        self.failUnless(l01 in p, "inplace dilation l01 is missing")
        self.failUnless(l12_1 in p, "inplace dilation l21 is missing")
        self.failUnless(l20 in p, "inplace dilation l20 is missing")
        self.failUnless(p0 in p, "inplace dilation p0 is missing")
        self.failUnless(p1 in p, "inplace dilation p1 is missing")
        self.failUnless(p2 in p, "inplace dilation p2 is missing")
        self.failUnless(p3 in p, "inplace dilation p3 is missing")
        self.failUnless(p4 in p, "inplace dilation p4 is missing")

        p=s.getBoundary()
        self.failUnless(len(p) == 3, "inplace dilation has too many boundary curves.")
        self.failUnless(l01 in p, "inplace dilation l01 is missing in boundary curves.")
        self.failUnless(p[p.index(l01)].hasSameOrientation(-l01),"l01 in getBoundary after dilation has incorrect orientation.")
        self.failUnless(l12_1 in p, "inplace dilation l21 is missing")
        self.failUnless(p[p.index(l12_1)].hasSameOrientation(-l12_1),"l12_1 in getBoundary after dilation has incorrect orientation.")
        self.failUnless(l20 in p, "inplace dilation l20 is missing")
        self.failUnless(p[p.index(l20)].hasSameOrientation(-l20),"l20 in getBoundary after dilation has incorrect orientation.")

        p=s.getBoundaryLoop()
        self.failUnless(cl1 == p, "inplace dilation s.getBoundaryLoop does not return cl1")
        self.failUnless(p.hasSameOrientation(-cl1),"cl1 in getBoundaryLoop after dilation has incorrect orientation.")


   def test_PlaneSurface(self):
        p0=Point(0,0,0,0.1)
        p1=Point(10,0,0,0.2)
        p2=Point(10,10,0,0.3)
        p3=Point(0,10,3,0.4)
        p4=Point(5,5,0,0.001)
        p5=Point(7,5,0,0.001)
        p6=Point(5,7,0,0.001)
        p7=Point(8,8,0,0.001)
        p8=Point(9,9,0,0.001)

        l0=Line(p0,p1)
        l1=Line(p1,p2)
        l2=Line(p2,p3)
        l3=Line(p3,p0)

        l9=Line(p1,p8)
        l10=Line(p8,p3)

        l4=Line(p4,p5)
        l5=Line(p5,p6)
        l6=Line(p6,p4)
        l7=Line(p6,p7)
        l8=Line(p7,p4)

        a1=Arc(p4,p3,p1)
        a2=Arc(p7,p5,p6)

        cl=CurveLoop(l0,l1,l2,l3)
        h=CurveLoop(l4,l5,l6)
        cl_s=CurveLoop(l0,l9,l10,l3)
        h2=CurveLoop(l4,l5,l7,l8)
        cl_a=CurveLoop(a1,l1,l2)
        h_a=CurveLoop(a2,l6,l4)

        self.failUnlessRaises(TypeError,ValueError,PlaneSurface,l4,msg="non CurveLoop argument accepted.")
        self.failUnlessRaises(TypeError,ValueError,PlaneSurface,cl_a,h,msg="CurveLoop with no line curves accepted.")
        self.failUnlessRaises(TypeError,ValueError,PlaneSurface,cl,[h_a],msg="CurveLoop with no line curves as holes accepted.")

        s=PlaneSurface(cl,holes=[h])

        cl2=s.getBoundaryLoop()
        self.failUnless(cl == cl2, " wrong boundary loops")
        self.failUnless(cl.hasSameOrientation(cl2),"cl has incorrect orientation.")

        hs=s.getHoles()
        self.failUnless(len(hs) == 1, "one holes expected.")
        self.failUnless(h==hs[0], "h is not defined as hole.")
        self.failUnless(hs[0].hasSameOrientation(h),"hs has incorrect orientation.")

        self.failUnless(s.hasSameOrientation(s),"has not same orientation like itself")
        self.failUnless(not s.hasSameOrientation(-s),"has same orientation like -itself")

        crvs=s.getBoundary()
        self.failUnless(len(crvs) == 7, "too many boundary corves.")
        self.failUnless(l0 in crvs, "l0 is missing in boundary")
        self.failUnless(crvs[crvs.index(l0)].hasSameOrientation(l0),"l0 has incorrect orientation.")
        self.failUnless(l1 in crvs, "l1 is missing in boundary")
        self.failUnless(crvs[crvs.index(l1)].hasSameOrientation(l1),"l1 has incorrect orientation.")
        self.failUnless(l2 in crvs, "l2 is missing in boundary")
        self.failUnless(crvs[crvs.index(l2)].hasSameOrientation(l2),"l2 has incorrect orientation.")
        self.failUnless(l3 in crvs, "l3 is missing in boundary")
        self.failUnless(crvs[crvs.index(l3)].hasSameOrientation(l3),"l3 has incorrect orientation.")
        self.failUnless(l4 in crvs, "l4 is missing in boundary")
        self.failUnless(crvs[crvs.index(l4)].hasSameOrientation(l4),"l4 has incorrect orientation.")
        self.failUnless(l5 in crvs, "l5 is missing in boundary")
        self.failUnless(crvs[crvs.index(l5)].hasSameOrientation(l5),"l5 has incorrect orientation.")
        self.failUnless(l6 in crvs, "l6 is missing in boundary")
        self.failUnless(crvs[crvs.index(l6)].hasSameOrientation(l6),"l6 has incorrect orientation.")
               
        code=s.getGmshCommand() 
        self.failUnless(code == "Plane Surface(29) = {23, 24};", "gmsh command wrong.")

        self.failUnless(not s.isColocated(p4),"PlaneSurface is colocated with point.")
        self.failUnless(s.isColocated(s),"PlaneSurface is not colocated with its self.")
        self.failUnless(s.isColocated(PlaneSurface(cl,holes=[h])),"PlaneSurface is not colocated with its copy.")
        self.failUnless(not s.isColocated(PlaneSurface(cl)),"PlaneSurface is colocated with PlaneSurface with same boundary but no hole")
        self.failUnless(not s.isColocated(PlaneSurface(cl_s,holes=[h])),"PlaneSurface is colocated with PlaneSurface with deformed boundary")
        self.failUnless(not s.isColocated(PlaneSurface(cl,holes=[h2])),"PlaneSurface is colocated with modified hole")

        s.setLocalScale(3.)
        self.failUnless(p0.getLocalScale()==3., "p0 has wrong local scale.")
        self.failUnless(p1.getLocalScale()==3., "p1 has wrong local scale.")
        self.failUnless(p2.getLocalScale()==3., "p2 has wrong local scale.")
        self.failUnless(p3.getLocalScale()==3., "p3 has wrong local scale.")
        self.failUnless(p4.getLocalScale()==3., "p4 has wrong local scale.")
        self.failUnless(p5.getLocalScale()==3., "p5 has wrong local scale.")
        self.failUnless(p6.getLocalScale()==3., "p6 has wrong local scale.")

        p=s.getPrimitives()
        self.failUnless(len(p) == 17, "too many primitives.")
        self.failUnless(s in p, "cl is missing")
        self.failUnless(cl in p, "cl is missing")
        self.failUnless(h in p, "h is missing")
        self.failUnless(l0 in p, "l0 is missing")
        self.failUnless(l1 in p, "l1 is missing")
        self.failUnless(l2 in p, "l2 is missing")
        self.failUnless(l3 in p, "l3 is missing")
        self.failUnless(l4 in p, "l4 is missing")
        self.failUnless(l5 in p, "l5 is missing")
        self.failUnless(l6 in p, "l6 is missing")
        self.failUnless(p0 in p, "p0 is missing")
        self.failUnless(p1 in p, "p1 is missing")
        self.failUnless(p2 in p, "p2 is missing")
        self.failUnless(p3 in p, "p3 is missing")
        self.failUnless(p4 in p, "p4 is missing")
        self.failUnless(p5 in p, "p5 is missing")
        self.failUnless(p6 in p, "p6 is missing")

        sp=s.copy()
        self.failUnless(isinstance(sp,PlaneSurface), "copy returns is not a PlaneSurface.")
        self.failUnless(not sp == s, "copy equals source")
        self.failUnless(sp.isColocated(s),"copy is not colocated with its source.")
        cbl=sp.getBoundaryLoop()
        self.failUnless(not cbl == cl,"copy uses cl1.")
        hs=sp.getHoles()
        self.failUnless(len(hs)==1,"copy is missing holes.")
        self.failUnless(not hs[0]== h,"copy contains h as a hole.")
        cp=sp.getPrimitives()
        self.failUnless(len(cp) == 17, "copy as too many primitives.")
        self.failUnless(not s in cp, "copy contains s")
        self.failUnless(not cl in cp, "copy contains cl")
        self.failUnless(not h in cp, "copy contains h")
        self.failUnless(not l0 in cp, "copy contains l0")
        self.failUnless(not l1 in cp, "copy contains l1")
        self.failUnless(not l2 in cp, "copy contains l2")
        self.failUnless(not l3 in cp, "copy contains l3")
        self.failUnless(not l4 in cp, "copy contains l4")
        self.failUnless(not l5 in cp, "copy contains l5")
        self.failUnless(not l6 in cp, "copy contains l6")
        self.failUnless(not p0 in cp, "copy contains p0")
        self.failUnless(not p1 in cp, "copy contains p1")
        self.failUnless(not p2 in cp, "copy contains p2")
        self.failUnless(not p3 in cp, "copy contains p3")
        self.failUnless(not p4 in cp, "copy contains p4")
        self.failUnless(not p5 in cp, "copy contains p5")
        self.failUnless(not p6 in cp, "copy contains p6")
        del sp
         

        p0_m=Point(0,0,0,0.1)
        p1_m=Point(-10,0,0,0.2)
        p2_m=Point(-10,-10,0,0.3)
        p3_m=Point(0,-10,-3,0.4)
        p4_m=Point(-5,-5,0,0.001)
        p5_m=Point(-7,-5,0,0.001)
        p6_m=Point(-5,-7,0,0.001)

        l0_m=Line(p0_m,p1_m)
        l1_m=Line(p1_m,p2_m)
        l2_m=Line(p2_m,p3_m)
        l3_m=Line(p3_m,p0_m)

        l4_m=Line(p4_m,p5_m)
        l5_m=Line(p5_m,p6_m)
        l6_m=Line(p6_m,p4_m)

        cl_m=CurveLoop(l0_m,l1_m,l2_m,l3_m)
        h_m=CurveLoop(l4_m,l5_m,l6_m)

        ds=s.apply(Dilation(-1.))
        self.failUnless(ds.isColocated(PlaneSurface(cl_m,holes=[h_m])),"dilation is wrong.")
        cbl=ds.getBoundaryLoop()
        self.failUnless(not cbl == cl,"dilation uses cl1.")
        hs=ds.getHoles()
        self.failUnless(len(hs)==1,"dilation is missing holes.")
        self.failUnless(not hs[0]== h,"dilation contains h as a hole.")
        cp=ds.getPrimitives()
        self.failUnless(len(cp) == 17, "dilation as too many primitives.")
        self.failUnless(not s in cp, "dilation contains s")
        self.failUnless(not cl in cp, "dilation contains cl")
        self.failUnless(not h in cp, "dilation contains h")
        self.failUnless(not l0 in cp, "dilation contains l0")
        self.failUnless(not l1 in cp, "dilation contains l1")
        self.failUnless(not l2 in cp, "dilation contains l2")
        self.failUnless(not l3 in cp, "dilation contains l3")
        self.failUnless(not l4 in cp, "dilation contains l4")
        self.failUnless(not l5 in cp, "dilation contains l5")
        self.failUnless(not l6 in cp, "dilation contains l6")
        self.failUnless(not p0 in cp, "dilation contains p0")
        self.failUnless(not p1 in cp, "dilation contains p1")
        self.failUnless(not p2 in cp, "dilation contains p2")
        self.failUnless(not p3 in cp, "dilation contains p3")
        self.failUnless(not p4 in cp, "dilation contains p4")
        self.failUnless(not p5 in cp, "dilation contains p5")
        self.failUnless(not p6 in cp, "dilation contains p6")

        s.modifyBy(Dilation(-1.))
        self.failUnless(s.isColocated(PlaneSurface(cl_m,holes=[h_m])),"inplace dilation is wrong.")
        cbl=s.getBoundaryLoop()
        self.failUnless(cbl == cl,"inplace dilation does not use cl1.")
        self.failUnless(cl.hasSameOrientation(cbl),"cl has incorrect orientation.")
        hs=s.getHoles()
        self.failUnless(len(hs)==1,"inplace dilation is missing holes.")
        self.failUnless(hs[0]== h,"inplace dilation must contain h as a hole.")
        self.failUnless(hs[0].hasSameOrientation(h),"hole in inplace dilation has incorrect orientation.")

        cp=s.getPrimitives()
        self.failUnless(len(cp) == 17, "inplace dilation as too many primitives.")
        self.failUnless(s in cp, "inplace dilation must use s")
        self.failUnless(cl in cp, "inplace dilation must use cl")
        self.failUnless(h in cp, "inplace dilation must use h")
        self.failUnless(l0 in cp, "inplace dilation must use l0")
        self.failUnless(l1 in cp, "inplace dilation must use l1")
        self.failUnless(l2 in cp, "inplace dilation must use l2")
        self.failUnless(l3 in cp, "inplace dilation must use l3")
        self.failUnless(l4 in cp, "inplace dilation must use l4")
        self.failUnless(l5 in cp, "inplace dilation must use l5")
        self.failUnless(l6 in cp, "inplace dilation must use l6")
        self.failUnless(p0 in cp, "inplace dilation must use p0")
        self.failUnless(p1 in cp, "inplace dilation must use p1")
        self.failUnless(p2 in cp, "inplace dilation must use p2")
        self.failUnless(p3 in cp, "inplace dilation must use p3")
        self.failUnless(p4 in cp, "inplace dilation must use p4")
        self.failUnless(p5 in cp, "inplace dilation must use p5")
        self.failUnless(p6 in cp, "inplace dilation must use p6")

   def test_PlaneSurface(self):
        p0=Point(0,0,0,0.1)
        p1=Point(10,0,0,0.2)
        p2=Point(10,10,0,0.3)
        p3=Point(0,10,3,0.4)
        p4=Point(5,5,0,0.001)
        p5=Point(7,5,0,0.001)
        p6=Point(5,7,0,0.001)
        p7=Point(8,8,0,0.001)
        p8=Point(9,9,0,0.001)

        l0=Line(p0,p1)
        l1=Line(p1,p2)
        l2=Line(p2,p3)
        l3=Line(p3,p0)

        l9=Line(p1,p8)
        l10=Line(p8,p3)

        l4=Line(p4,p5)
        l5=Line(p5,p6)
        l6=Line(p6,p4)
        l7=Line(p6,p7)
        l8=Line(p7,p4)

        a1=Arc(p4,p3,p1)
        a2=Arc(p7,p5,p6)

        cl=CurveLoop(l0,l1,l2,l3)
        h=CurveLoop(l4,l5,l6)
        cl_s=CurveLoop(l0,l9,l10,l3)
        h2=CurveLoop(l4,l5,l7,l8)
        cl_a=CurveLoop(a1,l1,l2)
        h_a=CurveLoop(a2,l6,l4)

        self.failUnlessRaises(TypeError,ValueError,PlaneSurface,l4,msg="non CurveLoop argument accepted.")
        self.failUnlessRaises(TypeError,ValueError,PlaneSurface,cl_a,h,msg="CurveLoop with no line curves accepted.")
        self.failUnlessRaises(TypeError,ValueError,PlaneSurface,cl,[h_a],msg="CurveLoop with no line curves as holes accepted.")

        CC0=PlaneSurface(cl,holes=[h])
        s=-CC0

        cl2=s.getBoundaryLoop()
        self.failUnless(cl == cl2, " wrong boundary loops")
        self.failUnless(cl.hasSameOrientation(-cl2),"cl has incorrect orientation.")

        hs=s.getHoles()
        self.failUnless(len(hs) == 1, "one holes expected.")
        self.failUnless(h==hs[0], "h is not defined as hole.")
        self.failUnless(hs[0].hasSameOrientation(-h),"hs has incorrect orientation.")

        self.failUnless(s.hasSameOrientation(s),"has not same orientation like itself")
        self.failUnless(not s.hasSameOrientation(-s),"has same orientation like -itself")

        crvs=s.getBoundary()
        self.failUnless(len(crvs) == 7, "too many boundary corves.")
        self.failUnless(l0 in crvs, "l0 is missing in boundary")
        self.failUnless(crvs[crvs.index(l0)].hasSameOrientation(-l0),"l0 has incorrect orientation.")
        self.failUnless(l1 in crvs, "l1 is missing in boundary")
        self.failUnless(crvs[crvs.index(l1)].hasSameOrientation(-l1),"l1 has incorrect orientation.")
        self.failUnless(l2 in crvs, "l2 is missing in boundary")
        self.failUnless(crvs[crvs.index(l2)].hasSameOrientation(-l2),"l2 has incorrect orientation.")
        self.failUnless(l3 in crvs, "l3 is missing in boundary")
        self.failUnless(crvs[crvs.index(l3)].hasSameOrientation(-l3),"l3 has incorrect orientation.")
        self.failUnless(l4 in crvs, "l4 is missing in boundary")
        self.failUnless(crvs[crvs.index(l4)].hasSameOrientation(-l4),"l4 has incorrect orientation.")
        self.failUnless(l5 in crvs, "l5 is missing in boundary")
        self.failUnless(crvs[crvs.index(l5)].hasSameOrientation(-l5),"l5 has incorrect orientation.")
        self.failUnless(l6 in crvs, "l6 is missing in boundary")
        self.failUnless(crvs[crvs.index(l6)].hasSameOrientation(-l6),"l6 has incorrect orientation.")
               
        code=s.getGmshCommand() 
        self.failUnless(code == "Plane Surface(29) = {23, 24};", "gmsh command wrong.")

        self.failUnless(not s.isColocated(p4),"PlaneSurface is colocated with point.")
        self.failUnless(s.isColocated(s),"PlaneSurface is not colocated with its self.")
        self.failUnless(s.isColocated(PlaneSurface(cl,holes=[h])),"PlaneSurface is not colocated with its copy.")
        self.failUnless(not s.isColocated(PlaneSurface(cl)),"PlaneSurface is colocated with PlaneSurface with same boundary but no hole")
        self.failUnless(not s.isColocated(PlaneSurface(cl_s,holes=[h])),"PlaneSurface is colocated with PlaneSurface with deformed boundary")
        self.failUnless(not s.isColocated(PlaneSurface(cl,holes=[h2])),"PlaneSurface is colocated with modified hole")

        s.setLocalScale(3.)
        self.failUnless(p0.getLocalScale()==3., "p0 has wrong local scale.")
        self.failUnless(p1.getLocalScale()==3., "p1 has wrong local scale.")
        self.failUnless(p2.getLocalScale()==3., "p2 has wrong local scale.")
        self.failUnless(p3.getLocalScale()==3., "p3 has wrong local scale.")
        self.failUnless(p4.getLocalScale()==3., "p4 has wrong local scale.")
        self.failUnless(p5.getLocalScale()==3., "p5 has wrong local scale.")
        self.failUnless(p6.getLocalScale()==3., "p6 has wrong local scale.")

        p=s.getPrimitives()
        self.failUnless(len(p) == 17, "too many primitives.")
        self.failUnless(s in p, "cl is missing")
        self.failUnless(cl in p, "cl is missing")
        self.failUnless(h in p, "h is missing")
        self.failUnless(l0 in p, "l0 is missing")
        self.failUnless(l1 in p, "l1 is missing")
        self.failUnless(l2 in p, "l2 is missing")
        self.failUnless(l3 in p, "l3 is missing")
        self.failUnless(l4 in p, "l4 is missing")
        self.failUnless(l5 in p, "l5 is missing")
        self.failUnless(l6 in p, "l6 is missing")
        self.failUnless(p0 in p, "p0 is missing")
        self.failUnless(p1 in p, "p1 is missing")
        self.failUnless(p2 in p, "p2 is missing")
        self.failUnless(p3 in p, "p3 is missing")
        self.failUnless(p4 in p, "p4 is missing")
        self.failUnless(p5 in p, "p5 is missing")
        self.failUnless(p6 in p, "p6 is missing")

        sp=s.copy()
        self.failUnless(isinstance(sp,ReversePlaneSurface), "copy returns is not a PlaneSurface.")
        self.failUnless(not sp == s, "copy equals source")
        self.failUnless(sp.isColocated(s),"copy is not colocated with its source.")
        cbl=sp.getBoundaryLoop()
        self.failUnless(not cbl == cl,"copy uses cl1.")
        hs=sp.getHoles()
        self.failUnless(len(hs)==1,"copy is missing holes.")
        self.failUnless(not hs[0]== h,"copy contains h as a hole.")
        cp=sp.getPrimitives()
        self.failUnless(len(cp) == 17, "copy as too many primitives.")
        self.failUnless(not s in cp, "copy contains s")
        self.failUnless(not cl in cp, "copy contains cl")
        self.failUnless(not h in cp, "copy contains h")
        self.failUnless(not l0 in cp, "copy contains l0")
        self.failUnless(not l1 in cp, "copy contains l1")
        self.failUnless(not l2 in cp, "copy contains l2")
        self.failUnless(not l3 in cp, "copy contains l3")
        self.failUnless(not l4 in cp, "copy contains l4")
        self.failUnless(not l5 in cp, "copy contains l5")
        self.failUnless(not l6 in cp, "copy contains l6")
        self.failUnless(not p0 in cp, "copy contains p0")
        self.failUnless(not p1 in cp, "copy contains p1")
        self.failUnless(not p2 in cp, "copy contains p2")
        self.failUnless(not p3 in cp, "copy contains p3")
        self.failUnless(not p4 in cp, "copy contains p4")
        self.failUnless(not p5 in cp, "copy contains p5")
        self.failUnless(not p6 in cp, "copy contains p6")
        del sp
         

        p0_m=Point(0,0,0,0.1)
        p1_m=Point(-10,0,0,0.2)
        p2_m=Point(-10,-10,0,0.3)
        p3_m=Point(0,-10,-3,0.4)
        p4_m=Point(-5,-5,0,0.001)
        p5_m=Point(-7,-5,0,0.001)
        p6_m=Point(-5,-7,0,0.001)

        l0_m=Line(p0_m,p1_m)
        l1_m=Line(p1_m,p2_m)
        l2_m=Line(p2_m,p3_m)
        l3_m=Line(p3_m,p0_m)

        l4_m=Line(p4_m,p5_m)
        l5_m=Line(p5_m,p6_m)
        l6_m=Line(p6_m,p4_m)

        cl_m=CurveLoop(l0_m,l1_m,l2_m,l3_m)
        h_m=CurveLoop(l4_m,l5_m,l6_m)

        ds=s.apply(Dilation(-1.))
        self.failUnless(ds.isColocated(PlaneSurface(cl_m,holes=[h_m])),"dilation is wrong.")
        cbl=ds.getBoundaryLoop()
        self.failUnless(not cbl == cl,"dilation uses cl1.")
        hs=ds.getHoles()
        self.failUnless(len(hs)==1,"dilation is missing holes.")
        self.failUnless(not hs[0]== h,"dilation contains h as a hole.")
        cp=ds.getPrimitives()
        self.failUnless(len(cp) == 17, "dilation as too many primitives.")
        self.failUnless(not s in cp, "dilation contains s")
        self.failUnless(not cl in cp, "dilation contains cl")
        self.failUnless(not h in cp, "dilation contains h")
        self.failUnless(not l0 in cp, "dilation contains l0")
        self.failUnless(not l1 in cp, "dilation contains l1")
        self.failUnless(not l2 in cp, "dilation contains l2")
        self.failUnless(not l3 in cp, "dilation contains l3")
        self.failUnless(not l4 in cp, "dilation contains l4")
        self.failUnless(not l5 in cp, "dilation contains l5")
        self.failUnless(not l6 in cp, "dilation contains l6")
        self.failUnless(not p0 in cp, "dilation contains p0")
        self.failUnless(not p1 in cp, "dilation contains p1")
        self.failUnless(not p2 in cp, "dilation contains p2")
        self.failUnless(not p3 in cp, "dilation contains p3")
        self.failUnless(not p4 in cp, "dilation contains p4")
        self.failUnless(not p5 in cp, "dilation contains p5")
        self.failUnless(not p6 in cp, "dilation contains p6")

        s.modifyBy(Dilation(-1.))
        self.failUnless(s.isColocated(PlaneSurface(cl_m,holes=[h_m])),"inplace dilation is wrong.")
        cbl=s.getBoundaryLoop()
        self.failUnless(cbl == cl,"inplace dilation does not use cl1.")
        self.failUnless(cl.hasSameOrientation(-cbl),"cl has incorrect orientation.")
        hs=s.getHoles()
        self.failUnless(len(hs)==1,"inplace dilation is missing holes.")
        self.failUnless(hs[0]== h,"inplace dilation must contain h as a hole.")
        self.failUnless(hs[0].hasSameOrientation(-h),"hole in inplace dilation has incorrect orientation.")

        cp=s.getPrimitives()
        self.failUnless(len(cp) == 17, "inplace dilation as too many primitives.")
        self.failUnless(s in cp, "inplace dilation must use s")
        self.failUnless(cl in cp, "inplace dilation must use cl")
        self.failUnless(h in cp, "inplace dilation must use h")
        self.failUnless(l0 in cp, "inplace dilation must use l0")
        self.failUnless(l1 in cp, "inplace dilation must use l1")
        self.failUnless(l2 in cp, "inplace dilation must use l2")
        self.failUnless(l3 in cp, "inplace dilation must use l3")
        self.failUnless(l4 in cp, "inplace dilation must use l4")
        self.failUnless(l5 in cp, "inplace dilation must use l5")
        self.failUnless(l6 in cp, "inplace dilation must use l6")
        self.failUnless(p0 in cp, "inplace dilation must use p0")
        self.failUnless(p1 in cp, "inplace dilation must use p1")
        self.failUnless(p2 in cp, "inplace dilation must use p2")
        self.failUnless(p3 in cp, "inplace dilation must use p3")
        self.failUnless(p4 in cp, "inplace dilation must use p4")
        self.failUnless(p5 in cp, "inplace dilation must use p5")
        self.failUnless(p6 in cp, "inplace dilation must use p6")

   def stest_SurfaceLoop(self):
        p0=Point( 0, 0, 0,0.1)
        p1=Point(10, 0, 0,0.1)
        p2=Point( 0,10, 0,0.1)
        p3=Point(10,10, 0,0.1)
        p4=Point( 0, 0,10,0.1)
        p5=Point(10, 0,10,0.1)
        p6=Point( 0,10,10,0.1)
        p7=Point(10,10,10,0.1)

        q0=Point( 4, 0, 4,0.1)
        q1=Point( 6, 0, 4,0.1)
        q2=Point( 4,10, 4,0.1)
        q3=Point( 6,10, 4,0.1)
        q4=Point( 4, 0, 6,0.1)
        q5=Point( 6, 0, 6,0.1)
        q6=Point( 4,10, 6,0.1)
        q7=Point( 6,10, 6,0.1)

        l01=Line(p0,p1)
        l15=Line(p1,p5)
        l54=Line(p5,p4)
        l04=Line(p4,p0)

        l13=Line(p1,p3)
        l37=Line(p3,p7)
        l75=Line(p7,p5)
        l67=Line(p6,p7)
        l26=Line(p2,p6)
        l32=Line(p3,p2)
        l20=Line(p2,p0)
        l46=Line(p4,p6)

        m01=Line(q0,q1)
        m15=Line(q1,q5)
        m54=Line(q5,q4)
        m40=Line(q4,q0)
        m23=Line(q2,q3)
        m37=Line(q3,q7)
        m76=Line(q7,q6)
        m62=Line(q6,q2)

        cl_l1=CurveLoop(l01,l15,l54,l04)
        cl_m1=CurveLoop(m01,m15,m54,m40)
        s1=PlaneSurface(cl_l1,holes=[cl_m1])

        cl_l2=CurveLoop(-l15,l13,l37,l75)
        s2=PlaneSurface(cl_l2)

        cl_l3=CurveLoop(l32,-l37,l67,l26)
        cl_m3=CurveLoop(-m23,-m37,-m76,-m62)
        s3=PlaneSurface(cl_l3,holes=[cl_m3])
     
        cl_l4=CurveLoop(l20,-l26,l46,-l04)
        s4=PlaneSurface(cl_l4)

        cl_l5=CurveLoop(l32,l20,l01,l13)
        s5=PlaneSurface(-cl_l5)

        cl_l6=CurveLoop(l67,l75,l54,l46)
        s6=PlaneSurface(-cl_l6)

        x=SurfaceLoop(s1,s2,s3,s4,s5)
        print x
        print "X"
        self.failUnlessRaises(TypeError,SurfaceLoop,s1,s2,s3,s4,s5,msg="broken loop not detecred.")
        s=SurfaceLoop(s1,s2,s3,s4,s5,s6)
if __name__ == '__main__':
   suite = unittest.TestSuite()
   suite.addTest(unittest.makeSuite(Test_PyCAD_Transformations))
   suite.addTest(unittest.makeSuite(Test_PyCAD_Primitives))
   s=unittest.TextTestRunner(verbosity=2).run(suite)
   if s.wasSuccessful():
     sys.exit(0)
   else:
     sys.exit(1)
