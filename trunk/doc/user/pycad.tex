\chapter{The module \pycad}
\label{PYCAD CHAP}



\section{Introduction}


\section{\pycad Classes}
\declaremodule{extension}{esys.pycad}
\modulesynopsis{Python geometry description and meshing interface}

\subsection{Primitives}

\begin{classdesc}{Point}{}

\end{classdesc}

\begin{classdesc}{Manifold1D}{}

\end{classdesc}

\begin{classdesc}{Manifold2D}{}

\end{classdesc}

\begin{classdesc}{Manifold3D}{}

\end{classdesc}

%============================================================================================================
\subsection{Transformations}

Transformations are used to move geometrical objects in the 3-dimensional space:

\begin{datadesc}{DEG}
The unit of degree. For instance use \code{90*DEG} for $90$ degrees.
\end{datadesc}

\begin{datadesc}{RAD}
The unit of radiant. For instance use \code{math.pi*RAD} for $180$ degrees.
\end{datadesc}

\begin{classdesc}{Translation}{\optional{b=[0,0,0]}}
defines a translation $x \to x+b$. \var{b} can be any object that can be converted 
into a \numarray object of shape $(3,)$.
\end{classdesc}
              
\begin{classdesc}{Rotatation}{\optional{axis=[1,1,1], \optional{ point = [0,0,0], \optional{angle=0*RAD} } } }
defines a rotation by \var{angle} around axis through point \var{point} and direction \var{axis}. 
\var{axis} and \var{point} can be any object that can be converted 
into a \numarray object of shape $(3,)$.
\var{axis} does not have to be normalized but must have positive length. The right hand rule~\cite{RIGHTHANDRULE}
applies.
\end{classdesc}


\begin{classdesc}{Dilation}{\optional{factor=1., \optional{center=[0,0,0]}}}
defines a dilation by the expansion/contraction \var{factor} with 
\var{center} as the dilation center.
\var{center} can be any object that can be converted 
into a \numarray object of shape $(3,)$.
\end{classdesc}

\begin{classdesc}{Reflection}{\optional{normal=[1,1,1], \optional{offset=0}}}
defines a reflection on a plane defined in normal form $n^t x = d$ 
where $n$ is the surface normal \var{normal} and $d$ is the plane \var{offset}.
\var{normal} can be any object that can be converted 
into a \numarray object of shape $(3,)$.
\var{normal} does not have to be normalized but must have positive length. 
\end{classdesc}

\subsection{Properties}

Property sets are used to bundle a set of geometrical objects in a group. The group
is identified by a name. Typically a property set is used to mark
subregions with share the same material properties or to mark portions of the boundary. 
For efficiency, the \Design class object assigns a integer to each of its property sets,
a so-called tag \index{tag}. The appropriate tag is attached to the elements at generation time.
The \TagMap generated by the \Design allows mapping the a name onto the corresponding tag.
In order to avoid ambiguity it is recommended to have unique names of property sets within a \Design. 
 

\begin{classdesc}{PropertySet}{name,*items}
defines a group geometrical objects which can be accessed through a \var{name}
The objects in the tuple \var{items} mast all be \ManifoldOneD, \ManifoldTwoD or \ManifoldThreeD objects.
\end{classdesc}


\begin{methoddesc}[PropertySet]{getManifoldClass}{}
returns the manifold class \ManifoldOneD, \ManifoldTwoD or \ManifoldThreeD expected from the items
in the property set.
\end{methoddesc}

\begin{methoddesc}[PropertySet]{getDim}{}
returns the spatial dimension of the items
in the property set. 
\end{methoddesc}

\begin{methoddesc}[PropertySet]{getName}{}
returns the name of the set
\end{methoddesc}

\begin{methoddesc}[PropertySet]{setName}{name}
sets the name. This name should be unique within a \Design.
\end{methoddesc}

\begin{methoddesc}[PropertySet]{addItem}{*items}
adds a tuple of items. They need to be objects of class \ManifoldOneD, \ManifoldTwoD or \ManifoldThreeD. 
\end{methoddesc}

\begin{methoddesc}[PropertySet]{getItems}{}
returns the list of items
\end{methoddesc}

\begin{methoddesc}[PropertySet]{clearItems}{}
clears the list of items 
\end{methoddesc}

\begin{methoddesc}[PropertySet]{getTag}{}
returns the tag used for this property set
\end{methoddesc}

\subsection{Accessing \PropertySet Names}
During mesh generation the \PropertySet objects are not identified by their name but an integer tag (mainly to provide 
a quicker indexing mechanism). The \TagMap which is generated by a \Design class object at mesh generation time
provides an mechanism to map the property set names onto tags and vice versa. 
The following example illustrates the mechanis: In this case, the \TagMap \var{tm} 
maps the names \var{x}, \var{a} onto the tags \var{5} and \var{4} and the tag \var{4}, respectively:   
\begin{python}
tm=TagMap({5 : "x" })
tm.setMap(a=1,x=4)
print tm.getTags("a"), tm.getTags("x") 
\end{python}
Th output is 
\begin{python}
   [ 1 ], [ 5, 4 ]
\end{python}

\begin{python}
d=Design()
d.add(PropertySet(name="a"))
print d.getTagMap().getTags("a")
\end{python}

\begin{python}
d=Design()
d.add(PropertySet(name="a"))
domain=esys.finley.
print d.getTagMap().getTags("a")
\end{python}

\begin{classdesc}{TagMap}{\optional{map = \{\} }}
defines a mapping between names (str) and tags (int). 
The dictionary \var{map} sets an initial mapping from tag to name.
\end{classdesc}

\begin{methoddesc}[TagMap]{setMap}{**kwargs}
adds a map from names to tags using keyword arguments. For instance 
\var{top=1234} assigns the tag \var{123} to name \var{top}. The tag has to be integer.
If a tag has been assigned to a name before the mapping will be overwritten. 
Notice that a single name can be assigned to different tags.
\end{methoddesc}

\begin{methoddesc}[TagMap]{getTags}{\optional{name=None}}
returns a list of the tags assigned to \var{name}. If \var{name} is not present 
a list of tags is returned.
\end{methoddesc}

 \begin{methoddesc}[TagMap]{getName}{\optional{tag=None}}
returns a the name assigned to \var{name}. If \var{tag} is not present 
a list of all names is returned.
\end{methoddesc}


\begin{methoddesc}[TagMap]{getMapping}{}
returns a dictionary where the tags define the keys and the values the corresponding names.
\end{methoddesc}

\begin{methoddesc}[TagMap]{map}{\optional{default=0}, \optional{**kwargs}}
returns a dictionary where the keys are the tags and the values are the corresponding values assigned 
to the tag via the keyword arguments \var{**kwargs}. The value of \var{default} is used for tags 
which map onto name with unspecified values.

The following example demonstrate the usage:
\begin{python}
tm=TagMap(x=5)
tm.setMap(a=1,x=4,z=10)
print tm.map(default = "unknown", x="john",  a="peter")
\end{python}  
The output is
\begin{python}
{ 5 : "john", 4: "john", 1 : "peter", 10 : "unknown" }
\end{python}  
\end{methoddesc}

\begin{methoddesc}[TagMap]{insert}{data,\optional{default=0, \optional{**kwargs}}}
inserts the values assigned to name via the keyword arguments \var{**kwargs} 
into the \Data object \var{Data}. The value \var{default} is used for names with no given value.
\end{methoddesc}

\begin{methoddesc}[TagMap]{writeXML}{\optional{iostream=None}}
writes an XML serialization into the \var{iostream} or if not present returns the XML representation
as a string.
\end{methoddesc}

\begin{methoddesc}[TagMap]{fillFromXML}{iostream}
uses XML data \var{iostream} defining an iostream or string. This method is the
inverse method of \var{writeXML}.

The following example demonstrates the usage:
\begin{python}
tm=TagMap(x=5)
tm.setMap(a=1,x=4,z=10)
tm.writeXML(open("tag_map.xml", "w"))
tm2=TagMap()
tm2.fillFromXML(open("tag_map.xml", "r"))
\end{python}  
\end{methoddesc}         



\section{Interface to \gmshextern}
\declaremodule{extension}{esys.pycad.gmsh}
\modulesynopsis{Python geometry description and meshing interface}

\begin{classdesc}{Design}{
\optional{dim=3, \optional{element_size=1., \optional{order=1, \optional{keep_files=False}}}}}
The \class{Design} describes the geometry defined by primitives to be meshed.
The \var{dim} specifies the spatial dimension. The argument \var{element_size} defines the global
element size which is multiplied by the local scale to set the element size at each \Point. 
The argument \var{order} defines the element order to be used. If \var{keep_files} is set to 
\True temporary files a kept otherwise they are removed when the instance of the class is deleted. 
\end{classdesc}


\begin{methoddesc}[Design]{setDim}{\optional{dim=3}}
sets the spatial dimension which needs to be $1$, $2$ or $3$.
\end{methoddesc}

\begin{methoddesc}[Design]{getDim}{}
returns the spatial dimension.
\end{methoddesc}

\begin{methoddesc}[Design]{setElementOrder}{\optional{order=1}}
sets the element order which needs to be $1$ or $2$.
\end{methoddesc}

\begin{methoddesc}[Design]{getElementOrder}{}
returns the element order.
\end{methoddesc}


\begin{methoddesc}[Design]{setElementSize}{\optional{element_size=1}}
set the global element size. The local element size at a point is defined as 
the global element size multipied by the local scale. The element size must be positive.
\end{methoddesc}


\begin{methoddesc}[Design]{getElementSize}{}
returns the global element size.
\end{methoddesc}

\begin{memberdesc}[Design]{DELAUNAY}
the \gmshextern Delauny triangulator.
\end{memberdesc}

\begin{memberdesc}[Design]{TETGEN}
the TetGen~\cite{TETGEN} triangulator.
\end{memberdesc}

\begin{memberdesc}[Design]{TETGEN}
the NETGEN~\cite{NETGEN} triangulator.
\end{memberdesc}

\begin{methoddesc}[Design]{setKeepFilesOn}{}
work files are kept at the end of the generation.
\end{methoddesc}

\begin{methoddesc}[Design]{setKeepFilesOff}{}
work files are deleted at the end of the generation.
\end{methoddesc}

\begin{methoddesc}[Design]{keepFiles}{}
returns \True if work files are kept. Otherwise \False is returned.
\end{methoddesc}

\begin{methoddesc}[Design]{setScriptFileName}{\optional{name=None}}
set the filename for the \gmshextern input script. if no name is given a name with extension "geo" is generated.
\end{methoddesc}

\begin{methoddesc}[Design]{getScriptFileName}{}
returns the name of the file for the \gmshextern script.
\end{methoddesc}


\begin{methoddesc}[Design]{setMeshFileName}{\optional{name=None}}
sets the name for the \gmshextern  mesh file. if no name is given a name with extension "msh" is generated.
\end{methoddesc}

\begin{methoddesc}[Design]{getMeshFileName}{}
returns the name of the file for the gmsh msh
\end{methoddesc}


\begin{methoddesc}[Design]{addItems}{*items}
adds the tuple of var{items}. An item can be any primitive or a \class{PropertySet}.
\warning{If a \PropertySet is added as an item added object that are not 
part of a \PropertySet are not considered in the messing.  
}

\end{methoddesc}

\begin{methoddesc}[Design]{getItems}{}
returns a list of the items
\end{methoddesc}

\begin{methoddesc}[Design]{clearItems}{}
resets the items in design
\end{methoddesc}

\begin{methoddesc}[Design]{getMeshHandler}{}
returns a handle to the mesh. The call of this method generates the mesh from the geometry and
returns a mechnism to access the mesh data. In the current implementation this
is this method returns a file name for a \gmshextern file containing the mesh data but this may change in
later versions.
\end{methoddesc}

\begin{methoddesc}[Design]{getScriptString}{}
returns the \gmshextern script to generate the mesh as string.
\end{methoddesc}

\begin{methoddesc}[Design]{getCommandString}{}
returns the \gmshextern command used to generate the mesh as string..
\end{methoddesc}

\begin{methoddesc}[Design]{setOptions}{\optional{algorithm=None, \optional{ optimize_quality=True,\optional{ smoothing=1}}}}
sets options for the mesh generator. \var{algorithm} sets the algorithm to be used.
The algorithm needs to be \var{Design.DELAUNAY}
\var{Design.TETGEN}
or \var{Design.NETGEN}. By default \var{Design.DELAUNAY} is used. \var{optimize_quality}=\True invokes an optimization of the mesh quality. \var{smoothing} sets the number of smoothing steps to be applied to the mesh.  
\end{methoddesc}

\begin{methoddesc}[Design]{getTagMap}{}
returns a \class{TagMap} to map the name \class{PropertySet} in the class to tag numbers generated by \gmshextern.
\end{methoddesc}
