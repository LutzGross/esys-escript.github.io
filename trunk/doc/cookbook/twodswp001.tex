
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2003-2010 by University of Queensland
% Earth Systems Science Computational Center (ESSCC)
% http://www.uq.edu.au/esscc
%
% Primary Business: Queensland, Australia
% Licensed under the Open Software License version 3.0
% http://www.opensource.org/licenses/osl-3.0.php
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Seismic Wave Propagation in Two Dimensions}
\editor{This chapter aims to expand the readers understanding of escript by modelling the wave equations.
Challenges will include a second order differential (multiple initial conditions). A new PDE to fit to the general form. Movement to a 3D problem (maybe)??? }

\verb|wavesolver2d.py|

Wave propagation in the earth can be described by the wave equation:
\begin{equation} \label{eqn:wav} \index{wave equation}
\rho \frac{\partial^{2}u\hackscore{i}}{\partial t^2} - \frac{\partial \sigma\hackscore{ij}}{\partial\hackscore{j}} = 0
\end{equation}
where $\sigma$ represents stress and is given by:
\begin{equation} \label{eqn:sigw}
 \sigma \hackscore{ij} = \lambda u\hackscore{k,k} \delta\hackscore{ij} + \mu ( u\hackscore{i,j} + u\hackscore{j,i})
\end{equation}
$\lambda$ and $\mu$ are the Lame Coefficients. Specifically $\mu$ is the bulk modulus. The \refEq{eqn:wav} can be written with the Einstein summation convention as:
\begin{equation}
 \rho u\hackscore{i,tt} = \sigma\hackscore{ij,j}
\end{equation}
For this model we will specify the boundary conditions such that the normal of the stress from the boundary is zero.
\begin{eqnarray} \label{eqn:bdw}
\sigma \hackscore{ij}n\hackscore{j}=0
\end{eqnarray}
To solve this PDE we are going to write a more generic solution routine than we have in the previous chapters. There are a number of advantages to this approach. Firstly, by writing a subroutine that will solve a 2D wave propagation problem it reduces the amount of code duplication that may occur. When errors arrise one need only ammend the subroutine rather than all iterations of it that may have been created. This saves time and effort in the long run. 

To create the our subroutine we will need to import all our necessary libraries again. This is as for previous examples. Then we can define our script and the variables it will take. Our subroutine is located in \verb|/examples/cblib/wavesolver2d.py|  . The arguments of the subroutine are;
\begin{python}
domain  : domain to solve over
h       : time step
tend    : end time
lam, mu : lames constants for domain
rho	: density of domain
U0	: magnitude of source
xc	: source location in domain (Vector)
savepath: where to output the data files
\end{python}
There are a few differences between the wave equation and the heat diffusion
problem of the previous chapter. While the nodes are defined the same way with
the function \verb getX  and the PDE is still linear; one must consider the
solution method. Without the line;
\begin{python}
mypde.setSolverMethod(LinearPDE.LUMPING)
\end{python}
the PDE would take a significant amount of time to solve. 
The \verb LUMPING functionality implements an aggressive approximation for the
$D$ coefficient matrix of the \esc linear PDE general form. 
While \verb LUMPING introduces additional error to the solution it can
significantly reduce the solution time. Care should be taken however, as this
function can only be used when the $A$, $B$ and $C$ coefficients of the general
form are zero. 

As the wave equation has a double time derivative, it is not sufficient to only
stipulate the initial conditions for one time step. Two time steps must be
specified so that the equation can be solved. For this example $u$ (\verb u )
and $u(t-1)$ (\verb u_m1 ) will be the same but if both of these condititions
are known, they can be specified individually. It should be noted here that if
multiple time steps are known at the begining of a model, they can be added to
the simulation manually. The solver can then continue the model from the end of
the known data. Alternatively, if the source motion is understood, its position
can be corrected for each iteration to create a more accurate recreation of an
event. 

The source in this example will induce a radially propagating wave. A small
displacement will be applied to the medium about a singularity which we have
called \verb xc  , this is the source location. We start by giving the source
some spatial magnitude by defining a small radius about \verb xc  which is
affected. The \verb src_radius  needs to cover a significant portion of grid
nodes, otherwise the waves generated will suffer from dispersion due to an
inadequate grid step size. If the source is small, the grid stepping must
reflect the size of the source for more accurate results. Our radius will be;
\begin{python}
 src_radius = 50
\end{python}
Now that the extent of the source has been allocated it needs two more things; a
direction and a magnitude. We can choose a direction based on the 360 degrees
that exist in a full circle. If we take $\theta=0$ to be the x-axis and move
counter clockwise then we can create a directional vector $U=[dx,dy]$  where
$tan(\theta) = dy/dx$. It is also necessary to ensure that our directional
vector of unit length such that $|U|=1$; which implies $\sqrt{dx^2+dy^2}=1$. By
doing this we ensure that no accidental scaling is introduced to our source
term. Here are three examples of different directions which satisfy the above
conditions;
\begin{enumerate}
 \item Along the x-axis: $U=[dx=1,dy=0]$
 \item Along the y-axis: $U=[dx=0,dy=1]$
 \item At 45deg: $U=[dx=\frac{1}{\sqrt2},dy=\frac{1}{\sqrt2}]$
\end{enumerate}
There are limitations to specifying the source in this manner. Realistically we
would not expect a 2D surface source to move form side to side as an isotropic
source makes more sense. \editor{I am not sure here how to create an isotropic
source function.}. In the 3D case things are not quite so bad. Normally we are
interested in the p-waves that are directed dowwards and thus we need not have
any x or y component in our source directionality. This still introduced
assumptions and removes realistic wave motions both P and S from the model.
For our example we will use;
\begin{python}
 dunit=numarray.array([1.,0.])
\end{python}
Next we must define the values of our entire domain for the first and second
time step. For the purposes of this example it is sufficient to have these two
timesteps as equal. Setting the source is similar to earlier problems where we
can use \esc functions to set specific areas of the domain to certain values. We
must also smooth our sourse to its surrounds to prevent ?diffusion? errors. This
is acheived by using a cosine taper. Our source terms then become;
\begin{python}
 u=U0*(cos(length(x-xc)*3.1415/src_radius)+1)*\
              whereNegative(length(x-xc)-src_radius)*dunit
 u_m1=u
\end{python}

It is often useful to know the values of PDE at certain locations in the model.
To acheive this we are going to use a new generic function 
called \verb cbphones  which allows us to specify receiver locations to record
the PDE values at those points. The function \verb cbphones as the arguments;
\begin{python}
#	domain  : domain of model
#	U       : Current time state displacement solution.
#	phones  : Geophone Locations
#	dim     : model dimesions
#	savepath: where to output the data files local is default
\end{python}
\editor{not generic as of yet but may move to make cbphones and the phones
positioning a serious part of wavesolver 2d}
We have chosen to have three receivers and they are called using;
\begin{python}
u_pot = cbphones(domain,u,[[0,500],[250,500],[400,500]],2)
\end{python}
This places the receivers on the surface at the source location and two
locations further along the top of the model. The output \verb u_pot  can then
be split and saved to file using the following command;
\begin{python}
u_pc_data=open(os.path.join(savepath,'U_pc.out'),'w')
u_pc_data.write("%f %f %f %f %f %f
%f\n"%(t,u_pc_x1,u_pc_y1,u_pc_x2,u_pc_y2,u_pc_x3,u_pc_y3))
\end{python}
Convieniently this saves the time, x direction displacement and y direction
displacement values for these locations. Now that the initial conditions have
been defined we can tackle the task of solving the wave equation for the number
of required time steps. To do this we require a while loop and form of the wave
equation which fits our general linear PDE form. We start with the form of the
equation for stress \refEq{eqn:sigw}. We can define the kronecker matrix using
the domain and take the derivative of \verb u  via the function \verb|grad(u)| 
. As $\lambda$ and $\mu$ are constants we can now define $\sigma$;
\begin{python}
g=grad(u)
stress=lam*trace(g)*kmat+mu*(g+transpose(g))
\end{python}
Solving for the double time derivative of u on the LHS of \refEq{eqn:wav}
required us to use the centred difference forumlua which returns;
\begin{equation}
u^n = 2u^{n-1}-u^{n-2}+h^2 \biggl(\frac{\partial ^2 u}{\partial t^2}\biggr)^n
\end{equation}
Substituting for the double time derivative we see;
\begin{equation}
\rho u^n = 2\rho u^{n-1}- \rho u^{n-2}+h^2 \sigma \hackscore{ij,j} ^n
\end{equation}
This fits the general form $Du=-X \hackscore{j,j} + Y$ where $D=rho$; $Y=2\rho
u^{n-1}- \rho u^{n-2}$ and $X=-h^2 \sigma \hackscore{ij,j} ^n$. \verb D does not
vary between time steps can be defined before our iteration loop via;
\begin{python}
mypde.setValue(D=kmat*rho)
\end{python}
The values for \verb u  must be refreshed after each iteration and are thus
defined within our while loop via;
\begin{python}
mypde.setValue(X=-stress*(h*h),Y=(rho*2*u-rho*u_m1))
\end{python}
With each iteration we update \verb u  and migrate our answers into the correct
variables. The iterative values must also be updated as well as the response
from our receiver locations. All this is acheived via;
\begin{python}
u_p1 = mypde.getSolution()
u_m1=u
u=u_p1
t+=h
n+=1
u_pot = cbphones(domain,u,[[125.,250.],[250.,250.],[250.,375.]],2)
# save displacements at point source to file for t > 0
u_pc_data.write("%f %f %f %f %f %f %f\n"%(t,u_pc_x1,u_pc_y1,u_pc_x2,u_pc_y2,u_pc_x3,u_pc_y3))
\end{python}
With an appropriate file saving output we now have a working generic solver for
our 2D wave equation problem. We have also included our two new generic programs
in the \verb cblib  library so they can be more simply imported along with their
own dependancies to our test script.

Writing a test program will allow us to more easily pass the variables required
to the solver to generate an output solution. Our testing code described in this
section can be found in \fileex{wavesolver2d001.py}. In a similar manner to the
previous chapter the first step to creating our script is to import the
necessary modules and functions including our new library file. Following this
the PDE and control variables must be defined. This includes the domain
dimensions and type, the time scale and the time step. To ensure stability the
time step can be calcuated such that it satisfies the Courant stability criteria
\editor{MORE HERE ONCE METHOD FINALISED}. Considering the complexity of the
computational solution to the wave equation it is proudant to consider how many
steps will need to be solved. Our test script thus includes an acknowledgement
clause;
\begin{python}
#Check to make sure number of time steps is not too large.
print "Time step size= ",h, "Expected number of outputs= ",tend/h
proceeder = raw_input("Is this ok?(y/n)")
#Exit if user thinks too many outputs.
if proceeder == "n":
sys.exit()
\end{python}
This requires that the user knows the number of itterations that will be required to solve the model for the time period \verb 0  to \verb tend . The command \verb sys.exit()  is used here to halt the script if the input to preceeder is \verb n  and thus prevent a forced crash of the script should its projected solve time be too large.
