\chapter{Cost Function}\label{chapter:ref:inversion cost function}
The general form of the cost function minimized in the inversion is given in the form (see also Chapter~\ref{Chp:ref:introduction})
\begin{equation}\label{REF:EQU:DRIVE:10}
J(m) = J^{reg}(m) + \sum_{f} \mu^{data}_{f} \cdot J^{f}(p^f)
\end{equation} 
where $m$ represents the level set function, $J^{reg}$ is the regularization term, see Chapter~\ref{Chp:ref:regularization},
and $J^{f}$ are a set of forward problems, see Chapter~\ref{Chp:ref:forward models} depending of 
physical parameters $p^f$.  The physical parameters $p^f$ are known functions 
of the  level set function $m$ which is the unknown to be calculated by the optimization process. 
$\mu^{data}_{f}$ are trade-off factors. It is pointed out that the regularization term includes additional trade-off factors 
The \class{InversionCostFunction} is class to define cost functions of an inversion. It is pointed out that
the \class{InversionCostFunction} class implements the \class{CostFunction} template class, see Chapter~\ref{chapter:ref:Minimization}.

In the simplest case there is a single forward model using a single physical parameter which is 
derived form single-values level set function. The following script snippet shows the creation of the
\class{InversionCostFunction} for the case of a gravity inversion:
\begin{verbatim}
p=DensityMapping(...)
f=GravityModel(...)
J=InversionCostFunction(Regularization(...), \
                        mappings=p, \
                        forward_models=f)
\end{verbatim}
The argument \verb|...| refers to an appropriate argument list.

If two forward models are coming into play using two different physical parameters 
the \member{mappings} and \member{forward_models} are defined as lists in the following form:
\begin{verbatim}
p_rho=DensityMapping(...)
p_k=SusceptibilityMapping(...)
f_mag=MagneticModel(...)
f_grav=GravityModel(...)

J=InversionCostFunction(Regularization(...), \
                        mappings=[p_rho, p_k], \
                        forward_models=[(f_mag, 1), (f_grav,0)])
\end{verbatim}
Here we define a joint inversion of gravity and magnetic data. \member{forward_models} is given as a list of
a tuple of a forward model and an index which referring to parameter in the \member{mappings} list to be used as an input.
The magnetic forward model \member{f_mag} is using the the second parameter (=\member{p_k}) in \member{mappings} list.
In this case the physical parameters are defined by a single-valued level set function. It is also possible
to link physical parameters to components of a level set function:
\begin{verbatim}
p_rho=DensityMapping(...)
p_k=SusceptibilityMapping(...)
f_mag=MagneticModel(...)
f_grav=GravityModel(...)

J=InversionCostFunction(Regularization(numLevelSets=2,...), \
                        mappings=[(p_rho,0), (p_k,1)], \
                        forward_models=[[(f_mag, 1), (f_grav,0)])   
\end{verbatim}
The \member{mappings} argument is now a list of pairs where the first pair entry specifies the parameter mapping and
the second pair entry specifies the index of the component of the level set function to be used to evaluate the parameter.
In this case the level set function has two components, where the density mapping uses the first component of the level set function 
while the susceptibility mapping uses the second component.

The \class{InversionCostFunction} API is defined as follows:

\begin{classdesc}{InversionCostFunction}{regularization, mappings, forward_models}
Constructor for the inversion cost function. \member{regularization} sets the regularization to be used, see Chapter~\ref{Chp:ref:regularization}.
\member{mappings} is a list of pairs where each pair comprises of a 
physical parameter mapping (see Chapter~\ref{Chp:ref:mapping}) and an index which refers to the component of level set function
defined by the \member{regularization} to be used to calculate the corresponding physical parameter. If 
the level set function has a single component the index can be omitted. If in addition there is a single physical parameter
the mapping can be given instead of a list. \member{forward_models} is a list of pairs where the 
first pair component is a forward model ( see Chapter~\ref{Chp:ref:forward models}) and the second 
pair component referring to the physical parameter in the \member{mappings} list providing the  physical parameter for the model.
If a single physical parameter is present the index can be omitted. If in addition a single  forward model is used this
forward model can be assigned to \member{forward_models} in replacement of a list.
\end{classdesc}


\begin{methoddesc}[InversionCostFunction]{getDomain}{}
        """
        returns the domain of the cost function
        :rtype: 'Domain`
        """
        self.regularization.getDomain()
\end{methoddesc}
        
\begin{methoddesc}[InversionCostFunction]{getNumTradeOffFactors}{}
        """
        returns the number of trade-off factors being used including the
        trade-off factors used in the regularization component.

        :rtype: ``int``
        """
        return self.__num_tradeoff_factors
\end{methoddesc}

 \begin{methoddesc}[InversionCostFunction]{getForwardModel}{idx=None}
        """
        returns the *idx*-th forward model.

        :param idx: model index. If cost function contains one model only `idx`
                    can be omitted.
        :type idx: ``int``
        """
        if idx==None: idx=0
        f=self.forward_models[idx]
        if isinstance(f, ForwardModel): 
              F=f
        else:
              F=f[0]
        return F
\end{methoddesc}
        
\begin{methoddesc}[InversionCostFunction]{getRegularization}{}
        """
        returns the regularization
        """
        return self.regularization
\end{methoddesc}

        
\begin{methoddesc}[InversionCostFunction]{setTradeOffFactorsModels}{mu=None}
        """
        sets the trade-off factors for the forward model components.
        
        :param mu: list of the trade-off factors. If not present ones are used.
        :type mu: ``float`` in case of a single model or a ``list`` of ``float``
                  with the length of the number of models.
        """
        if mu==None:
            self.mu_model=np.ones((self.numModels, )) 
        else:
            if self.numModels > 1:
               mu=np.asarray(mu)
               if min(mu) > 0:
                  self.mu_model= mu
               else:
                  raise ValueError("All value for trade-off factor mu must be positive.")
            else:
              mu=float(mu)
              if mu > 0:
                  self.mu_model= [mu, ]
              else:
                  raise ValueError("Trade-off factor must be positive.") 
\end{methoddesc}
           
\begin{methoddesc}[InversionCostFunction]{setTradeOffFactorsRegularization}{mu=None, mu_c=None}
        """
        sets the trade of factors for the regularization component of the cost
        function, see `Regularization` for details.
        
        :param mu: trade-off factors for the level-set variation part 
        :param mu_c: trade-off factors for the cross gradient variation part 
        """
        self.regularization.setTradeOffFactorsForVariation(mu)
        self.regularization.setTradeOffFactorsForCrossGradient(mu_c)
\end{methoddesc}
        
\begin{methoddesc}[InversionCostFunction]{setTradeOffFactors}{mu=None}
        """
        sets the trade-off factors for the forward model and regularization
        terms. 

        :param mu: list of trade-off factors. 
        :type mu: ``list`` of ``float``
        """
        if mu is None:
            mu=np.ones((self.__num_tradeoff_factors,))
        self.setTradeOffFactorsModels(mu[:self.numModels])
        self.regularization.setTradeOffFactors(mu[self.numModels:])
\end{methoddesc}

\begin{methoddesc}[InversionCostFunction]{createLevelSetFunction}{*props}
        """
        returns an instance of an object used to represent a level set function
        initialized with zeros. Components can be overwritten by physical
        properties 'props'. If present entries must correspond to the
        `mappings` arguments in the constructor. Use `None` for properties for
        which no value is given.
        """
        m=self.regularization.getPDE().createSolution()
        if len(props) > 0:
           for i in xrange(self.numMappings): 
              if props[i]: 
                  mm=self.mappings[i]
                  if isinstance(mm, Mapping):
                      m=mm.getInverse(props[i])
                  elif len(mm) == 1:
                      m=mm[0].getInverse(props[i])
                  else:
                      m[mm[1]]=mm[0].getInverse(props[i])
        return m
\end{methoddesc}
    
\begin{methoddesc}[InversionCostFunction]{getProperties}{m, return_list=False}
        """
        returns a list of the physical properties from a given level set
        function *m* using the mappings of the cost function.
        
        :param m: level set function
        :type m: `Data`
        :param return_list: if True a list is returned. 
            def _:type return_list: `bool`
        :rtype: `list` of `Data`
        """
        props=[]
        for i in xrange(self.numMappings): 
           mm=self.mappings[i]
           if isinstance(mm, Mapping):
               p=mm.getValue(m)
           elif len(mm) == 1:
               p=mm[0].getValue(m)
           else:
               p=mm[0].getValue(m[mm[1]])
           props.append(p)
        if self.numMappings > 1 or return_list:
           return props
        else:
           return props[0]
\end{methoddesc}
           
\begin{methoddesc}[InversionCostFunction]{getDualProduct}{x, r}
        """
        Returns the dual product, see `Regularization.getDualProduct`

        :type x: `Data`
        :type r: `ArithmeticTuple`             
        :rtype: `float`
        """
        return self.regularization.getDualProduct(x, r)
\end{methoddesc}

\begin{methoddesc}[InversionCostFunction]{getArguments}{m}
        """
        returns pre-computed values that are shared in the calculation of
        *J(m)* and *grad J(m)*. In this implementation returns a tuple with the
        mapped value of ``m``, the arguments from the forward model and the
        arguments from the regularization.
        
        :param m: current approximation of the level set function
        :type m: `Data`
        :return: tuple of of values of the parameters, pre-computed values for the forward model and
                 pre-computed values for the regularization
        :rtype: `tuple`
        """
        args_reg=self.regularization.getArguments(m)

        props=self.getProperties(m, return_list=True)
        args_f=[]
        for i in xrange(self.numModels):
           f=self.forward_models[i]
           if isinstance(f, ForwardModel): 
              aa=f.getArguments(props[0])
           elif len(f) == 1:
              aa=f[0].getArguments(props[0])
           else:
              idx = f[1]
              f=f[0]
              if isinstance(idx, int):
                 aa=f.getArguments(props[idx])
              else:
                 pp=tuple( [ props[i] for i in idx] )
                 aa=f.getArguments(*pp)
           args_f.append(aa)
           
        return props, args_f, args_reg
\end{methoddesc}

\begin{methoddesc}[InversionCostFunction]{getValue}{m, *args}
        """
        Returns the value *J(m)* of the cost function at *m*.
        If the pre-computed values are not supplied `getArguments()` is called.

        :param m: current approximation of the level set function
        :type m: `Data`
        :param args: tuple of of values of the parameters, pre-computed values for the forward model and
                 pre-computed values for the regularization
        :rtype: `float`
        """

        if len(args)==0:
            args=self.getArguments(m)
        
        props=args[0]
        args_f=args[1]
        args_reg=args[2]
        
        J = self.regularization.getValue(m, *args_reg)
        print "J_reg = %e"%J
                
        for i in xrange(self.numModels):
                 
           f=self.forward_models[i]
           if isinstance(f, ForwardModel): 
              J_f = f.getValue(props[0],*args_f[i])
           elif len(f) == 1:
              J_f=f[0].getValue(props[0],*args_f[i])
           else:
              idx = f[1]
              f=f[0]
              if isinstance(idx, int):
                 J_f = f.getValue(props[idx],*args_f[i])
              else:
                 args=tuple( [ props[j] for j in idx] + args_f[i])
                 J_f = f.getValue(*args)
           print "J_f[%d] = %e"%(i, J_f)
           print "mu_model[%d] = %e"%(i, self.mu_model[i])
           J += self.mu_model[i] * J_f
           
        return   J
\end{methoddesc}

\begin{methoddesc}[InversionCostFunction]{getGradient}{m, *args}
        """
        returns the gradient of the cost function  at *m*.
        If the pre-computed values are not supplied `getArguments()` is called.

        :param m: current approximation of the level set function
        :type m: `Data`
        :param args: tuple of of values of the parameters, pre-computed values for the forward model and
                 pre-computed values for the regularization
                 
        :rtype: `ArithmeticTuple`
        """
        if len(args)==0:
            args = self.getArguments(m)
         
        props=args[0]
        args_f=args[1]
        args_reg=args[2]
        
        g_J = self.regularization.getGradient(m, *args_reg) 
        p_diffs=[]
        for i in xrange(self.numMappings): 
           mm=self.mappings[i]
           if isinstance(mm, Mapping):
               dpdm = mm.getDerivative(m)
           elif len(mm) == 1:
               dpdm = mm[0].getDerivative(m)
           else:
               dpdm = mm[0].getDerivative(m[mm[1]])
           p_diffs.append(dpdm)
           
        Y=g_J[0]   
        for i in xrange(self.numModels):
           mu=self.mu_model[i] 
           f=self.forward_models[i]
           if isinstance(f, ForwardModel): 
              Ys= f.getGradient(props[0],*args_f[i]) * p_diffs[0] * mu
              if self.numLevelSets == 1 :
                 Y +=Ys
              else:
                  Y[0] +=Ys
           elif len(f) == 1:
              Ys=f[0].getGradient(props[0],*args_f[i]) * p_diffs[0]  * mu
              if self.numLevelSets == 1 :
                 Y +=Ys
              else:
                  Y[0] +=Ys
           else:
              idx = f[1]
              f=f[0]
              if isinstance(idx, int):
                 Ys = f.getGradient(props[idx],*args_f[i]) * p_diffs[idx] * mu 
                 if self.numLevelSets == 1 :
                     if idx == 0:
                         Y+=Ys
                     else:
                         raise IndexError("Illegal mapping index.")
                 else:
                     Y[idx] += Ys 
              else:
                 args=tuple( [ props[j] for j in idx] + args_f[i])
                 Ys = f.getGradient(*args)
                 for ii in xrange(len(idx)):
                     Y[idx[ii]]+=Ys[ii]* p_diffs[idx[ii]]  * mu

        return g_J
\end{methoddesc}


\begin{methoddesc}[InversionCostFunction]{getInverseHessianApproximation}{m, r, *args}
        """
        returns an approximative evaluation *p* of the inverse of the Hessian operator of the cost function
        for a given gradient type *r* at a given location *m*: *H(m) p = r*

        :param m: level set approximation where to calculate Hessian inverse
        :type m: `Data`
        :param r: a given gradient
        :type r: `ArithmeticTuple`
        :param args: tuple of of values of the parameters, pre-computed values for the forward model and
                 pre-computed values for the regularization
        :rtype: `Data`
        :note: in the current implementation only the regularization term is
               considered in the inverse Hessian approximation.

        """
        m=self.regularization.getInverseHessianApproximation(m, r, *args[2])
        return m

\end{methoddesc}
        
\begin{methoddesc}[InversionCostFunction]{getNorm}{m}
        """
        returns the norm of ``m``

        :param m: level set function
        :type m: `Data`
        :rtype: ``float``
        """

\end{methoddesc}
