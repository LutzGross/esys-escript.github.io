# Copyright (C) 2004-2005 Paul Cochrane
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

# $Id: offset_plot.py,v 1.1 2005/11/30 04:29:53 paultcochrane Exp $

"""
Class and functions associated with a pyvisi OffsetPlot objects (gnuplot)
"""

# generic imports
from pyvisi.renderers.gnuplot.common import debugMsg
import copy

# module specific imports
from pyvisi.renderers.gnuplot.plot import Plot

__revision__ = '$Revision: 1.1 $'

class OffsetPlot(Plot):
    """
    Offset plot
    """
    def __init__(self, scene):
        """
        Initialisation of OffsetPlot class

        @param scene: the scene with which to associate the OffsetPlot
        @type scene: Scene object
        """
        debugMsg("Called OffsetPlot.__init__()")
        Plot.__init__(self, scene)

        self.renderer = scene.renderer

        self.title = None
        self.xlabel = None
        self.ylabel = None

        self.linestyle = 'lines'   # pyvisi-defined linestyle
        self._linestyle = None  # renderer-specific linestyle

        self.sep = None

        # now add the object to the scene
        scene.add(self)

    def setData(self, *dataList):
        """
        Sets the data to the given plot object.

        @param dataList: list of data objects to plot
        @type dataList: tuple
        """
        debugMsg("Called setData() in OffsetPlot()")
        
        self.renderer.runString("# OffsetPlot.setData()")

        # do some sanity checking on the data
        if len(dataList) > 3 or len(dataList) < 1:
            raise ValueError, "Must have either one, two or three input arrays"

        # the data is y values located at different x positions, changing
        # over time, so the normal x-dimension is t, the normal y dimension
        # is both x and y; y basically being offset by the x values
        # therefore will refer to tData, xData and yData

        # compare the shapes of the input vectors.
        # assume that the first one is the t data, and that the first
        # dimension of the second one is the same length as the t data
        # length
        if len(dataList) == 1:
            yData = dataList[0]
        elif len(dataList) == 2:
            tData = dataList[0]
            yData = dataList[1]
            if tData.shape[0] != yData.shape[0]:
                raise ValueError, "Input arrays don't have the correct shape"
        elif len(dataList) == 3:
            tData = dataList[0]
            xData = dataList[1]
            yData = dataList[2]
            if tData.shape[0] != yData.shape[0]:
                raise ValueError, \
                       "First dim of third arg doesn't agree with first arg"
            if len(yData.shape) == 1:
                if xData.shape[0] != 1:
                    raise ValueError, \
                       "Second arg must be a scalar when third arg is a vector"
            elif len(yData.shape) == 2:
                if xData.shape[0] != yData.shape[1]:
                    raise ValueError, \
                       "Second dim of third arg doesn't agree with second arg"

        # this is a really dodgy way to get the data into the renderer
        # I really have to find a better, more elegant way to do this
        
        # if only have one array input, then autogenerate tData
        if len(dataList) == 1:
            tData = range(1, len(dataList[0])+1)
            if len(tData) != len(dataList[0]):
                errorString = "Autogenerated xData array length not "
                errorString += "equal to input array length"
                raise ValueError, errorString
                        
            ## pass the t data around
            self.renderer.renderDict['_t'] = copy.deepcopy(tData)
        # if have two arrays to plot, the first one is the t data
        elif len(dataList) == 2:
            ## pass the t data around
            self.renderer.renderDict['_t'] = copy.deepcopy(tData)
        elif len(dataList) == 3:
            ## pass the t data around
            self.renderer.renderDict['_t'] = copy.deepcopy(tData)
            ## pass the x data around
            self.renderer.renderDict['_x'] = copy.deepcopy(xData)
        else:
            # shouldn't get to here, but raise an error anyway
            raise ValueError, "Incorrect number of arguments"

        # range over the data, printing what the expansion of the array is
        # and regenerate the data within the eval
        if len(yData.shape) == 1:
            dataLen = 1
        elif len(yData.shape) == 2:
            dataLen = yData.shape[1]
        else:
            raise ValueError, \
                    "The last setData argument has the incorrect shape"

        # share around the y data
        for i in range(dataLen):
            yDataVar = "_y%d" % i
            if len(yData.shape) == 1:
                self.renderer.renderDict[yDataVar] = copy.deepcopy(yData)
            else:
                self.renderer.renderDict[yDataVar] = copy.deepcopy(yData[:, i])
            # check that the data here is a 1-D array
            if len(self.renderer.renderDict[yDataVar].shape) != 1:
                raise ValueError, "Can only handle 1D arrays at present"
            
        ### shift the data up according to the offset rules
        # concatenate the data
        evalString = "_yAll = concatenate(["
        for i in range(dataLen-1):
            evalString += "_y%d," % i
        evalString += "_y%d])" % int(dataLen-1)
        self.renderer.runString(evalString)

        # find its min and max
        self.renderer.runString("_yMax = max(_yAll)")
        self.renderer.runString("_yMin = min(_yAll)")

        # keep the data apart a bit with a constant
        if self.sep is None:
            self.renderer.runString("_const = 0.01*(_yMax - _yMin)")
        else:
            evalString = "_const = %f" % self.sep
            self.renderer.runString(evalString)

        # behave differently if we have xData as to not
        if len(dataList) == 3:
            # this is for when we have xData
            self.renderer.runString("_yMaxAbs = max(abs(_yAll))")
            # calculate the minimum delta x
            x1 = xData[:-1]
            x2 = xData[1:]
            minDeltax = min(x2 - x1)
            evalString = "_scale = %f/(2.0*_yMaxAbs)" % minDeltax
            self.renderer.runString(evalString)
            
            for i in range(dataLen):
                evalString = "_y%d = _scale*_y%d + _x[%d]" % (i, i, i)
                self.renderer.runString(evalString)
        else:
            # shift the data up
            self.renderer.runString("_shift = _yMax - _yMin + _const")

            for i in range(dataLen):
                evalString = "_y%d = _y%d + %f*_shift" % (i, i, i)
                self.renderer.runString(evalString)

        # specify the minimum and maximum value on the graph
        # assumed to be max(_y0) - 2.0*_const and max(_y%d) + 2.0*_const
        self.renderer.runString("_minVal = min(_y0) - 2.0*_const")
        evalString = "_maxVal = max(_y%d) + 2.0*_const" % int(dataLen-1)
        self.renderer.runString(evalString)
        evalString = "_gnuplot(\'set yrange [%g:%g]\' % (_minVal, _maxVal))"
        self.renderer.runString(evalString)

        # give the data to gnuplot
        for i in range(dataLen):
            evalString = "_data%d = Gnuplot.Data(_t, " % i
            evalString += "_y%d" % i

            # if there are any linestyle settings etc, add them here (gnuplot
            # reasons)
            if self.linestyle is not None:
                # set the linestyle to renderer-specific version (_linestyle)
                self.setLineStyle(self.linestyle)
                evalString += ", with=\'%s\'" % self._linestyle

            # finish off the evalString
            evalString += ")"

            # and add it to the evalstack
            self.renderer.runString(evalString)

        # return the number of data objects to plot
        self.renderer.numDataObjects = dataLen

        return

    def render(self):
        """
        Does OffsetPlot object specific rendering stuff
        """
        debugMsg("Called OffsetPlot.render()")

        self.renderer.runString("# OffsetPlot.render()")

        # if a title is set, put it here
        if self.title is not None:
            evalString = "_gnuplot.title(\'%s\')" % self.title
            self.renderer.runString(evalString)

        # if an xlabel is set, add it
        if self.xlabel is not None:
            evalString = "_gnuplot.xlabel(\'%s\')" % self.xlabel
            self.renderer.runString(evalString)

        # if a ylabel is set, add it
        if self.ylabel is not None:
            evalString = "_gnuplot.ylabel(\'%s\')" % self.ylabel
            self.renderer.runString(evalString)

        # set up the evalString to use for plotting
        evalString = "_gnuplot.plot("
        for i in range(self.renderer.numDataObjects-1):
            evalString += "_data%d, " % i
        evalString += "_data%d)" % (self.renderer.numDataObjects-1,)
        self.renderer.runString(evalString)

        return

    def setLineStyle(self, linestyle):
        """
        Sets the linestyle of the OffsetPlot

        Linestyles may be either a word in the Gnuplot style, or a symbol 
        shortcut in the Matlab style.  Some of the options do not have a
        Matlab equivalent but do have a Gnuplot equivalent, or vice versa.

        What this method does, is take the linestyles possible as defined by
        PyVisi, and then does some conversion as best it can to get the
        relevant output from (in this case) gnuplot.
        
        Possible linestyles are:
            1. lines ('-')
            2. points ('o')
            3. linespoints ('-o')
            4. dots ('.')
            5. dotted (':')
            6. dashes ('--')
            7. dotdashes ('-.')

        @param linestyle: the style to use for the lines
        @type linestyle: string
        """
        debugMsg("Called OffsetPlot.setLineStyle()")

        # now implement the gnuplot-specific way to do this
        if linestyle == 'lines' or linestyle == '-':
            self._linestyle = 'lines'
        elif linestyle == 'points' or linestyle == 'o':
            self._linestyle = 'points'
        elif linestyle == 'linespoints' or linestyle == '-o':
            self._linestyle = 'linespoints'
        elif linestyle == 'dots' or linestyle == '.':
            self._linestyle = 'dots'
        elif linestyle == 'dotted' or linestyle == ':':
            print "linestyle = %s" % linestyle
            raise NotImplementedError, \
                    "Sorry, haven't implemented this style yet."
        elif linestyle == 'dashes' or linestyle == '--':
            print "linestyle = %s" % linestyle
            raise NotImplementedError, \
                    "Sorry, haven't implemented this style yet."
        elif linestyle == 'dotdashes' or linestyle == '-.':
            print "linestyle = %s" % linestyle
            raise NotImplementedError, \
                    "Sorry, haven't implemented this style yet."
        else:
            raise ValueError, "Unknown linestyle!  I got \'%s\'" % linestyle

        return

    def getLineStyle(self):
        """
        Gets the current linestyle of the OffsetPlot

        @return: the linestyle as a string
        """
        debugMsg("Called OffsetPlot.getLineStyle()")

        return self.linestyle


# vim: expandtab shiftwidth=4:
