/*! \mainpage Thyra : Fundamental Operator/Vector Interfaces for the Development of Abstract Numerical Algorithms (ANAs)

<b>Warning!</b> Clicking on the above links (i.e. "Class List", "File List"
etc.)  can be a bit overwhelming and not recommended as a way to "browse" the
code that is part of this doxygen collection.  Instead, it is recommended that
one use the outline below to browse the classes and various functions
documented here.  The one exception is the above <a
href="./modules.html">"Modules"</a> link which is essentially an outline of
what is presented below.  The following presentation is designed to expose
developers to the %Thyra ANA Operator/Vector interfaces and related code in
manageable chunks as to not overwhelm.  However, the above links are very
useful as a developer's reference and should only be used as such.

\section Thyra_Op_Vec_outline_sec Outline

<ul>
<li> \ref Thyra_Op_Vec_intro_sec
<li> \ref Thyra_Op_Vec_foundational_interfaces_sec
<li> \ref thyra_operator_vector_use_cases_sec
<li> \ref thyra_operator_vector_examples_sec
<li> \ref Thyra_Op_Vec_faq_sec
<li> \ref Thyra_Op_Vec_links_to_other_documentation_sec
</ul>

\section Thyra_Op_Vec_intro_sec Introduction

The C++ namespace <tt>Thyra</tt> contains abstract interfaces to linear
algebra objects such as vectors and linear operators and its most fundamental
interfaces are shown in the UML class diagram below.  <!-- A detailed
discussion of the motivation, requirements and basic design issues associated
with %Thyra are described in <a href="???">this report</a>.  The purpose of
this outline documentation is not to restate what is in <a href="???">this
report</A>.  --> This documentation page is meant to provide a road-map to the
Doxygen-generated C++ code documentation and provide convenient access to
helpful examples.

This main page provides the starting point for all of the documentation for
the %Thyra Operator/Vector Interfaces.

\section Thyra_Op_Vec_foundational_interfaces_sec Foundational Thyra Operator/Vector Interfaces

\image html ThyraOperatorVectorSimple.gif "Foundational Thyra operator/vector interfaces (Note: above graphic is not hyper-linked!)"

The most fundamental abstract interfaces contained in the %Thyra package
(and shown in the above UML class diagram) are:

<ul>
<li><tt>Thyra::VectorSpaceBase</tt> is the fundamental abstract interface for a vector space that defines
    the scalar product and factory functions for creating <tt>Thyra::VectorBase</tt> and <tt>Thyra::MultiVectorBase</tt> objects.
<li><tt>Thyra::VectorBase</tt> is the fundamental abstract interface for finite-dimensional vectors.
<li><tt>Thyra::LinearOpBase</tt> is the fundamental abstract interface for linear operators.
<li><tt>Thyra::MultiVectorBase</tt> is the fundamental abstract interface for collections of column vectors.
<li><tt>RTOpPack::RTOpT</tt> is the fundamental abstract interface to all diagonal vector reduction/transformation operations.
</ul>

From here on out, the abstract C++ classes <tt>Thyra::VectorSpaceBase</tt>,
<tt>Thyra::VectorBase</tt>, <tt>Thyra::MultiVectorBase</tt> and
<tt>Thyra::LinearOpBase</tt> will be referred to as the <b><em>foundational
%Thyra operator/vector interfaces</em></b>.

The rest of the C++ classes and non-member functions described in this doxygen
collection are designed to support one of a number of different use cases
associated with the above foundational %Thyra operator/vector interfaces.

\section thyra_operator_vector_use_cases_sec Use Cases for Foundational Thyra Operator/Vector Interfaces

Here we outline three common use cases related to the \ref
Thyra_Op_Vec_foundational_interfaces_sec .

There are primarily three different use cases related to the foundational
%Thyra operator/vector interfaces shown above.  The first, and by far the most
important, is the use of the \ref Thyra_Op_Vec_ANA_Interoperability_grp.  This
first use case is really the main reason for the creation of %Thyra in the
first place and is the most basic and important dependence that another
package can have on %Thyra.  The second most important use case is the \ref
Thyra_Op_Vec_Adapters_grp of vector spaces, vectors, multi-vectors and linear
operators.  These types of subclass implementations are also known as
"adapter" subclasses if they "adapt" some pre-existing set of classes or
interfaces (which is often the case).  The third use case is the use of the
\ref Thyra_Op_Vec_ANA_Development_grp.  While the foundational %Thyra
operator/vector interface classes were not directly designed for this use
case, with some minimal helper functions and classes, directly writing ANA
implementations in terms of %Thyra objects is quite straightforward.

Click on the links below for a discussion of each of these three use cases and
a description of additional supporting code.  These use cases provide the
primary documentation organization for the software in this doxygen
collection.

<ol>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ol>

\section thyra_operator_vector_examples_sec Assorted Thyra Operator/Vector Examples


Below are links to example code that demonstrate various use cases for
the code in the %Thyra package:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_grp : These are examples that use a
simple power method ANA and show both templated serial and MPI
implementations.

<li>\ref Thyra_Op_Vec_examples_cg_grp : These are examples that use a simple CG ANA
and show both templated serial and MPI implementations.

<li>\ref Thyra_Op_Vec_product_vec_spc_prg_grp : This is a simple testing
program that demonstrates how product vectors and product spaces are
created and used.

</ol>


\section Thyra_Op_Vec_faq_sec Frequently Asked Questions (FAQ)

Click \ref Thyra_Op_Vec_faq_grp "here" for a list of frequently asked
questions (FAQ) compiled for this collection of code.

\section Thyra_Op_Vec_links_to_other_documentation_sec Links to Other Documentation Collections

Below are links to other related documentation:

<ul>

<li><b><a href="../../../../../doc/html/index.html">Main Thyra Package
Documentation</a></b>: This is the main documentation page for the %Thyra
package which provides an outline for all %Thyra software.

<li><b><a href="../../../../../../epetra/thyra/doc/html/index.html">ANA Operator/Vector
Adapters for Epetra</a></b>: This software allows the creation of
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt>,
<tt>Thyra::MultiVectorBase</tt>, and <tt>Thyra::LinearOpBase</tt> objects out
of Epetra objects.

<li><b><a href="../../../../../../amesos/thyra/doc/html/index.html">ANA Linear Solver
Adapters for Amesos</a></b>: This software defines the implementation of the
extended interfaces <tt>Thyra::LinearOpWithSolveBase</tt> and
<tt>Thyra::LinearOpWithSolveFactoryBase</tt> in terms of
<tt>Amesos_BaseSolver</tt> implementations.  These adapters allow a client to
take any <tt>Epetra_RowMatrix</tt> object embedded in a
<tt>Thyra::EpetraLinearOp</tt> object and immediately use to to define a
direct linear solver.

<li><b><a href="../../../../../../aztecoo/thyra/doc/html/index.html">ANA Linear Solver
Adapters for AztecOO</a></b>: This software defines the implementation of the
extended interfaces <tt>Thyra::LinearOpWithSolveBase</tt> and
<tt>Thyra::LinearOpWithSolveFactoryBase</tt> in terms of the <tt>AztecOO</tt>
class.  These adapters allow a client to take any <tt>Epetra_RowMatrix</tt>
object embedded in a <tt>Thyra::EpetraLinearOp</tt> object and immediately use
to to define an iterative linear solver such as GMRES or CG.

</ul>

*/

/** \defgroup Thyra_Op_Vec_faq_grp Frequently Asked Questions (FAQ) about Thyra Operator/Vector Software

\section Thyra_Op_Vec_faq_outline_sec Outline

<ul>

<li>\ref Thyra_Op_Vec_faq_rcp_sec

  <ul>
  <li>\ref Thyra_Op_Vec_faq_rcp_important_sec
  <li>\ref Thyra_Op_Vec_faq_rcp_amp_star_sec
  <li>\ref Thyra_Op_Vec_faq_rcp_everywhere_sec
  </ul>

<li>\ref Thyra_Op_Vec_faq_itfc_sec

  <ul>
  <li>\ref Thyra_Op_Vec_faq_why_helper_funcs_sec
  <li>\ref Thyra_Op_Vec_faq_index_op_sec
  <li>\ref Thyra_Op_Vec_faq_op_overload_sec
  <li>\ref Thyra_Op_Vec_faq_Scalar_sec
  <li>\ref Thyra_Op_Vec_faq_creating_vecs_multivecs_sec
  </ul>

</ul>

\section Thyra_Op_Vec_faq_rcp_sec Questions about the smart pointer class Teuchos::RCP

\subsection Thyra_Op_Vec_faq_rcp_important_sec Q: What are RCP objects and why are they important?

<b>A:</b>The class Teuchos::RCP implements a form of reference
counting which, through the magic of smart pointers in C++, allows objects to
be created and used without much concern for when and where they should be
deleted.  It is a form of garbage collection but is not as general or fail-
safe as in languages with built in garbage collection.  For more information
see:

http://trilinos.sandia.gov/RefCountPtrBeginnersGuideSAND.pdf

and click on: <tt>Teuchos::RCP</tt>

\subsection Thyra_Op_Vec_faq_rcp_amp_star_sec Q: Do I really have to write &*ptr all the time?

What are the benefits of &* vs. get()?

<b>A:</b> There are two ways to get at the underlying raw pointer to an
object that is wrapped in the RCP<C> object <tt>c_ptr</tt>:

\code

C *c_rptr1 = c_ptr.get(); // Unchecked, can be NULL
C *c_rptr2 = &*c_ptr;     // Checked in debug build and will not return NULL
\endcode

You should use <tt>c_ptr.get()</tt> when it is okay for the pointer to be
<tt>NULL</tt>.  On the other hand, you should use <tt>&*c_ptr</tt> when you
don't want to allow the raw pointer to be <tt>NULL</tt>.  This is because the
operator function <tt>Teuchos::RCP::operator*()</tt> will throw an
exception if <tt>Teuchos::RCP::get()==NULL</tt> when the code is
compiled using the macro define <tt>-D_DEBUG</tt>.

For more information see Item 3 in Appendix B in 

http://trilinos.sandia.gov/RefCountPtrBeginnersGuideSAND.pdf

\subsection Thyra_Op_Vec_faq_rcp_everywhere_sec Q: Should my code use RCP's everywhere?

<b>A:</b> You should only use RCP to wrap objects where a persisting
relationship is being formed or maintained.  For non-persisting relationships,
use raw C++ references and pointers.

For more information see the main body and Appendix D of the document:

http://trilinos.sandia.gov/RefCountPtrBeginnersGuideSAND.pdf

\section Thyra_Op_Vec_faq_itfc_sec Questions about Fundamental Thyra Operator/Vector Interfaces

\subsection Thyra_Op_Vec_faq_why_helper_funcs_sec Q: Why is Thyra written with so many non-member helper functions instead of member functions?

In my C++ class we were told that the beauty of OOP is that functions and data
can be put together into classes to combine the operations with the data they
operate on.

<b>A:</b> Generally member functions should only be used over non-member
functions when direct access to private or protected data for functions is
required.  My minimizing the amount of code that can access non-public data
you greatly simplify maintenance.  See section 11.3.1 in "The C++ Programming
Language: Special Edition" for a discussion of this topic.

\subsection Thyra_Op_Vec_faq_index_op_sec Q: Why don't Thyra vectors support element access using the an overloaded operator[]?

<b>A:</b> Direct element access to vector data through the
<tt>Thyra::VectorBase</tt> interface can not be allowed in most general
abstract numerical algorithms except in very specialized cases.  Direct
element access assumes that all of the the vector data is readily available
which is not the case in distributed-memory, out-of-core and certainly not
client/server runtime configurations.  In addition, an overloaded
<tt>operator[]</tt> function would be extremely inefficient since it would
have to be a virtual function.

For more information on the philosophy of the design of vector interface
<tt>Thyra::VectorBase</tt> see the document "Vector Reduction/Transformation
Operators" at:

http://software.sandia.gov/RTOp/RTOpTOMS.pdf

\subsection Thyra_Op_Vec_faq_op_overload_sec Q: Why doesn't Thyra support linear algebra operations using overloaded operators for +, -, *, etc?

<b>A:</b> Supporting Matlab-like syntax for linear algebra operations like:

\verbatim

  y = alpha*x + z;

  y = adjoint(A)*x + B*z;
\endverbatim

for large abstract objects in a near-optimally efficient manner is extremely
non-trivial.  Such a capability can be supported through the creation of
handle classes and compile-time expression templates but such an
implementation is complicated and is difficult for beginners to debug through.
There are a whole host of other reasons they Matlab-like syntax will not work
as well as in Matlab.  For a slightly more detailed discussion, see the document

<b><a href="./LinearAlgebraFunctionConvention.pdf">A Simple Convention for
the Specification of Linear Algebra Function Prototypes in C++ </a></b>

In short, Thyra does not (yet) support operator overloading for Matlab-like
syntax and will not until the resulting code can be as efficient, compile-time
safe, and as debuggable as the current lower-level function-call interface.
However, check back with Thyra in the near future and you might find such
handle classes with operator overloading.

\subsection Thyra_Op_Vec_faq_Scalar_sec Q: Where is the Scalar class, and how do I use it to replace my underlying data-type, e.g. double, in my ANA? 

<b>A:</b> The 'Scalar' class in a template argument in all of the core Thyra
interface code.  The goal of this template argument is to allow many abstract
numerical algorithms to be written in a general form to support a number of
different scalar types (e.g. real, complex, extended precision etc.).  While
the interfaces, the composite classes, and many of the concrete
implementations are fully templated some are not and can only support one
scalar type (e.g. see the Epetra/Thyra adapters).

See the <tt>Thyra::sillyCgSolve()</tt> and <tt>Thyra::sillyPowerMethod()</tt>
examples for how this templating is used.

\subsection Thyra_Op_Vec_faq_creating_vecs_multivecs_sec Q: How do I create a Thyra::VectorBase or Thyra::MultiVectorBase object?

The member functions Thyra::VectorSpaceBase::createMember() and
Thyra::VectorSpaceBase::createMembers() are protected and can not be called by
client code.

<b>A:</b> You must use the non-member functions <tt>Thyra::createMember()</tt>
and <tt>Thyra::createMembers()</tt> described \ref
Thyra_Op_Vec_createMember_grp "here".

<!-- \subsection Thyra_Op_Vec_faq_xxx_sec Q: -->

*/

/** \defgroup Thyra_Op_Vec_use_cases_grp Use Cases for the Foundational Thyra Operator/Vector Interfaces

\brief Here we outline three common use cases related to the \ref
Thyra_Op_Vec_foundational_interfaces_sec.

Click on the links below for a discussion of each of these three use
cases and a description of additional supporting C++ classes and
non-member functions.

<ol>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ol>

*/

/** \defgroup Thyra_Op_Vec_ANA_Interoperability_grp Thyra Operator/Vector Interfaces as an Interoperability Layer for Abstract Numerical Algorithms (ANAs)

\ingroup Thyra_Op_Vec_use_cases_grp

\brief As stated in the \ref index "introduction", the primary purpose
of %Thyra is to define a set of basic and minimal abstract
interfaces to support the interoperability of abstract numerical
algorithms (ANAs).

Below, the interoperability interfaces are divided into \ref
Thyra_Op_Vec_Interoperability_Fundamental_Interfaces_sec "fundamental" and
\ref Thyra_Op_Vec_Interoperability_Extended_Interfaces_sec "extended"
categories.  The fundamental operator/vector interfaces are the foundation for
all other interfaces and software described in this doxygen collection.  The
extended operator/vector interfaces define new types of functionality.

\section Thyra_Op_Vec_Interoperability_Fundamental_Interfaces_sec Fundamental Interfaces

\image html ThyraOperatorVector.gif "Fundamental vector and linear operator interfaces (Note: above graphic is not hyper-linked!)"

The above UML class diagram is a more detailed version of the UML
class diagram shown in the \ref index "introduction" for the
foundational operator/vector interface classes.  The fundamental interface classes
shown in the above UML class diagram are described below:

<ul>
<li><tt>Thyra::VectorSpaceFactoryBase</tt> is basic factory interface for creating
    <tt>Thyra::VectorSpaceBase</tt> objects given a dimension.
<li><tt>Thyra::VectorSpaceBase</tt> is the fundamental abstract interface for a vector space that defines
    the scalar product and factory functions for creating <tt>Thyra::VectorBase</tt> and <tt>Thyra::MultiVectorBase</tt> objects.
<li><tt>Thyra::VectorBase</tt> is the fundamental abstract interface for finite-dimensional vectors.
<li><tt>Thyra::LinearOpBase</tt> is the fundamental abstract interface for linear operators.
<li><tt>Thyra::MultiVectorBase</tt> is the fundamental abstract interface for collections of column vectors.
</ul>

These interface classes rely on a few \ref Thyra_Op_Vec_BasicTypes_grp "basic types"
and \ref Thyra_Op_Vec_Exceptions_grp "basic exception classes".

<!-- The details behind the design of these interfaces are described in detail
in <a
href="http://trilinos.sandia.gov/packages/tsfcore/TSFCoreSAND.pdf">this
report</a> and in the documentation for each individual C++ class. --> One
important paper describing the RTOp approach which provides the foundation for
<tt>RTOpPack::RTOpT</tt> can be found in <a
href="http://software.sandia.gov/RTOp/RTOpTOMS.pdf">this paper</a>.  Note that
<tt>RTOpPack::RTOpT</tt> is a refinement of the C and C++ RTOp interfaces
described in the aforementioned paper.

\section Thyra_Op_Vec_Interoperability_Extended_Interfaces_sec Extended Interfaces

The %Thyra package also contains a set of
\ref Thyra_Op_Vec_Interoperability_Extended_Interfaces_grp "extended interfaces" that build on
the above fundamental operator/vector interfaces that play a role in extended
levels of interoperability.

\section Thyra_Op_Vec_ANA_Interoperability_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_Adapters_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_fundamental_interfaces_code_grp C++ code for foundational Thyra operator/vector interfaces

\ingroup Thyra_Op_Vec_ANA_Interoperability_grp

\brief These are the \ref Thyra_Op_Vec_foundational_interfaces_sec that
provide the foundation for all ANAs.

*/

/** \defgroup Thyra_Op_Vec_Interoperability_Extended_Interfaces_grp Extended Operator/Vector interfaces

The %Thyra package also contains a set of
extended interfaces that build on
the \ref Thyra_Op_Vec_Interoperability_Fundamental_Interfaces_sec "fundamental"
operator/vector interfaces that play a role in interoperability with extended levels of functionality.

<ol>

<li> <b>Interfaces to product vector spaces, vectors and multi-vectors</b>

<ul>
<li><tt>Thyra::ProductVectorSpaceBase</tt> defines an interface for a composite product vector space composed out of one
    or more constituent <tt>Thyra::VectorSpaceBase</tt> objects.
<li><tt>Thyra::ProductVectorBase</tt> defines an interface for a composite product vector composed out of one
    or more constituent <tt>Thyra::VectorBase</tt> objects.
<li><tt>Thyra::ProductMultiVectorBase</tt>  defines an interface for a composite product multi-vector composed out of one
    or more constituent <tt>Thyra::MultiVectorBase</tt> objects.
</ul>

Concrete implementations of these basic interfaces are described \ref
Thyra_Op_Vec_ANA_Development_overview_sec "here".

<li> <b>Interfaces to invertible linear operators</b>

<ul>
<li><tt>Thyra::LinearOpWithSolveBase</tt> defines a simple interface for performing the inverse
linear operator application.
<li><tt>Thyra::LinearOpWithSolveFactoryBase</tt> defines an interface for generating or updating a
<tt>Thyra::LinearOpWithSolveBase</tt> object out of a <tt>Thyra::LinearOpBase</tt> object.
</ul>

</ol>

\ingroup Thyra_Op_Vec_ANA_Interoperability_grp

*/

/** \defgroup Thyra_Op_Vec_Adapters_grp Development of Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_use_cases_grp

\brief In order for abstract numerical algorithms (ANAs)
\ref Thyra_Op_Vec_ANA_Development_grp "developed with Thyra" or
\ref Thyra_Op_Vec_ANA_Interoperability_grp "accessed using Thyra" to be useful,
concrete implementations of the
\ref Thyra_Op_Vec_foundational_interfaces_sec must be provided.
However, because of a number of convenient C++ subclasses described
here, a developer of such implementation subclasses does not really need to understand much at all
about the philosophy or details behind the fundamental %Thyra
interfaces in order to provide implementations for the most common use
cases.

One of the main motivations behind the design of the \ref
Thyra_Op_Vec_foundational_interfaces_sec is the uniform support for many
different computing environments such as serial shared-memory (i.e. SMP) and a
variety of distributed-memory models (e.g. SPMD (single program, multiple
data), client-server, master-slave and client-server/master-slave).  While
this is the case, the overwhelming majority of concrete implementations of
these types will be in more typical SMP serial shared-memory or SPMD
distributed-memory environments.  Because of this, the Trilinos package %Thyra
contains a set of base subclasses that makes the development of concrete
vector space, vector, multi-vector and linear operator subclasses as easy as
possible.  However, the \ref Thyra_Op_Vec_foundational_interfaces_sec allow
for almost limitless possibilities with respect to the types of
implementations so it is not reasonable to provide pre-packaged support for
all of the possibilities.

<b>Heads Up!</b> In case you think you will have to develop your own concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> or
<tt>Thyra::MultiVectorBase</tt> subclasses in addition to whatever
<tt>Thyra::LinearOpBase</tt> subclasses that you need for you application, you
are probably wrong!  You most likely will not need to create any concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> or
<tt>Thyra::MultiVectorBase</tt> subclasses and instead should only need to
develop concrete <tt>Thyra::LinearOpBase</tt> subclass(es) by deriving from
<tt>Thyra::SerialLinearOpBase</tt> for serial platforms or
<tt>Thyra::MPILinearOpBase</tt> for MPI SPMD platforms.  As described below,
general yet efficient implementations of concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> and
<tt>Thyra::MultiVectorBase</tt> subclasses for serial and MPI SPMD platforms
are already available.

Next, we provide a description of the various types of support code
for creating concrete implementations as well as concrete
implementations that are available.  Just browse the categories that
you are interested in.

\section Thyra_Op_Vec_Adapters_overview_sec Overview of Concrete Thyra Subclass Implementations

<ol>

<li><b>Basic default implementation node subclasses</b>

The following subclasses directly derive from \ref
Thyra_Op_Vec_foundational_interfaces_sec and provide general default
implementations for as many virtual functions as reasonable:

<ul>

<li><tt>Thyra::VectorSpaceDefaultBase</tt> should be a direct or indirect base
class of almost every <tt>Thyra::VectorSpaceBase</tt> subclass.  This node
subclass provides the default implementation
<tt>Thyra::VectorSpaceDefaultBase::createMembers()</tt> using
<tt>Thyra::DefaultColumnwiseMultiVector</tt>.  Therefore, a subclass need only provide a
<tt>VectorBase</tt> implementation and override
<tt>Thyra::VectorSpaceBase::createMember()</tt> and related functions.

<li><tt>Thyra::MultiVectorDefaultBase</tt> should be a direct or indirect base
class of almost every <tt>Thyra::MultiVectorBase</tt> subclass.  This node
subclass provides a default of every inherited virtual function from the base
class <tt>Thyra::MultiVectorBase</tt> in terms of just
<tt>Thyra::MultiVectorBase::col()</tt>.  While many of these default function
implementations are highly non-optimal, the none the less allow for rapid
prototyping of new <tt>Thyra::MultiVectorBase</tt> subclasses.

<li><tt>Thyra::VectorDefaultBase</tt> should be a direct or indirect base
class of almost every <tt>Thyra::VectorBase</tt> subclass.  This node subclass
provides full general and efficient implementations of all of the inherited
virtual functions from the base class <tt>Thyra::MultiVectorBase</tt>.

</ul>

<li><b>\ref Thyra_Op_Vec_basic_adapter_support_grp</b>

Click \ref Thyra_Op_Vec_basic_adapter_support_grp "here" if you want to know
about high-level support subclasses for separating out the definition of the
scalar product from the data structures and factory methods for specific
computing platforms.  All of the concrete %Thyra implementation subclasses
outlined below derive from and use these base interfaces.  However, knowing
the details of these base interfaces is not critical for developing concrete
implementations in most situations unless application-defined scalar products
are needed.  The Euclidean scalar product is used automatically by default and
if that is all you need then you can ignore these base classes.

<li><b>Support subclasses for specific types of computing platforms</b>

Below we outline support code contained in the %Thyra package for
different categories of computing platforms.

<b>Note!</b> Before attempting to create your own concrete subclasses
of the \ref Thyra_Op_Vec_foundational_interfaces_sec please browse the 
links below so that you know what support is already available.  In many
cases, most of the concrete implementation software that you need for
%Thyra is already provided.

<ol>

<li><b>\ref Thyra_Op_Vec_serial_adapters_grp</b>

Click \ref Thyra_Op_Vec_serial_adapters_grp "here" if you want to know about
support for developing %Thyra subclass implementations for serial
shared-memory platforms.  Since these are the most commonly used computing
platforms by applied mathematicians and academic researchers, these subclasses
should be the most commonly used by this group.  Note that the above link also
describes very general and efficient concrete serial subclasses for vector
spaces, vectors and multi-vectors as well as a support class for creating
concrete linear operator implementations.

<li><b>\ref Thyra_Op_Vec_mpi_adapters_grp</b>

Click \ref Thyra_Op_Vec_mpi_adapters_grp "here" if you want to know about
support for developing %Thyra subclass implementations for SPMD
distributed-memory platforms.  These platforms are most commonly used in
large-scale scientific computing.  Note that the above link also describes
very general and efficient concrete MPI SPMD subclasses for vector spaces,
vectors, and multi-vectors as well as a support class for creating concrete
SPMD linear operator implementations.

</ol>

</ol>

\section Thyra_Op_Vec_Adapters_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_general_adapter_support_code_grp Miscellaneous Support Code for Developing Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_Adapters_grp

\brief This is some basic C++ code to support the development of Thyra subclass implementations.

*/


/** \defgroup Thyra_Op_Vec_general_adapter_support_code_utils_grp Internal Helper Code not meant for General Use

\brief Some support code that is not meant for general programmers to access.

\ingroup Thyra_Op_Vec_general_adapter_support_code_grp

*/

/** \defgroup Thyra_Op_Vec_basic_adapter_support_grp Basic Support Subclasses Abstracting Application-Specific Scalar Products

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The \ref Thyra_Op_Vec_foundational_interfaces_sec define an interface
for providing ANAs with the functionality they need concerning
application-specific scalar products without concern for how such scalar
products are implemented or how such scalar products relate to the
implementation of vectors, multi-vectors or linear operators.  While this is
most straightforward for clients of these interfaces, it is not the most
convenient for subclass implementation developers.  The first level of basic
subclasses for supporting the development of concrete %Thyra operator/vector
implementations involves separating out the definition of the scalar product
from the basic vector and multi-vector data structures and the factory methods
for creating them.  The base subclasses for supporting application-defined
scalar products are shown in the UML class diagram below.

\image html ScalarProdVectorSpaceBase.gif "Support base subclasses for abstracting application-specific scalar products (Note: above graphic is not hyperlinked!)"

The classes shown in the above UML class diagram are described below:

<ul>

<li><tt>Thyra::ScalarProdBase</tt> defines an interface for an
application-specific scalar product independent from a vector space.

<li><tt>Thyra::ScalarProdVectorSpaceBase</tt> is subclass of
<tt>%Thyra::%VectorSpaceBase</tt> that defines the scalar product functions in
terms of an aggregate <tt>%Thyra::%ScalarProdBase</tt> object that can be
swapped in and out (see the C++ code for the
<tt>Thyra::ScalarProdVectorSpaceBase::scalarProd()</tt> function as an
example).

<li><tt>Thyra::EuclideanScalarProd</tt> is a standard implementation subclass
of <tt>%Thyra::%ScalarProdBase</tt> for Euclidean scalar products (i.e. using
the dot product).  This is the default scalar product definition used by
<tt>%Thyra::%ScalarProdVectorSpaceBase</tt> and all of its subclass objects.

<li><tt>Thyra::LinearOpScalarProd</tt> is a more general implementation of a
scalar product that uses an arbitrary symmetric positive-definite
<tt>%Thyra::%LinearOpBase</tt> object (shown using the <tt>op</tt>
relationship in the above UML class diagram).

<li><tt>Thyra::EuclideanLinearOpBase</tt> is a base subclass that allows the
development of general concrete implementations of
<tt>%Thyra::%LinearOpBase</tt> that are independent of an application-specific
scalar product.  This base subclass defines the functions
<tt>Thyra::EuclideanLinearOpBase::euclideanApply()</tt> and
<tt>Thyra::EuclideanLinearOpBase::euclideanApplyTranspose()</tt> which are
called by <tt>Thyra::ScalarProdBase::apply()</tt> to modify the application of
an Euclidean linear operator for the definition of the scalar product (see the
C++ code for the overridden <tt>Thyra::EuclideanLinearOpBase::apply()</tt> and
<tt>Thyra::EuclideanLinearOpBase::applyTranspose()</tt> functions).  This base
class is most helpful for the definition of concrete
<tt>Thyra::MultiVectorBase</tt> subclasses.  More specialized linear operators
that already define the operator with respect to application-specific scalar
product should not derive from this subclass but should instead derive
directly from <tt>%Thyra:%LinearOpBase</tt>.

</ul>

The base subclasses <tt>Thyra::ScalarProdVectorSpaceBase</tt> and
<tt>Thyra::EuclideanLinearOpBase</tt> are used for almost all of the other
adapter support subclasses and concrete implementations in the %Thyra package.

*/

/** \defgroup Thyra_Op_Vec_serial_adapters_grp Thyra Operator/Vector Subclasses for Serial Shared-Memory Platforms

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The package %Thyra includes subclasses for common serial
shared-memory vector spaces, vectors and multi-vectors which are
described here.

Given the subclasses described below, there should be no need to create new
concrete serial shared-memory vector spaces, vectors or multi-vectors when
interfacing to most other well designed software.

\section Thyra_Op_Vec_serial_adapters_classes_sec Subclasses for Serial Implementations

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_serial_support_grp</b>

Click \ref Thyra_Op_Vec_adapters_serial_support_grp "here" if you want to know
about the basic support node subclasses for a common type of serial vector and
multi-vector implementation that all of the concrete implementations described
below derive from.

<li> <b>Concrete Serial Subclasses</b>

Below are some concrete implementations of %Thyra classes that are
derived from the
\ref Thyra_Op_Vec_adapters_serial_support_grp "basic serial base subclasses"
mentioned above.

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_serial_concrete_std_grp</b>

Click \ref Thyra_Op_Vec_adapters_serial_concrete_std_grp "here" if you want to
know about some general, yet very efficient, concrete implementations of
serial vector spaces, vectors and multi-vectors.

</ol>

</ol>

\section Thyra_Op_Vec_serial_adapters_examples_sec Example Subclasses for Serial Shared-Memory Platforms

The only example that one should need for how to provide a serial
implementation for the \ref Thyra_Op_Vec_foundational_interfaces_sec is
provided below:

<ul>

<li><tt>SerialTridiagLinearOp</tt> is a simple templated
concrete linear operator subclass for tridiagonal matrices that
derives from <tt>Thyra::SerialLinearOpBase</tt>.

</ul>

To create a new specialized serial <tt>Thyra::LinearOpBase</tt> subclass
one should just have to copy the source code for the above example
<tt>SerialTridiagLinearOp</tt> subclass into a new file(s), change the
name and then modify the new subclass as needed.

*/

/** \defgroup Thyra_Op_Vec_serial_adapters_support_code_grp Support code for Thyra Operator/Vector Subclasses for Serial Shared-Memory Platforms

\ingroup Thyra_Op_Vec_serial_adapters_grp

*/

/** \defgroup Thyra_Op_Vec_adapters_serial_support_grp Thyra Operator/Vector Base Support Subclasses for Serial Shared-Memory Implementations

\ingroup Thyra_Op_Vec_serial_adapters_grp

\brief The package %Thyra includes node subclasses for serial vector spaces,
vectors, multi-vectors, and linear operators.

The UML class diagram below shows the subclasses described here:

\image html SerialVectorSpaceBase.gif "Support base subclasses for serial shared-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

\section Thyra_Op_Vec_serial_adapters_classes_sec Base Subclasses for Serial Shared-Memory Platforms

The following subclasses represent general yet very efficient node subclasses
that almost all serial shared-memory vector space, vector and multi-vector
subclasses can and should inherit from.

<ul>

<li><tt>Thyra::SerialVectorSpaceBase</tt> is a useful node subclass for
defining concrete serial vector space subclasses.  This subclass simply
overrides <tt>%Thyra::VectorSpaceBase::isCompatible()</tt> to return
<tt>true</tt> if the other vector space is in core and is the same dimension
since this is all that should be required for serial vectors and multi-vectors
to be 100\% compatible.

<li><tt>Thyra::SerialVectorBase</tt> is a useful node subclass for defining
concrete serial vector subclasses.  This base class provides a very general
implementation for <tt>%Thyra::%VectorBase::%applyOp()</tt> that relies on
explicit vector element access.  All that a concrete subclass must do to is to
provide explicit access to vector data in overrides of the virtual
<tt>Thyra::SerialVectorBase::getData()</tt> functions.

<li><tt>Thyra::SerialMultiVectorBase</tt> is a useful node subclass for
defining concrete serial multi-vector subclasses.  This base class provides
implementations for both <tt>%Thyra::%MultiVectorBase::%applyOp()</tt> and
<tt>%Thyra::%MultiVectorBase::%apply()</tt> that relies on explicit
multi-vector element access.  All that a concrete subclass must do is to
provide explicit access to multi-vector data in overrides of the
<tt>Thyra::SerialMultiVectorBase::getData()</tt> functions.  Note in general
that the override of <tt>Thyra::MultiVectorBase::apply()</tt> is a level-3
BLAS operation and this base class uses <tt>Teuchos::BLAS::GEMM()</tt> to
access optimized level-3 BLAS.  This assumes that the %Teuchos package has
been configured to use optimized BLAS (for the data types <tt>float</tt>,
<tt>double</tt>, <tt>std::complex<float></tt> and
<tt>std::complex<double></tt> of course).

</ul>

The above base subclasses <tt>Thyra::SerialVectorBase</tt> and
<tt>Thyra::SerialMultiVectorBase</tt> should provide very efficient
implementations of all of the operations defined on <tt>Thyra::VectorBase</tt>
and <tt>Thyra::MultiVectorBase</tt> for serial shared-memory platforms.  All
that concrete subclasses must provide is explicit access to vector and
multi-vector data.

\section Thyra_Op_Vec_serial_adapters_linear_op_sec Base Subclasses for Serial Thyra::LinearOpBase Implementations

To facilitate the creation of concrete serial linear operators the
following simple but very general base class is supplied:

<ul> <li><tt>Thyra::SerialLinearOpBase</tt> is a general node subclass for
serial shared-memory platforms that only requires concrete subclass
implementations to override one function that accepts explicit vector data.
</ul>

*/

/** \defgroup Thyra_Op_Vec_adapters_serial_concrete_std_grp Efficient Generic Serial Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_serial_adapters_grp

\brief The package %Thyra includes general, yet very efficient, concrete
subclass implementations for serial vector spaces, vectors, multi-vectors, and
linear operators.

The UML class diagram below shows the subclasses described here:

\image html DefaultSerialVectorSpace.gif "Concrete subclasses for serial shared-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

<ul>

<li><tt>Thyra::DefaultSerialVectorSpaceFactory</tt> is a general concrete
implementation of a factory for serial vector spaces that creates
<tt>%Thyra::%DefaultSerialVectorSpace</tt> objects of any given dimension.  This
subclass is used to provide the default implementation of
<tt>%Thyra::VectorSpaceDefaultBase::smallVecSpcFcty()</tt>.  As a result,
<tt>%Thyra::%DefaultSerialVectorSpace</tt> is the default implementation of the
domain space of the default multi-vectors returned from
<tt>%Thyra::%VectorSpaceDefaultBase::%createMembers()</tt>.

<li><tt>Thyra::DefaultSerialVectorSpace</tt> is a general concrete implementation
for serial vector spaces that creates <tt>%Thyra::DefaultSerialVector</tt> and
<tt>%Thyra::DefaultSerialMultiVector</tt> objects.  All this subclass really does
is provide trivial implementations for the factory methods
<tt>%Thyra::%VectorSpaceBase::%createMember()</tt> and
<tt>%Thyra::%VectorSpaceBase::%createMembers()</tt>.

<li><tt>Thyra::DefaultSerialVector</tt> is an efficient general concrete
implementation for serial vectors.  All this subclass does is provide storage
for a serial vector and return pointers to that storage to the
<tt>%Thyra::SerialVectorBase</tt> base class through the overridden
<tt>%Thyra::DefaultSerialVector::getData()</tt> functions.  This concrete subclass
has constructors that accept arbitrary strided data and can trivially handle
any underlying data storage format due to the magic of
<tt>%Teuchos::RCP</tt>.

<li><tt>Thyra::DefaultSerialMultiVector</tt> is an efficient general concrete
implementation for serial multi-vectors.  All this subclass does is provide
storage for a serial multi-vector and return pointers to that storage (and
leading dimension) to the <tt>%Thyra::SerialMultiVectorBase</tt> base class
through the overridden <tt>%Thyra::DefaultSerialMultiVector::getData()</tt>
functions.  This concrete subclass has constructors that accept column-major
data and can trivially handle any underlying data storage format due to the
magic of <tt>%Teuchos::RCP</tt>.

</ul>

The above concrete subclasses provide very general and very efficient
implementations for serial vector space, vector, and multi-vector objects.
There should almost never be a need to develop any other serial subclasses for
these objects.  However, if for some reason one decides that one wants to
develop new such subclasses then the above concrete subclasses should provide
an adequate example for how to do so.

*/

/** \defgroup Thyra_Op_Vec_mpi_adapters_grp Thyra Operator/Vector Subclasses for MPI-based SPMD Distributed-Memory Platforms

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The package %Thyra includes subclasses for common MPI-based SPMD vector
spaces, vectors, and multi-vectors which are described here.

When interfacing to most other well designed packages, there should be no need
to create new concrete MPI-based SPMD vector space, vector or multi-vector
subclasses given the subclasses described below.

\section Thyra_Op_Vec_mpi_adapters_classes_sec Subclasses for MPI SPMD Thyra Implementations

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_MPI_support_grp</b>

Click \ref Thyra_Op_Vec_adapters_MPI_support_grp "here" if you want to know
about the basic support base subclasses for a common type of MPI-based SPMD
vector and multi-vector implementation that all of the concrete
implementations described below depend on.

<li> <b>Concrete MPI-based SPMD subclasses</b>

Below are some concrete implementations of %Thyra classes that are
derived from the
\ref Thyra_Op_Vec_adapters_MPI_support_grp "basic MPI-support base subclasses"
mentioned above.

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_MPI_concrete_std_grp</b>

Click \ref Thyra_Op_Vec_adapters_MPI_concrete_std_grp "here" if you want to
know about some general, yet very efficient, concrete implementations of
MPI-based SPMD vector spaces, vectors and multi-vectors.

<li> <b><a href="../../../../../../epetra/thyra/doc/html/index.html">Epetra to Thyra Operator/Vector Adapters</a></b> (separate doxygen collection)

Click <a href="../../../../../../epetra/thyra/doc/html/index.html">here</a> if
you want to know about some general code that takes Epetra objects and creates
%Thyra wrappers for them.

</ol>

</ol>

*/

/** \defgroup Thyra_Op_Vec_adapters_MPI_support_grp Thyra Operator/Vector Base Support Subclasses for MPI-based SPMD Thyra Implementations

\ingroup Thyra_Op_Vec_mpi_adapters_grp

\brief The package %Thyra contains base subclasses that support a
common type of MPI-based SPMD implementation of vectors and
multi-vectors that are described here.

The UML class diagram below shows the subclasses described here:

\image html MPIVectorSpaceBase.gif "Support base subclasses for MPI SPMD distributed-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

The base subclasses described here provide support for a simple, yet
general, category of MPI-based SPMD vectors, multi-vectors and vector
spaces.

<ul>

<li><tt>Thyra::MPIVectorSpaceBase</tt> abstracts the the types of
SPMD distributed-memory data distributions supported by these base
subclasses.  This vector space base class assumes a unique
partitioning of vector and multi-vector elements to a set of
processors where there exists no ghost elements.

<li><tt>Thyra::MPIVectorBase</tt> is a base subclass for MPI-based
SPMD <tt>%Thyra::%VectorBase</tt> objects.  This class defines concrete
implementations for the <tt>%Thyra::%VectorBase</tt> virtual functions
<tt>%applyOp()</tt>, <tt>%acquireDetachedView() const</tt>, <tt>%releaseDetachedView()
const</tt>, <tt>%acquireDetachedView()</tt> and <tt>%commitDetachedView()</tt>.
These functions are implemented given explicit access to local processor
elements as returned by the <tt>getLocalData()</tt> functions overridden
in a subclass object.

<li><tt>Thyra::MPIMultiVectorBase</tt> is a base subclass for
MPI-based SPMD <tt>%Thyra::%MultiVectorBase</tt> objects.  This class
defines concrete implementations for the
<tt>%Thyra::%MultiVectorBase</tt> virtual functions <tt>%applyOp()</tt>,
<tt>%acquireDetachedView() const</tt>, <tt>%releaseDetachedView()
const</tt>, <tt>%acquireDetachedView()</tt> and
<tt>%commitDetachedView()</tt>.  These functions are implemented
given explicit access to local processor elements as returned by the
<tt>getLocalData()</tt> functions overridden in a subclass object.  In
addition, this subclass derives from
<tt>Thyra::EuclideanLinearOpBase</tt> so that any
application-specific scalar product is automatically supported.  The
multi-vector version of
<tt>Thyra::MPIMultiVectorBase::euclideanApply()</tt> is implemented
by calling <tt>Teuchos::BLAS::GEMM()</tt> on each local processor to
access level-3 BLAS.  Therefore, if %Teuchos is configured to link to
optimized BLAS then this base subclass will provided a near optimal
implementation of a MPI SPMD multi-vector.

</ul>

One of the big advantages of deriving concrete MPI-based SPMD
implementations from these base subclasses is that they provide automatic
interoperability between different concrete subclasses.  This type of
automatic interoperability is demonstrated in ???this testing program???.

\section Thyra_Op_Vec_mpi_adapters_linear_op_sec Base Subclasses for MPI Thyra::LinearOpBase Implementations

To facilitate the creation of concrete MPI linear operators the
following simple but very general base class is supplied:

<ul> <li><tt>Thyra::MPILinearOpBase</tt> is a general base subclass
for MPI SPMD platforms that only requires concrete subclass
implementations to override one function that accepts explicit local
vector data.  </ul>

*/

/** \defgroup Thyra_Op_Vec_adapters_MPI_concrete_std_grp Efficient Generic MPI-based SPMD Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_mpi_adapters_grp

\brief The package %Thyra contains highly efficient concrete
implementations of MPI-based vector space, vector and multi-vector
subclasses.

\image html DefaultMPIVectorSpace.gif "Concrete subclasses for MPI-based SPMD distributed-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

\section Thyra_Op_Vec_adapters_MPI_concrete_std_classes_grp Concrete MPI-based SPMD Subclasses

The concrete subclasses described here derive directly from the \ref
\ref Thyra_Op_Vec_adapters_MPI_support_grp.

<ul>

<li><tt>Thyra::DefaultMPIVectorSpaceFactory</tt> is a concrete
<tt>%Thyra::%VectorSpaceFactoryBase</tt> subclass implementation that
creates locally replicated <tt>%Thyra::%DefaultMPIVectorSpace</tt> objects
given their dimension.  This class is meant to create domain spaces for
any MPI-based SPMD multi-vector object it is is used as such (for
example, see <tt>Thyra::MPIVectorSpaceBase::smallVecSpcFcty()</tt>).

<li><tt>Thyra::DefaultMPIVectorSpace</tt> is a general
<tt>%Thyra::%VectorSpaceBase</tt> subclass implementation for MPI-based
SPMD vector spaces which creates <tt>%Thyra::%DefaultMPIVector</tt> and
<tt>%Thyra::%DefaultMPIMultiVector</tt> objects.

<li><tt>Thyra::DefaultMPIVector</tt> is a very general, highly
efficient <tt>%Thyra::%VectorBase</tt> subclass implementation for
MPI-based SPMD vectors.  Objects of this type can be constructed
from a variety of data sources due to the magic of
<tt>%Teuchos::%RCP</tt>.

<li><tt>Thyra::DefaultMPIMultiVector</tt> is a very general, highly
efficient <tt>%Thyra::%MultiVectorBase</tt> subclass implementation for
MPI-based SPMD multi-vectors.  Objects of this type can be constructed
from a variety of data sources due to the magic of
<tt>%Teuchos::%RCP</tt>.

</ul>

Together, these concrete subclasses provide a complete and highly
efficient implementation for MPI-based SPMD vector, multi-vector and
vector space objects.  From the standpoint of the needs of an ANA,
there is really no need for any other concrete implementations of
these subclasses for MPI SPMD platforms.

*/

/** \defgroup Thyra_Op_Vec_ANA_Development_grp Thyra Operator/Vector Interfaces as an API for the Development of Abstract Numerical Algorithms (ANAs)

\ingroup Thyra_Op_Vec_use_cases_grp

\brief While the \ref Thyra_Op_Vec_foundational_interfaces_sec were not
principally designed to provide a direct API for the development of
ANA software, with some minimal helper functions and classes, directly
writing even sophisticated ANA implementations directly in terms of
%Thyra objects is quite straightforward.

It turns out that using %Thyra for the development of simple ANAs,
as described below, really does not require any deep understanding of
the \ref Thyra_Op_Vec_foundational_interfaces_sec "foundational Thyra operator/vector interfaces.

\section Thyra_Op_Vec_ANA_Development_overview_sec Overview of Using Thyra Software for Development of ANA Software

There are several different types of helper classes and functions that
simplify the use of %Thyra for the development of ANAs.

<ol>

<li> <b>"Standard" non-member wrapper functions for vector (and multi-vector) reduction/transformation operations</b>

While the use of the <tt>RTOpPack::RTOpT</tt> interface class and the
single <tt>Thyra::VectorBase::applyOp()</tt> function provide an elegant
and efficient solution for the interoperability of vector
interfaces, it is not the easiest API for developing ANAs.  However,
a number of easy to use C++ wrapper functions for many different
 vector and multi-vector operations is already provided:

<ul>
<li> \ref Thyra_Op_Vec_VectorStdOps_grp
<li> \ref Thyra_Op_Vec_MultiVectorStdOps_grp
</ul>

These C++ wrapper functions rely on pre-implemented
<tt>RTOpPack::RTOpT</tt> subclasses.  Adding new
<tt>RTOpPack::RTOpT</tt> subclasses and new wrapper functions for new
vector and multi-vector reduction/transformation operations is an easy
matter for an experienced C++ developer who understands
<tt>RTOpPack::RTOpT</tt> (please contact rabartl@sandia.gov if you
need a new vector or multi-vector operation that is not already
supported).

<li> <b>Creating explicit views of vector and multi-vector elements</b>

<b>Warning!</b> using the utility classes below it is very easy to
obtain direct access to vector and multi-vector elements but in
general, this is a very bad idea.  However, as described in <a
href="http://trilinos.sandia.gov/packages/tsfcore/TSFCoreSAND.pdf">this
report</a>, there are some types of ANAs that require direct element
access to certain kinds of vectors and multi-vectors (for example,
vectors and multi-vectors that lie is the domain space of a
multi-vector).  The following utility classes streamline creating and
using explicit views.

<ul>
<li><tt>Thyra::ConstDetachedVectorView</tt> creates a (<tt>const</tt>) non-mutable explicit view of a <tt>const %Thyra::%VectorBase</tt> object,
    allows direct access to vector elements and then frees the view in the destructor.
<li><tt>Thyra::DetachedVectorView</tt> creates a (non-<tt>const</tt>) mutable explicit view of a <tt>%Thyra::%VectorBase</tt> object,
    allows direct access to vector elements and then frees the view in the destructor.
<li><tt>Thyra::ConstDetachedMultiVectorView</tt> creates a (<tt>const</tt>) non-mutable explicit view of a <tt>const %Thyra::%MultiVectorBase</tt> object,
    allows direct access to multi-vector elements and then frees the view in the destructor.
<li><tt>Thyra::DetachedMultiVectorView</tt> creates a (non-<tt>const</tt>) mutable explicit view of a <tt>%Thyra::%MultiVectorBase</tt> object,
    allows direct access to multi-vector elements and then frees the view in the destructor.
</ul>

One of the big advantages of using the above utility classes in
addition to their convenience is that views are freed in destructors
and these view will be freed even in the event that an exception is
thrown.  The use of these view classes is quite straightforward.

<li> <b>Aggregate vector space, vector, multi-vector and linear operator objects</b>

One of the big advantages of having a set of abstract interfaces to operators
and vectors is that it is quite easy to define some very useful aggregate
subclasses that allow one or more individual objects be treated as a single
object (see the "Composite" and "Decorator" design patterns in the GoF's
"Design Patterns" book).

<ol>

<li> <b>Product vector spaces, vectors and multi-vectors</b>

One particularly useful category of composite linear algebra objects
is the product vector space \f$\mathcal{X} = \mathcal{V}_1 {}\times
\mathcal{V}_2 {}\times {}\ldots {}\times \mathcal{V}_m\f$ where
\f$\mathcal{V}_k\f$, for \f$k = 1 {}\ldots m\f$, are different constituent
vector spaces.  Product vector spaces give rise to product vectors

\f[
x = \left[\begin{array}{c} v_1 \\ v_2 \\ \vdots \\ v_m \end{array}\right]
\f]

(where \f$v_1 \in \mathcal{V}_1, v_2 \in \mathcal{V}_2, \ldots, v_m
\in \mathcal{V}_m\f$) and product multi-vectors

\f[
X = \left[\begin{array}{c} V_1 \\ V_2 \\ \vdots \\ V_m \end{array}\right].
\f]

(where \f$V_1 \in \mathcal{V}_1 | \mathcal{D}, V_2 \in \mathcal{V}_2 | \mathcal{D},
\ldots, V_m \in \mathcal{V}_m | \mathcal{D}\f$ and \f$\mathcal{D}\f$ is the
domain space for the multi-vectors).

Very general concrete implementations of the product vector space, vector and
multi-vector interfaces described \ref
Thyra_Op_Vec_Interoperability_Extended_Interfaces_sec "here" are provided and
are shown below:

<ul>
<li><tt>Thyra::DefaultProductVectorSpace</tt> is a general concrete implementation of <tt>Thyra::ProductVectorSpaceBase</tt>
    that should be sufficient for most use cases.
<li><tt>Thyra::DefaultProductVector</tt> is a general concrete implementation of <tt>Thyra::ProductVectorBase</tt>
    that should be sufficient for most use cases.
<li><tt>Thyra::ProductMultiVector</tt> is a general concrete implementation of <tt>Thyra::ProductMultiVectorBase</tt>
    that should be sufficient for most use cases. (ToDo: This needs to be implemented!)
</ul>

Note that the above concrete subclasses are very efficient for must,
but not all, possible use cases for such composite objects.

When using product vector spaces, product vectors and product
multi-vectors it is generally the case where a concrete
<tt>Thyra::DefaultProductVectorSpace</tt> object is first created and then
<tt>Thyra::DefaultProductVector</tt> and
<tt>Thyra::ProductMultiVector</tt> objects are created by the
functions <tt>Thyra::DefaultProductVectorSpace::createMember()</tt> and
<tt>Thyra::DefaultProductVectorSpace::createMembers()</tt>.  See
\ref Thyra_Op_Vec_product_vec_spc_prg_grp "this example"
of how product vector spaces are used.

<li> <b>Miscellaneous aggregate linear operators</b>

There are several different types of useful composite
<tt>Thyra::LinearOpBase</tt> subclasses that one can define.  A few
useful composite linear operator subclasses are shown below:

<ul>
<li><tt>Thyra::DefaultDiagonalLinearOp</tt> is a simple concrete subclass that defines a diagonal <tt>Thyra::LinearOpBase</tt>
    \f$M = \gamma \; \mbox{diag}(d) \in \Re^{n \times n}\f$
    out of any <tt>Thyra::VectorBase</tt> object for the diagonal \f$d \in \Re^n\f$.
<li><tt>Thyra::DefaultScaledAdjointLinearOp</tt> is a simple concrete decorator subclass that defines an
    implicit scaled and/or adjoined (or transposed) linear operator \f$M = \gamma \; op(A)\f$.
<li><tt>Thyra::DefaultMultipliedLinearOp</tt> is a simple concrete composite subclass that defines a composite multiplicative
    <tt>Thyra::LinearOpBase</tt> of the form \f$M = \gamma \; A_1 A_2 \ldots A_m}\f$ composed out of one or more
    constituent linear operators \f$A_1, A_2 \ldots A_m\f$.
</ul>

</ol>

<li> <b>Unit testing software</b>

This is basic testing software for %Thyra:

<ul>
<li><tt>Thyra::LinearOpTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::LinearOpBase</tt> object by checking its linear properties, and/or its adjoint,
    and/or symmetry.  In addition, it can check if two linear operators are the same.
<li><tt>Thyra::MultiVectorTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::MultiVectorBase</tt> object.  This class exposes a <tt>Thyra::LinearOpTester</tt> object
    for testing the <tt>LinearOpBase</tt> base interface of <tt>Thyra::MultiVectorBase</tt>. 
<li><tt>Thyra::VectorTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::VectorBase</tt> object.  This class exposes a <tt>Thyra::MultiVectorTester</tt> object
    for testing the <tt>MultiVectorBase</tt> base interface of <tt>Thyra::VectorBase</tt>. 
<li><tt>Thyra::VectorSpaceTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then proceeds to create a number of <tt>Thyra::VectorBase</tt> and
    <tt>Thyra::MultiVectorBase</tt> objects and then and validates all of these objects.
    This class class, therefore, is a unit testing class for all three interfaces <tt>%Thyra::VectorSpaceBase</tt>,
    <tt>%Thyra::VectorBase</tt>, and <tt>Thyra::MultiVectorBase</tt>.
<li><tt>Thyra::VectorStdOpsTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then tests all of the standard vector RTOp wrappers documented
    \ref Thyra_Op_Vec_VectorStdOps_grp "here".
<li><tt>Thyra::MultiVectorStdOpsTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then tests all of the standard multi-vector RTOp wrappers documented
    \ref Thyra_Op_Vec_MultiVectorStdOps_grp "here".
</ul>

<li> <b>Miscellaneous Tools for testing and debugging</b>

There is software included in the Thyra package to support basic
testing and debugging.

First, 100/% general output stream operators for any
<tt>Thyra::VectorBase</tt> or <tt>Thyra::LinearOpBase</tt> object are
provided in the following operator functions:

<ul>
<li><tt>Thyra::operator<<(std::ostream& o, const Thyra::VectorBase<Scalar>& v)</tt>
    is an output stream operator for printing <tt>Thyra::VectorBase</tt> objects.
<li><tt>Thyra::operator<<(std::ostream& o, const Thyra::LinearOpBase<Scalar>& M)</tt>
    is an output stream operator for printing <tt>Thyra::LinearOpBase</tt> (and therefore
also <tt>Thyra::MultiVectorBase</tt>) objects.
</ul>

\section Thyra_Op_Vec_ANA_Development_examples_sec Examples of Abstract Numerical Algorithms

There are several code examples that one can study to see how to use
the code described here as an API for developing ANAs.

<ul>

<li><tt>sillyPowerMethod()</tt> is a simple example ANA that
implements the power method for estimating the dominate eigenvalue
of a linear operator.

<li><tt>sillyCgSolve()</tt> is a simple example ANA that
implements the conjugate gradient method for solving a symmetric
positive definite linear system.

<li><tt>Thyra::LinearOpTester::check()</tt> shows how to access a
<tt>Thyra::LinearOpBase</tt> objects domain and range spaces, how to use
these spaces to create vectors and multi-vectors and how to perform
various types of operations involving vectors, multi-vectors and
linear operators.

</ul>

\section Thyra_Op_Vec_ANA_Development_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_ANA_Development_support_code_grp General ANA support code
 *
 * \ingroup Thyra_Op_Vec_ANA_Development_grp
 */

/** \defgroup Thyra_Op_Vec_ANA_Development_support_code_utils_grp General ANA support code utilities
 *
 * \ingroup Thyra_Op_Vec_ANA_Development_support_code_grp
 */

//
// Examples
//


/** \defgroup Thyra_Op_Vec_examples_grp Assorted Thyra Operator/Vector Example Code

\brief Below are links to example code that demonstrate various use cases for
%Thyra operator/vector code:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_grp

<li>\ref Thyra_Op_Vec_examples_cg_grp

<li>\ref Thyra_Op_Vec_product_vec_spc_prg_grp

</ol>

*/

//
// Silly power method example
//

/** \defgroup Thyra_Op_Vec_examples_power_method_grp Power Method Examples

\ingroup Thyra_Op_Vec_examples_grp

\brief Here we show some simple examples of using code in the %Thyra
package with an example linear ANA algorithm for the power method for
estimating the dominate eigen value of a matrix.

These example programs are meant to mimic the power method example
program shown in the <a href="../../../../../../epetra/doc/html/index.html#example">Epetra
documentation</a>.

The power method ANA is implemented in the function
<tt>sillyPowerMethod()</tt> and its implementation is shown below:

\dontinclude sillyPowerMethod.hpp

\skip template
\until end sillyPowerMethod

The above templated function <tt>%sillyPowerMethod()</tt> is used in
the following various example implementations which use several
different scalar types:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_serial_grp

</ol>

*/

/** \example sillyPowerMethod.hpp

Click \ref Thyra_Op_Vec_examples_power_method_grp "here" for a more
detailed discussion of this example function.

*/

/** \defgroup Thyra_Op_Vec_examples_power_method_serial_grp Templated Serial Implementation of the Power Method

\ingroup Thyra_Op_Vec_examples_power_method_grp

\brief Here is an example program that shows the use of the example
serial templated matrix class <tt>SerialTridiagLinearOp</tt>
with the example linear ANA implementation <tt>sillyPowerMethod()</tt>.

This example program is contained in the source file:

\verbatim ./example/Core/sillyPowerMethod_serial.cpp \endverbatim

where <tt>./</tt> is the base source directory for %Thyra
(i.e. <tt>???/Trilinos/packages/Thyra</tt>).

The class <tt>SerialTridiagLinearOp</tt> that derives from the
base class <tt>Thyra::SerialLinearOpBase</tt> is quite simple and
its complete implementation looks like:

\dontinclude SerialTridiagLinearOp.hpp
\skip template
\until end class SerialTridiagLinearOp

\dontinclude sillyPowerMethod_serial.cpp

The above serial matrix class is used in an example program (see
<tt>runPowerMethodExample()</tt> below) that calls <tt>%sillyPowerMethod()</tt>.
In this example program, the matrix constructed and used is the
well-known tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2      & -1 \\
-1     &  2      & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -1      & 2       & -1 \\
       &         &         &  -1     & 2
\end{array}\right].
\f]

The power method is then run on the matrix \f$A\f$ run for a number of
iterations (or until convergence to some tolerance).

After this, the first diagonal element \f$A_{(1,1)}=2\f$ is then
scaled to \f$A_{(1,1)}=20\f$ and the power method is run again (which
much faster convergence).

The following templated function implements the example described
above:

\skip template
\until end runPowerMethodExample

The above templated function <tt>runPowerMethodExample()</tt> is
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
<li> Real extended-precision type <b><tt>mpf_class</tt></b>
     (if <tt>--enable-teuchos-gmp</tt> was used at configuration time)
<li> Complex extended-precision type <b><tt>std::complex<mpf_class></tt></b>
     (if <tt>--enable-teuchos-complex</tt> and <tt>--enable-teuchos-gmp</tt>
     where used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/Core/sillyPowerMethod_serial.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>???/Trilinos/$BUILD_DIR/packages/Thyra</tt>).

This example program should run successfully with no arguments and, at the
time of this writing, produces the following output:

\verbatim

$ ./sillyPowerMethod_serial.exe

***
*** Running power method example using scalar type = 'float' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = 2.634806e+00, ||A*q-lambda*q|| = 9.051834e-01
Iter = 4, lambda = 3.552294e+00, ||A*q-lambda*q|| = 2.496006e-01
Iter = 8, lambda = 3.612831e+00, ||A*q-lambda*q|| = 7.194513e-02
Iter = 12, lambda = 3.617640e+00, ||A*q-lambda*q|| = 1.981858e-02
Iter = 16, lambda = 3.618005e+00, ||A*q-lambda*q|| = 5.435463e-03
Iter = 20, lambda = 3.618032e+00, ||A*q-lambda*q|| = 1.490343e-03
Iter = 24, lambda = 3.618034e+00, ||A*q-lambda*q|| = 4.085834e-04

  Estimate of dominate eigenvalue lambda = 3.618034e+00

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = 1.791493e+01, ||A*q-lambda*q|| = 5.881544e+00
Iter = 4, lambda = 2.005555e+01, ||A*q-lambda*q|| = 3.251727e-03
Iter = 8, lambda = 2.005556e+01, ||A*q-lambda*q|| = 2.788594e-06

  Estimate of dominate eigenvalue lambda = 2.005556e+01

***
*** Running power method example using scalar type = 'double' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = 2.634806e+00, ||A*q-lambda*q|| = 9.051834e-01
Iter = 4, lambda = 3.552293e+00, ||A*q-lambda*q|| = 2.496007e-01
Iter = 8, lambda = 3.612831e+00, ||A*q-lambda*q|| = 7.194514e-02
Iter = 12, lambda = 3.617641e+00, ||A*q-lambda*q|| = 1.981868e-02
Iter = 16, lambda = 3.618004e+00, ||A*q-lambda*q|| = 5.435543e-03
Iter = 20, lambda = 3.618032e+00, ||A*q-lambda*q|| = 1.490271e-03
Iter = 24, lambda = 3.618034e+00, ||A*q-lambda*q|| = 4.085797e-04

  Estimate of dominate eigenvalue lambda = 3.618034e+00

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = 1.791493e+01, ||A*q-lambda*q|| = 5.881543e+00
Iter = 4, lambda = 2.005555e+01, ||A*q-lambda*q|| = 3.251777e-03
Iter = 8, lambda = 2.005556e+01, ||A*q-lambda*q|| = 2.681092e-06

  Estimate of dominate eigenvalue lambda = 2.005556e+01

***
*** Running power method example using scalar type = 'std::complex<float>' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.885460e+00,2.235174e-08), ||A*q-lambda*q|| = 8.366854e-01
Iter = 4, lambda = (2.908303e+00,1.490116e-08), ||A*q-lambda*q|| = 4.634469e-01
Iter = 8, lambda = (3.465825e+00,-5.960464e-08), ||A*q-lambda*q|| = 3.592391e-01
Iter = 12, lambda = (3.604720e+00,-2.980232e-08), ||A*q-lambda*q|| = 1.146174e-01
Iter = 16, lambda = (3.617021e+00,-9.778887e-09), ||A*q-lambda*q|| = 3.181574e-02
Iter = 20, lambda = (3.617958e+00,9.010546e-08), ||A*q-lambda*q|| = 8.730849e-03
Iter = 24, lambda = (3.618028e+00,1.565786e-08), ||A*q-lambda*q|| = 2.393888e-03
Iter = 28, lambda = (3.618034e+00,9.727955e-09), ||A*q-lambda*q|| = 6.563177e-04

  Estimate of dominate eigenvalue lambda = (3.618034e+00,9.727955e-09)

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.316405e+01,-1.341105e-07), ||A*q-lambda*q|| = 8.828070e+00
Iter = 4, lambda = (2.005556e+01,1.859358e-07), ||A*q-lambda*q|| = 4.617708e-03
Iter = 8, lambda = (2.005555e+01,5.564779e-08), ||A*q-lambda*q|| = 4.349416e-06

  Estimate of dominate eigenvalue lambda = (2.005555e+01,5.564779e-08)

***
*** Running power method example using scalar type = 'std::complex<double>' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.885459e+00,1.387779e-17), ||A*q-lambda*q|| = 8.366853e-01
Iter = 4, lambda = (2.908303e+00,-2.775558e-17), ||A*q-lambda*q|| = 4.634469e-01
Iter = 8, lambda = (3.465825e+00,-1.040834e-16), ||A*q-lambda*q|| = 3.592392e-01
Iter = 12, lambda = (3.604720e+00,1.249001e-16), ||A*q-lambda*q|| = 1.146174e-01
Iter = 16, lambda = (3.617021e+00,-1.058181e-16), ||A*q-lambda*q|| = 3.181573e-02
Iter = 20, lambda = (3.617958e+00,6.179952e-17), ||A*q-lambda*q|| = 8.730912e-03
Iter = 24, lambda = (3.618028e+00,-4.602438e-17), ||A*q-lambda*q|| = 2.393871e-03
Iter = 28, lambda = (3.618034e+00,-8.632960e-18), ||A*q-lambda*q|| = 6.563170e-04

  Estimate of dominate eigenvalue lambda = (3.618034e+00,-8.632960e-18)

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = (1.316405e+01,-5.551115e-16), ||A*q-lambda*q|| = 8.828069e+00
Iter = 4, lambda = (2.005555e+01,-3.814166e-16), ||A*q-lambda*q|| = 4.617726e-03
Iter = 8, lambda = (2.005556e+01,-1.371085e-17), ||A*q-lambda*q|| = 3.719354e-06

  Estimate of dominate eigenvalue lambda = (2.005556e+01,-1.371085e-17)

***
*** Running power method example using scalar type = 'mpf_class' ...
***

(1) Constructing tridiagonal matrix A of dimension = 4 ...

(2) Running the power method on matrix A ...

Starting power method ...

Iter = 0, lambda = 9.402176e-01, ||A*q-lambda*q|| = 1.103226e+00
Iter = 4, lambda = 3.577075e+00, ||A*q-lambda*q|| = 1.999005e-01
Iter = 8, lambda = 3.614877e+00, ||A*q-lambda*q|| = 5.609685e-02
Iter = 12, lambda = 3.617796e+00, ||A*q-lambda*q|| = 1.542336e-02
Iter = 16, lambda = 3.618016e+00, ||A*q-lambda*q|| = 4.229461e-03
Iter = 20, lambda = 3.618033e+00, ||A*q-lambda*q|| = 1.159585e-03
Iter = 24, lambda = 3.618034e+00, ||A*q-lambda*q|| = 3.179170e-04

  Estimate of dominate eigenvalue lambda = 3.618034e+00

(3) Increasing first diagonal entry by factor of 10 ...

(4) Running the power method again on matrix A ...

Starting power method ...

Iter = 0, lambda = 1.102725e+01, ||A*q-lambda*q|| = 9.675451e+00
Iter = 4, lambda = 2.005556e+01, ||A*q-lambda*q|| = 1.920248e-03
Iter = 8, lambda = 2.005556e+01, ||A*q-lambda*q|| = 1.572132e-06

  Estimate of dominate eigenvalue lambda = 2.005556e+01

Congratulations! All of the tests checked out!

\endverbatim

This example program also takes a number of command-line options.  To
see what the command-line options are, use the <tt>--help</tt> option.
At the time of this writing, the command-line options returned from
<tt>./sillyPowerMethod_serial.exe --help</tt> are:

\verbatim
$ ./sillyPowerMethod_serial.exe --help
Usage: ./sillyPowerMethod_serial [options]
  options:
  --help                         Prints this help message
  --pause-for-debugging          Pauses for user input to allow attaching a debugger
  --verbose              bool    Determines if any output is printed or not.
  --quiet                        (default: --verbose)
  --dim                  int     Dimension of the linear system.
                                 (default: --dim=4)
  --dump-all             bool    Determines if quantities are dumped or not.
  --no-dump                      (default: --no-dump)
\endverbatim

To see the full listing of this example program click: <a
href="sillyPowerMethod__serial_8cpp-example.html">
sillyPowerMethod_serial.cpp </a>

*/

/** \example SerialTridiagLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_power_method_serial_grp "here" and
\ref Thyra_Op_Vec_examples_cg_serial_grp "here" for example programs that
use this example class.

*/

/** \example MPITridiagLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_power_method_MPI_grp "here" and
\ref Thyra_Op_Vec_examples_cg_MPI_grp "here" for example programs that
use this example class.

*/

/** \example sillyPowerMethod_serial.cpp

Click \ref Thyra_Op_Vec_examples_power_method_serial_grp "here" for a more
detailed discussion of this example program.

*/

//
// Silly CG example
//

/** \defgroup Thyra_Op_Vec_examples_cg_grp CG Examples

\ingroup Thyra_Op_Vec_examples_grp

\brief Here we show some simple examples of using code in the %Thyra
package with an example ANA algorithm for the iterative solution of
symmetric positive-definite linear systems using the conjugate
gradient (CG) method.

The CG ANA is implemented in the function <tt>sillyCgSolve()</tt> and
its implementation is shown below:

\dontinclude sillyCgSolve.hpp

\skip template
\until end sillyCgSolve

This above templated function is used in the following various example
implementations which use several different scalar types:

<ol>

<li>\ref Thyra_Op_Vec_examples_cg_serial_grp

<li>\ref Thyra_Op_Vec_examples_cg_MPI_grp

</ol>

*/

/** \example sillyCgSolve.hpp

Click \ref Thyra_Op_Vec_examples_cg_grp "here" for a more
detailed discussion of this example function.

*/

/** \defgroup Thyra_Op_Vec_examples_cg_serial_grp Templated Serial Implementation of the CG Method

\ingroup Thyra_Op_Vec_examples_cg_grp

\brief Here is an example program that shows the use of the example
serial templated matrix class <tt>SerialTridiagLinearOp</tt>
with the example linear ANA implementation <tt>sillyCgSolve()</tt>.

The class <tt>SerialTridiagLinearOp</tt> that derives from the
base class <tt>Thyra::SerialLinearOpBase</tt> is quite simple and
its complete implementation looks like:

\dontinclude SerialTridiagLinearOp.hpp
\skip template
\until end class SerialTridiagLinearOp

\dontinclude sillyCgSolve_serial.cpp

The above serial matrix class is used in an example program (see
<tt>runCgSolveExample()</tt> below) that calls <tt>%sillyCgSolve()</tt>.
In this example program, the matrix constructed and used is the following
tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2 a    & -1 \\
-r(1)  &  2 a    & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -r(n-2) & 2 a       & -1 \\
       &         &         &  -r(n-1)  & 2 a
\end{array}\right]
\f]

where \f$a\f$ is an adjustable diagonal scale factories that makes the matrix
\f$A\f$ more or less well conditioned and \f$r(i)\f$ is either \f$-1\f$ for a
symmetric operator or \f$rand()\f$ for an unsymmetric operator.

If a symmetric operator is used, then CG is run using \f$A\f$ directly.  If
\f$A\f$ is unsymmetric, then the normal equations

\f[

  A^H A x = A^H b

\f]

are solved and the operator used is

\f[
A \Rightarrow A^H A
\f]

The CG method is then run on the matrix \f$A\f$ or \f$A^H A\f$ for a number of
iterations or until convergence to some tolerance is achieved.

The following templated function <tt>runCgSolveExample()</tt>
implements the example described above:

\skip template
\until end runCgSolveExample

The above templated function <tt>runCgSolveExample()</tt> is then
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
<li> Real extended-precision type <b><tt>mpf_class</tt></b>
     (if <tt>--enable-teuchos-gmp</tt> was used at configuration time)
<li> Complex extended-precision type <b><tt>std::complex<mpf_class></tt></b>
     (if <tt>--enable-teuchos-complex</tt> and <tt>--enable-teuchos-gmp</tt>
     where used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/Core/sillyCgSolve_serial.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>???/Trilinos/$BUILD_DIR/packages/Thyra</tt>).

This example program should run successfully with no arguments and, at the time
of this writing, produces the following output:

\verbatim

$ ./sillyCgSolve_serial.exe

***
*** Running silly CG solver using scalar type = 'float' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.03937e-05
         <= linear_properties_error_tol() = 0.0001 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.03937e-05
         >= linear_properties_warning_tol() = 1e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-15.3963,-15.3963) = 3.09709e-07
         <= adjoint_error_tol() = 0.0001 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<float>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(0.216513,0.216513) = 2.13352e-06
         <= linear_properties_error_tol() = 0.0001 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err(0.216513,0.216513) = 2.13352e-06
         >= linear_properties_warning_tol() = 1e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-10.5495,-10.5495) = 1.808e-07
         <= adjoint_error_tol() = 0.0001 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(18.106,18.106) = 3.1603e-07
         <= symmetry_error_tol() = 0.0001 : passed

*** Leaving LinearOpTester<float>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<float>', size = 500

describe x:
  type = 'DefaultSerialVector<float>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812529e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.589733e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.381910e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.546838e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.840684e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.891940e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.613070e-05

||b-A*x||/||b|| = 1.344797e-03/1.299397e+01 = 1.034939e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 3.680000e-01 sec

***
*** Running silly CG solver using scalar type = 'double' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.394610e-01,2.394610e-01) = 1.101131e-14
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-5.913676e+00,-5.913676e+00) = 9.011435e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<double>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.165119e-01,2.165119e-01) = 4.743187e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-1.054952e+01,-1.054952e+01) = 5.051482e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(1.810601e+01,1.810601e+01) = 1.962174e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<double>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<double>', size = 500

describe x:
  type = 'DefaultSerialVector<double>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812612e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.590140e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.382036e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.547269e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.842233e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.892296e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.615059e-05

||b-A*x||/||b|| = 1.249378e-03/1.299397e+01 = 9.615059e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 2.020000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<float>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-3.456044e-01,-4.895731e-01),(-3.456052e-01,-4.895744e-01)) = 2.541641e-06
         <= linear_properties_error_tol() = 1.000000e-04 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err((-3.456044e-01,-4.895731e-01),(-3.456052e-01,-4.895744e-01)) = 2.541641e-06
         >= linear_properties_warning_tol() = 1.000000e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.643561e+01,6.788700e+00),(1.643562e+01,6.788701e+00)) = 2.211224e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-9.677564e-01,6.222531e-01),(-9.677570e-01,6.222509e-01)) = 1.950122e-06
         <= linear_properties_error_tol() = 1.000000e-04 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err((-9.677564e-01,6.222531e-01),(-9.677570e-01,6.222509e-01)) = 1.950122e-06
         >= linear_properties_warning_tol() = 1.000000e-06!

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.402400e+01,4.335190e+00),(1.402399e+01,4.335191e+00)) = 3.911690e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.046669e+01,2.444866e+00),(1.046669e+01,2.444870e+00)) = 5.173613e-07
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721108e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355135e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733771e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754171e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.684857e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.239717e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.721012e-05

||b-A*x||/||b|| = 1.887406e-03/1.800947e+01 = 1.048008e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 3.410000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<double>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-4.443735e-01,-2.545424e-01),(-4.443735e-01,-2.545424e-01)) = 7.714438e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((6.554045e+00,7.729893e+00),(6.554045e+00,7.729893e+00)) = 8.314229e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-9.677554e-01,6.222520e-01),(-9.677554e-01,6.222520e-01)) = 2.869021e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.402400e+01,4.335187e+00),(1.402400e+01,4.335187e+00)) = 3.375439e-15
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.046669e+01,2.444870e+00),(1.046669e+01,2.444870e+00)) = 1.652665e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721187e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355587e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733925e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754771e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.686419e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.240143e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.723106e-05

||b-A*x||/||b|| = 1.751081e-03/1.800948e+01 = 9.723106e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 3.120000e-01 sec

***
*** Running silly CG solver using scalar type = 'mpf_class' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(9.554737e-01,9.554737e-01) = 3.054291e-19
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-6.665022e-01,-6.665022e-01) = 3.655873e-19
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<mpf_class>::check(...)

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(1.811994e+00,1.811994e+00) = 2.692563e-19
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-2.469042e+00,-2.469042e+00) = 3.952367e-20
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(7.214884e-01,7.214884e-01) = 8.887522e-20
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<mpf_class>::check(...)

Starting CG solver ...

describe A:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<mpf_class>', size = 500

describe x:
  type = 'DefaultSerialVector<mpf_class>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 7.662633e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 1.869085e-01
Iter = 93, ||b-A*x||/||b-A*x0|| = 4.641508e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 1.001201e-02
Iter = 155, ||b-A*x||/||b-A*x0|| = 2.792430e-03
Iter = 186, ||b-A*x||/||b-A*x0|| = 5.392830e-04
Iter = 217, ||b-A*x||/||b-A*x0|| = 1.093640e-04
Iter = 219, ||b-A*x||/||b-A*x0|| = 9.685596e-05

||b-A*x||/||b|| = 1.255016e-03/1.295755e+01 = 9.685596e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 3.037000e+00 sec

Congratulations! All of the tests checked out!

\endverbatim

This example program also takes a number of command-line options.  To
see what the command-line options are, use the <tt>--help</tt> option.
At the time of this writing, the command-line options returned from
<tt>./sillyCgSolve_serial.exe --help</tt> are:

\verbatim

$ ./sillyCgSolve_serial.exe --help
Usage: ./sillyCgSolve_serial [options]
  options:
  --help                         Prints this help message
  --pause-for-debugging          Pauses for user input to allow attaching a debugger
  --verbose              bool    Determines if any output is printed or not.
  --quiet                        (default: --verbose)
  --dim                  int     Dimension of the linear system.
                                 (default: --dim=500)
  --diag-scale           double  Scaling of the diagonal to improve conditioning.
                                 (default: --diag-scale=1.001)
  --sym-op               bool    Determines if the operator is symmetric or not.
  --unsym-op                     (default: --sym-op)
  --tol                  double  Relative tolerance for linear system solve.
                                 (default: --tol=0.0001)
  --max-num-iters        int     Maximum of CG iterations.
                                 (default: --max-num-iters=300)
\endverbatim

When the option <tt>--unsym-op</tt> is selected, the normal equations are
solved which is shown in the following example:

\verbatim

$ ./sillyCgSolve_serial.exe --unsym-op --max-num-iters=20

***
*** Running silly CG solver using scalar type = 'float' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(19.2992,19.2992) = 3.95322e-07
         <= linear_properties_error_tol() = 0.0001 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-1.72592,-1.72592) = 9.66979e-07
         <= adjoint_error_tol() = 0.0001 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<float>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<float>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<float>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<float>', rangeDim = 500, domainDim = 500
          overallScalar=1
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(35.3825,35.3825) = 2.15626e-07
         <= linear_properties_error_tol() = 0.0001 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-36.7441,-36.744) = 2.07636e-07
         <= adjoint_error_tol() = 0.0001 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(37.9726,37.9726) = 0
         <= symmetry_error_tol() = 0.0001 : passed

*** Leaving LinearOpTester<float>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<float>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<float>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<float>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<float>', size = 500

describe x:
  type = 'DefaultSerialVector<float>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 6.660668e-03
Iter = 6, ||b-A*x||/||b-A*x0|| = 3.351218e-05

||b-A*x||/||b|| = 1.069767e-03/3.191998e+01 = 3.351403e-05 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 1.090000e-01 sec

***
*** Running silly CG solver using scalar type = 'double' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(-1.680574e+00,-1.680574e+00) = 1.321243e-16
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-6.383695e-01,-6.383695e-01) = 2.260901e-15
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<double>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<double>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<double>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<double>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(6.938410e+00,6.938410e+00) = 1.024071e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-2.814797e+01,-2.814797e+01) = 2.524312e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(4.438044e+01,4.438044e+01) = 1.601027e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<double>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<double>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<double>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<double>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<double>', size = 500

describe x:
  type = 'DefaultSerialVector<double>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 1.233805e-01
Iter = 6, ||b-A*x||/||b-A*x0|| = 2.217761e-02
Iter = 9, ||b-A*x||/||b-A*x0|| = 4.338932e-03
Iter = 12, ||b-A*x||/||b-A*x0|| = 7.668738e-04
Iter = 15, ||b-A*x||/||b-A*x0|| = 1.317471e-04
Iter = 16, ||b-A*x||/||b-A*x0|| = 7.581160e-05

||b-A*x||/||b|| = 2.307234e-03/3.043379e+01 = 7.581160e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 6.700000e-02 sec

***
*** Running silly CG solver using scalar type = 'std::complex<float>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((2.723428e-01,2.028702e+00),(2.723447e-01,2.028702e+00)) = 9.390742e-07
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.121651e+01,3.660773e+00),(1.121650e+01,3.660776e+00)) = 2.914302e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<float>>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-1.574269e+01,1.134796e+01),(-1.574271e+01,1.134796e+01)) = 8.368621e-07
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((5.278718e+01,4.448534e+00),(5.278718e+01,4.448544e+00)) = 1.938938e-07
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((2.419142e+01,1.037749e+01),(2.419140e+01,1.037749e+01)) = 6.680345e-07
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<float>>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<float>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<float>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 1.431026e-01
Iter = 6, ||b-A*x||/||b-A*x0|| = 2.387369e-02
Iter = 9, ||b-A*x||/||b-A*x0|| = 3.633558e-03
Iter = 12, ||b-A*x||/||b-A*x0|| = 5.538159e-04
Iter = 15, ||b-A*x||/||b-A*x0|| = 8.121288e-05

||b-A*x||/||b|| = 3.305705e-03/4.070510e+01 = 8.121108e-05 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 6.700000e-02 sec

***
*** Running silly CG solver using scalar type = 'std::complex<double>' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-1.970843e+00,-3.441251e+01),(-1.970843e+00,-3.441251e+01)) = 6.291975e-16
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.372625e+00,1.850210e+01),(1.372625e+00,1.850210e+01)) = 8.360598e-16
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<std::complex<double>>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-5.472665e+01,3.895074e+01),(-5.472665e+01,3.895074e+01)) = 9.520071e-16
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((-1.017174e+01,1.130154e+01),(-1.017174e+01,1.130154e+01)) = 1.263687e-15
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((2.205033e+01,-4.284830e+01),(2.205033e+01,-4.284830e+01)) = 1.823840e-15
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<std::complex<double>>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
          overallScalar=(1.000000e+00,0.000000e+00)
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<std::complex<double>>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

describe x:
  type = 'DefaultSerialVector<std::complex<double>>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 2.153769e-02
Iter = 6, ||b-A*x||/||b-A*x0|| = 3.394906e-04
Iter = 7, ||b-A*x||/||b-A*x0|| = 9.023713e-05

||b-A*x||/||b|| = 4.053765e-03/4.492347e+01 = 9.023713e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 5.900000e-02 sec

***
*** Running silly CG solver using scalar type = 'mpf_class' ...
***

Constructing tridiagonal matrix A of dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Testing the constructed linear operator A ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.352466e+02,2.352466e+02) = 1.221329e-20
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(6.045283e+01,6.045283e+01) = 1.019303e-20
         <= adjoint_error_tol() = 1.000000e-04 : passed

Skipping check for symmetry since this->check_for_symmetry()==false

*** Leaving LinearOpTester<mpf_class>::check(...)

Setting up normal equations for unsymmetric system A^H*(A*x-b) => new A*x = b ...

Testing the linear operator used with the solve ...

*** Entering LinearOpTester<mpf_class>::check(op,...) ...

describe op:
  type = 'DefaultMultipliedLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500


Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.173757e+02,2.173757e+02) = 1.945199e-20
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Checking that the adjoint agrees with the non-adjoint operator as:

  <0.5*op'*v2,v1> == <v2,0.5*op*v1>
   \________/            \_______/
       v4                   v3

         <v4,v1>  == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op'*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(4.949277e+01,4.949277e+01) = 1.752502e-20
         <= adjoint_error_tol() = 1.000000e-04 : passed

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(5.540864e+01,5.540864e+01) = 2.152412e-20
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<mpf_class>::check(...)

Starting CG solver ...

describe A:
  type = 'DefaultMultipliedLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
    numOps=2
    Constituent LinearOpBase objects for M = Op[0]*...*Op[numOps-1]:
      Op[0] =
        type = 'DefaultScaledAdjointLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
          overallScalar=1.000000e+00
          overallTransp=CONJTRANS
          Constituent transformations:
            transp=CONJTRANS
              origOp =
                type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500
      Op[1] =
        type = 'SerialTridiagLinearOp<mpf_class>', rangeDim = 500, domainDim = 500

describe b:
  type = 'DefaultSerialVector<mpf_class>', size = 500

describe x:
  type = 'DefaultSerialVector<mpf_class>', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 3, ||b-A*x||/||b-A*x0|| = 2.692000e-01
Iter = 6, ||b-A*x||/||b-A*x0|| = 2.507806e-02
Iter = 9, ||b-A*x||/||b-A*x0|| = 3.479960e-03
Iter = 12, ||b-A*x||/||b-A*x0|| = 5.338185e-04
Iter = 15, ||b-A*x||/||b-A*x0|| = 7.988701e-05

||b-A*x||/||b|| = 1.412440e-03/1.768048e+01 = 7.988701e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 5.060000e-01 sec

Congratulations! All of the tests checked out!

\endverbatim

Note in the above example how the normal operator \f$A^H A\f$ is described.
This aggregate operator is created by the function calls
<tt>Thyra::scale()</tt> and <tt>Thyra::multiply()</tt> which create implicit
<tt>Thyra::ScaledAdjointedLinearOp</tt> and
<tt>Thyra::DefaultMultipliedLinearOp</tt> objects.

To see the full listing of this example program click: <a
href="sillyCgSolve__serial_8cpp-example.html">
sillyCgSolve_serial.cpp </a>

*/

/** \example sillyCgSolve_serial.cpp

Click \ref Thyra_Op_Vec_examples_cg_serial_grp "here" for a more
detailed discussion of this example program.

*/

/** \defgroup Thyra_Op_Vec_examples_cg_MPI_grp Templated MPI Implementation of the CG Method

\ingroup Thyra_Op_Vec_examples_cg_grp

\brief Here is an example program that shows the use of the example
MPI templated matrix class <tt>MPITridiagLinearOp</tt> with the
example linear ANA implementation <tt>sillyCgSolve()</tt>.

The class <tt>MPITridiagLinearOp</tt> that derives from the base class
<tt>Thyra::MPILinearOpBase</tt> is quite simple and its
implementation (minus the <tt>communication()</tt> function) looks
like:

\dontinclude MPITridiagLinearOp.hpp
\skip template
\until end class MPITridiagLinearOp

\dontinclude sillyCgSolve_mpi.cpp

The above MPI matrix class is used in an example program (see
<tt>runCgSolveExample()</tt> below) that calls
<tt>%sillyCgSolve()</tt>.  In this example program, the matrix
constructed and used is the well-known tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2 a    & -1 \\
-1     &  2 a    & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -1      & 2 a     & -1 \\
       &         &         &  -1     & 2 a
\end{array}\right]
\f]

where \f$a\f$ is an adjustable diagonal scale factor that makes the
matrix \f$A\f$ more or less well conditioned.

The CG method is then run on the matrix \f$A\f$ for a number of
iterations or until convergence to some tolerance is achieved.

The following templated function <tt>runCgSolveExample()</tt>
implements the example described above:

\skip template
\until end runCgSolveExample

The above templated function <tt>runCgSolveExample()</tt> is then
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/Core/sillyCgSolve_mpi.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>???/Trilinos/$BUILD_DIR/packages/Thyra</tt>).

This example program should run successfully with no arguments for any number
of processors and, at the time of this writing, for one processor produces the
following output:

\verbatim

$ ./sillyCgSolve_mpi.exe

***
*** Running silly CG solver using scalar type = 'float' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = 1.001 ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpIfE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.0936e-05
         <= linear_properties_error_tol() = 0.0001 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err(-0.0412178,-0.0412174) = 1.0936e-05
         >= linear_properties_warning_tol() = 1e-06!

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-15.3963,-15.3963) = 3.09709e-07
         <= symmetry_error_tol() = 0.0001 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpIfE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdIfEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdIfEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812529e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.589733e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.381910e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.546838e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.840684e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.891940e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.613070e-05

||b-A*x||/||b|| = 1.344796e-03/1.299397e+01 = 1.034939e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 5.490000e-01 sec

***
*** Running silly CG solver using scalar type = 'double' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = 1.001000e+00 ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpIdE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err(2.165119e-01,2.165119e-01) = 4.871381e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err(-1.054952e+01,-1.054952e+01) = 5.051482e-16
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpIdE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdIdEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdIdEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.812612e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 6.590140e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.382036e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 3.547269e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.842233e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 1.892296e-04
Iter = 204, ||b-A*x||/||b-A*x0|| = 9.615059e-05

||b-A*x||/||b|| = 1.249378e-03/1.299397e+01 = 9.615059e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 2.120000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<float>' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpISt7complexIfEE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((5.142615e-01,1.741409e-01),(5.142629e-01,1.741405e-01)) = 2.639293e-06
         <= linear_properties_error_tol() = 1.000000e-04 : passed
Warning! rel_err(sum(v4),sum(v5))
       = rel_err((5.142615e-01,1.741409e-01),(5.142629e-01,1.741405e-01)) = 2.639293e-06
         >= linear_properties_warning_tol() = 1.000000e-06!

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.242970e+01,1.590466e+01),(1.242970e+01,1.590467e+01)) = 3.809048e-07
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpISt7complexIfEE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdISt7complexIfEEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdISt7complexIfEEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721108e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355135e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733771e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754171e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.684857e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.239717e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.721012e-05

||b-A*x||/||b|| = 1.887406e-03/1.800947e+01 = 1.048008e-04 <= 10.0*tolerance = 9.999999e-04: passed

Total time = 3.020000e-01 sec

***
*** Running silly CG solver using scalar type = 'std::complex<double>' ...
***

Constructing tridiagonal matrix A of local dimension = 500 and diagonal multiplier = (1.001000e+00,0.000000e+00) ...

Global dimension of A = 500

Testing the constructed linear operator A ...

*** Entering LinearOpTester<Scalar>::check(op,...) ...

op = 18MPITridiagLinearOpISt7complexIdEE

Checking the domain and range spaces ...
op.domain().get() != NULL ? passed
op.range().get() != NULL ? passed

Checking that the operator truly is linear:

  0.5*op*(v1 + v2) == 0.5*op*v1 + 0.5*op*v2
          \_____/         \___/
             v3            v5
  \_____________/     \___________________/
         v4                    v5

           sum(v4) == sum(v5)

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = v1 + v2 ...

v4 = 0.5*op*v3 ...

v5 = op*v1 ...

v5 = 0.5*op*v2 + 0.5*v5 ...

Check: rel_err(sum(v4),sum(v5))
       = rel_err((-9.677554e-01,6.222520e-01),(-9.677554e-01,6.222520e-01)) = 2.869021e-15
         <= linear_properties_error_tol() = 1.000000e-04 : passed

Skipping adjoint check since op.opSupported(CONJTRANS)==false

Performing check of symmetry since check_for_symmetry()==true ...

op.domain()->isCompatible(*op.range()) == true : passed

Checking that the operator is symmetric as:

  <0.5*op*v2,v1> == <v2,0.5*op*v1>
   \_______/            \_______/
      v4                    v3

         <v4,v1> == <v2,v3>

Random vector tests = 1

v1 = randomize(-1,+1); ...

v2 = randomize(-1,+1); ...

v3 = 0.5*op*v1 ...

v4 = 0.5*op*v2 ...

Check: rel_err(<v4,v1>,<v2,v3>)
       = rel_err((1.402400e+01,4.335187e+00),(1.402400e+01,4.335187e+00)) = 3.375439e-15
         <= symmetry_error_tol() = 1.000000e-04 : passed

*** Leaving LinearOpTester<Scalar>::check(...)

Starting CG solver ...

describe A:
  type = '18MPITridiagLinearOpISt7complexIdEE', rangeDim = 500, domainDim = 500

describe b:
  type = 'N5Thyra12MPIVectorStdISt7complexIdEEE', size = 500

describe x:
  type = 'N5Thyra12MPIVectorStdISt7complexIdEEE', size = 500

Iter = 0, ||b-A*x||/||b-A*x0|| = 1.000000e+00
Iter = 31, ||b-A*x||/||b-A*x0|| = 2.721187e-01
Iter = 62, ||b-A*x||/||b-A*x0|| = 7.355587e-02
Iter = 93, ||b-A*x||/||b-A*x0|| = 1.733925e-02
Iter = 124, ||b-A*x||/||b-A*x0|| = 4.754771e-03
Iter = 155, ||b-A*x||/||b-A*x0|| = 9.686419e-04
Iter = 186, ||b-A*x||/||b-A*x0|| = 2.240143e-04
Iter = 208, ||b-A*x||/||b-A*x0|| = 9.723106e-05

||b-A*x||/||b|| = 1.751081e-03/1.800948e+01 = 9.723106e-05 <= 10.0*tolerance = 1.000000e-03: passed

Total time = 3.110000e-01 sec

Congratulations! All of the tests checked out!

\endverbatim

This example program also takes a number of command-line options.  To
see what the command-line options are, use the <tt>--help</tt> option.
At the time of this writing, the command-line options returned from
<tt>./sillyCgSolve_mpi.exe --help</tt> are:

\verbatim

$ ./sillyCgSolve_mpi.exe --help
Usage: ./sillyCgSolve_mpi [options]
  options:
  --help                         Prints this help message
  --pause-for-debugging          Pauses for user input to allow attaching a debugger
  --verbose              bool    Determines if any output is printed or not.
  --quiet                        (default: --verbose)
  --local-dim            int     Local dimension of the linear system.
                                 (default: --local-dim=500)
  --diag-scale           double  Scaling of the diagonal to improve conditioning.
                                 (default: --diag-scale=1.001)
  --tol                  double  Relative tolerance for linear system solve.
                                 (default: --tol=0.0001)
  --max-num-iters        int     Maximum of CG iterations.
                                 (default: --max-num-iters=300)
\endverbatim

To see the full listing of this example program click: <a
href="sillyCgSolve__mpi_8cpp-example.html">
sillyCgSolve_mpi.cpp </a>

*/

/** \example sillyCgSolve_mpi.cpp

Click \ref Thyra_Op_Vec_examples_cg_MPI_grp "here" for a more
detailed discussion of this example program.

*/

//
// FFT examples
//

/** \example ComplexFFTLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_fft_grp "here" for an example program that
use this example class.

*/

/** \example RealComplexFFTLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_fft_grp "here" for an example program that
use this example class.

*/

/** \defgroup Thyra_Op_Vec_examples_fft_grp Templated FFT examples

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this example program click: <a
href="silly1DFFT__serial_8cpp-example.html">
silly1DFFT_serial.cpp </a>

*/

/** \example silly1DFFT_serial.cpp

*/

//
// Misc examples
//

/** \defgroup Thyra_Op_Vec_product_vec_spc_prg_grp Testing Program for Composite Product VectorBase Spaces and Product Vectors

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__product__space_8cpp-example.html">
test_product_space.cpp </a>.

*/

/** \example test_product_space.cpp

Click \ref Thyra_Op_Vec_product_vec_spc_prg_grp "here" for a more
detailed discussion of this example/test program.

*/

/** \defgroup Thyra_Op_Vec_test_composite_linear_ops_grp Testing Program for Composite Linear Operators

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__composite__linear__ops_8cpp-example.html">
test_composite_linear_ops.cpp </a>.

*/

/** \example test_composite_linear_ops.cpp

*/

/** \defgroup Thyra_Op_Vec_test_std_ops_grp Testing Program for Standard Vector and Multi-Vector Reduction/Transformation Operators

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__std__ops_8cpp-example.html">
test_std_ops.cpp </a>.

*/

/** \example test_std_ops.cpp

*/
