
/** \defgroup Thyra_Op_Vec_use_cases_grp Use Cases for the Fundamental Thyra Operator/Vector Interfaces

\brief Here we outline three common use cases related to the \ref
Thyra_Op_Vec_fundamental_interfaces_sec.

Click on the links below for a discussion of each of these three use
cases and a description of additional supporting C++ classes and
non-member functions.

<ol>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

</ol>

*/

/** \defgroup Thyra_Op_Vec_ANA_Interoperability_grp Interoperability Interfaces for linear Abstract Numerical Algorithms (ANAs)

\ingroup Thyra_Op_Vec_use_cases_grp

\brief As stated in the \ref index "introduction", the primary purpose
of %Thyra is to define a set of basic and minimal abstract
interfaces to support the interoperability of abstract numerical
algorithms (ANAs).

ToDo: Put in links to fundamental and extended operator-vector interfaces.

\section Thyra_Op_Vec_ANA_Interoperability_other_sec Other Use Cases

<ul>
<li> \ref Thyra_Op_Vec_Adapters_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_ANA_Development_grp Development of linear Abstract Numerical Algorithms (ANAs)

\ingroup Thyra_Op_Vec_use_cases_grp

\brief While the \ref Thyra_Op_Vec_fundamental_interfaces_sec were not
principally designed to provide a direct API for the development of
ANA software, with some minimal helper functions and classes, directly
writing even sophisticated ANA implementations directly in terms of
%Thyra objects is quite straightforward.

It turns out that using %Thyra for the development of simple ANAs,
as described below, really does not require any deep understanding of
the \ref Thyra_Op_Vec_fundamental_interfaces_sec "foundational Thyra operator/vector interfaces.

\section Thyra_Op_Vec_ANA_Development_overview_sec Overview of Using Thyra Software for Development of ANA Software

There are several different types of helper classes and functions that
simplify the use of %Thyra for the development of ANAs.

<ol>

<li> <b>Java-like handle classes supporting efficient operator-overloading for linear algebra operations</b>

The following Java-like handle classes wrap Thyra base objects and define the
basic linear algebra operations:

<ul>

<li><tt>Thyra::VectorSpace</tt> wraps <tt>Thyra::VectorSpaceBase</tt> objects.

<li><tt>Thyra::Vector</tt> wraps <tt>Thyra::VectorBase</tt> objects and allows
developers to write linear algebra experessions like <tt>y = alpha*x + z</tt>.
The class <tt>Thyra::ConstVector</tt> is a base class of
<tt>%Thyra::%Vector</tt> that allows for the compile checking of
<tt>const</tt> protection.

<li><tt>Thyra::LinearOperator</tt> wraps <tt>Thyra::LinearOpBase</tt> objects
and allows developers to write linear algebra experessions like <tt>D =
alpha*A + adjoint(B) * C</tt>.  Unlike vectors, however, explicit objects are
not formed in these types of operations and instead the implicit operators
defined <a href="thyra_impicit_linear_operators_tag">below</a>.  The class
<tt>Thyra::ConstLinearOperator</tt> is a base class of
<tt>%Thyra::%LinearOperator</tt> that allows for the compile checking of
<tt>const</tt> protection.

</ul>

Hande clases have the same basic semantics as <tt>Thyra::RCP</tt> for
copy construction and assignment and infact they all use
<tt>Thyra::RCP</tt> internally to point to the underlying Thyra base
objects.  For an example of their use, see the function
<tt>sillierCgSolve()</tt> which calls <tt>silliestCgSolve()</tt>.

<li> <b>"Standard" non-member wrapper functions for vector (and multi-vector) reduction/transformation operations</b>

While the use of the <tt>RTOpPack::RTOpT</tt> interface class and the
single <tt>Thyra::VectorBase::applyOp()</tt> function provide an elegant
and efficient solution for the interoperability of vector
interfaces, it is not the easiest API for developing ANAs.  However,
a number of easy to use C++ wrapper functions for many different
 vector and multi-vector operations is already provided:

<ul>
<li> \ref Thyra_Op_Vec_VectorStdOps_grp
<li> \ref Thyra_Op_Vec_MultiVectorStdOps_grp
</ul>

These C++ wrapper functions rely on pre-implemented
<tt>RTOpPack::RTOpT</tt> subclasses.  Adding new
<tt>RTOpPack::RTOpT</tt> subclasses and new wrapper functions for new
vector and multi-vector reduction/transformation operations is an easy
matter for an experienced C++ developer who understands
<tt>RTOpPack::RTOpT</tt> (please contact rabartl@sandia.gov if you
need a new vector or multi-vector operation that is not already
supported).

<li> <b>Implicit vector space, vector, multi-vector and linear operator subclasses</b>

One of the big advantages of having a set of abstract interfaces to operators
and vectors is that it is quite easy to define some very useful aggregate
subclasses that allow one or more individual objects be treated as a single
object (see the "Composite" and "Decorator" design patterns in the GoF's
"Design Patterns" book).

<ol>

<li> <b>Implicit product vector spaces, vectors and multi-vectors</b>

One particularly useful category of composite linear algebra objects
is the product vector space \f$\mathcal{X} = \mathcal{V}_0 {}\times
\mathcal{V}_1 {}\times {}\ldots {}\times \mathcal{V}_{m-1}\f$ where
\f$\mathcal{V}_k\f$, for \f$k = 0 {}\ldots {m-1}\f$, are different constituent
vector spaces.  Product vector spaces give rise to product vectors

\f[
x = \left[\begin{array}{c} v_0 \\ v_1 \\ \vdots \\ v_{m-1} \end{array}\right]
\f]

(where \f$v_0 \in \mathcal{V}_0, v_1 \in \mathcal{V}_1, \ldots, v_{m-1}
\in \mathcal{V}_{m-1}\f$) and product multi-vectors

\f[
X = \left[\begin{array}{c} V_0 \\ V_1 \\ \vdots \\ V_{m-1} \end{array}\right].
\f]

(where \f$V_0 \in \mathcal{V}_0 | \mathcal{D}, V_1 \in \mathcal{V}_1 | \mathcal{D},
\ldots, V_{m-1} \in \mathcal{V}_{m-1} | \mathcal{D}\f$ and \f$\mathcal{D}\f$ is the
domain space for the multi-vectors).

Very general concrete implementations of the product vector space, vector and
multi-vector interfaces described \ref
Thyra_Op_Vec_Interoperability_Extended_Interfaces_sec "here" are provided and
are shown below:

<ul>
<li><tt>Thyra::DefaultProductVectorSpace</tt> is a general concrete implementation of <tt>Thyra::ProductVectorSpaceBase</tt>
    that should be sufficient for most use cases.
<li><tt>Thyra::DefaultProductVector</tt> is a general concrete implementation of <tt>Thyra::ProductVectorBase</tt>
    that should be sufficient for most use cases.
<li><tt>Thyra::DefaultProductMultiVector</tt> is a general concrete implementation of <tt>Thyra::ProductMultiVectorBase</tt>
    that should be sufficient for most use cases.
</ul>

Note that the above concrete subclasses are very efficient for must,
but not all, possible use cases for such composite objects.

When using product vector spaces, product vectors and product
multi-vectors it is generally the case where a concrete
<tt>Thyra::DefaultProductVectorSpace</tt> object is first created and then
<tt>Thyra::DefaultProductVector</tt> and
<tt>Thyra::DefaultProductMultiVector</tt> objects are created by the
functions <tt>Thyra::DefaultProductVectorSpace::createMember()</tt> and
<tt>Thyra::DefaultProductVectorSpace::createMembers()</tt>.  See
\ref Thyra_Op_Vec_product_vec_spc_prg_grp "this example"
of how product vector spaces are used.

<li> <b>Miscellaneous implicit linear operators</b><a name="thyra_impicit_linear_operators_tag"/>

These are several different types of useful implicit composite/decorator
<tt>Thyra::LinearOpBase</tt> subclasses.  These concrete subclasses provide
the building blocks for arbitararly complex implicitly composed linear
operators.  Default implementations for these implicit linear operator
subclasses are shown below:

<ul>

<li><tt>Thyra::DefaultZeroLinearOp</tt> is used to define
  a zero linear operator of the form:

  \f$M = 0 \in \Re^{m \times n}\f$

  defined in terms of two vector spaces (a range and a domain).

<li><tt>Thyra::DefaultIdentityLinearOp</tt> is used to define
  an identity linear operator of the form:

  \f$M = I \in \Re^{n \times n}\f$

  defined in terms of a single vector space.

<li><tt>Thyra::DefaultDiagonalLinearOp</tt> is a simple concrete subclass
  that defines a diagonal linear operator

  \f$M = \mbox{diag}(d) \in \Re^{n \times n}\f$

  out of any <tt>Thyra::VectorBase</tt> object for the diagonal \f$d \in \Re^n\f$.

<li><tt>Thyra::DefaultScaledAdjointLinearOp</tt> is a simple concrete
  decorator subclass that defines an
  implicit scaled and/or adjoined (or transposed) linear operator

  \f$M = \gamma \; op(A)\f$.

<li><tt>Thyra::DefaultAddedLinearOp</tt> is a simple concrete composite
  subclass that represent the implicit addition of two or more constituent 
  <tt>Thyra::LinearOpBase</tt> objects of the form

  \f$M =\; A_0 + A_1 + \ldots + A_{m-1}}\f$

  composed out of one or more constituent linear operators
  \f$A_0, A_1 \ldots A_{m-1}\f$.

<li><tt>Thyra::DefaultMultipliedLinearOp</tt> is a simple concrete composite
  subclass that defines a composite multiplicative
  <tt>Thyra::LinearOpBase</tt> of the form

  \f$M =\; A_0 A_1 \ldots A_{m-1}}\f$

  composed out of one or more constituent linear operators
  \f$A_0, A_1 \ldots A_{m-1}\f$.

<li><tt>Thyra::DefaultBlockedLinearOp</tt> is a simple concrete composite
  subclass that defines a composite blocking of
  <tt>Thyra::LinearOpBase</tt> objects of the form

  \f$M = \begin{array}{cccc}
    A_{0,0} & A_{0,1} & \ldots & A_{0,n-1} \\
    A_{1,0} & A_{1,1} & \ldots & A_{1,n-1} \\
    \vdots &  \vdots  & \ddots & \vdots \\
    A_{m-1,0} & A_{m-1,1} & \ldots & A_{m-1,n-1}
  \end{array}\f$

  composed out of one or more constituent linear operators.

</ul>

</ol>

<li> <b>Creating explicit views of vector and multi-vector elements</b>

<b>Warning!</b> using the utility classes below it is very easy to
obtain direct access to vector and multi-vector elements but in
general, this is a very bad idea.  However, as described in <a
href="http://trilinos.sandia.gov/packages/tsfcore/TSFCoreSAND.pdf">this
report</a>, there are some types of ANAs that require direct element
access to certain kinds of vectors and multi-vectors (for example,
vectors and multi-vectors that lie is the domain space of a
multi-vector).  The following utility classes streamline creating and
using explicit views.

<ul>
<li><tt>Thyra::ConstDetachedVectorView</tt> creates a (<tt>const</tt>) non-mutable explicit view of a <tt>const %Thyra::%VectorBase</tt> object,
    allows direct access to vector elements and then frees the view in the destructor.
<li><tt>Thyra::DetachedVectorView</tt> creates a (non-<tt>const</tt>) mutable explicit view of a <tt>%Thyra::%VectorBase</tt> object,
    allows direct access to vector elements and then frees the view in the destructor.
<li><tt>Thyra::ConstDetachedMultiVectorView</tt> creates a (<tt>const</tt>) non-mutable explicit view of a <tt>const %Thyra::%MultiVectorBase</tt> object,
    allows direct access to multi-vector elements and then frees the view in the destructor.
<li><tt>Thyra::DetachedMultiVectorView</tt> creates a (non-<tt>const</tt>) mutable explicit view of a <tt>%Thyra::%MultiVectorBase</tt> object,
    allows direct access to multi-vector elements and then frees the view in the destructor.
</ul>

One of the big advantages of using the above utility classes in
addition to their convenience is that views are freed in destructors
and these view will be freed even in the event that an exception is
thrown.  The use of these view classes is quite straightforward.

<li><b>Basic default implementation node subclasses</b>

The following subclasses directly derive from
\ref Thyra_Op_Vec_fundamental_interfaces_sec and provide general default
implementations for as many virtual functions as reasonable:

<ul>

<li><tt>Thyra::VectorSpaceDefaultBase</tt> should be a direct or indirect base
class of almost every concrete <tt>Thyra::VectorSpaceBase</tt> adapter
subclass.  This node subclass provides the default implementation
<tt>Thyra::VectorSpaceDefaultBase::createMembers()</tt> using the
<tt>Thyra::DefaultColumnwiseMultiVector</tt> subclass.  Therefore, a subclass
need only provide a <tt>VectorBase</tt> implementation and override the
<tt>Thyra::VectorSpaceBase::createMember()</tt> and related functions.

<li><tt>Thyra::LinearOpDefaultBase</tt> should be a direct or indirect base
class of almost every concrete <tt>Thyra::MultiVectorBase</tt> adpater
subclass.  This node subclass provides just the default implementation
override <tt>Thyra::LinearOpDefaultBase::describe()</tt>

<li><tt>Thyra::SingleScalarLinearOpBase</tt> provides a node subclass for all
linear operators that can only handle a single scalar type for both the range
and domain spaces.

<li><tt>Thyra::SingleRhsLinearOpBase</tt> provides a node subclass for all
linear operators that can only handle a single scalar type for both the range
and domain spaces and only single vector arguments for
<tt>Thyra::SingleRhsLinearOpBase::apply()</tt>.

<li><tt>Thyra::MultiVectorDefaultBase</tt> should be a direct or indirect base
class of almost every concrete <tt>Thyra::MultiVectorBase</tt> adpater
subclass.  This node subclass provides a default of every inherited virtual
function from the base class <tt>Thyra::MultiVectorBase</tt> in terms of just
<tt>Thyra::MultiVectorBase::col()</tt>.  While many of these default function
implementations are highly non-optimal, however, they allow for rapid
prototyping of new <tt>Thyra::MultiVectorBase</tt> subclasses.

<li><tt>Thyra::VectorDefaultBase</tt> should be a direct or indirect base
class of almost every concrete <tt>Thyra::VectorBase</tt> adpater subclass.
This node subclass provides full general and efficient implementations of all
of the inherited virtual functions from the base class
<tt>Thyra::MultiVectorBase</tt>.

</ul>

<li> <b>Unit testing software</b>

This is basic testing software for %Thyra:

<ul>
<li><tt>Thyra::LinearOpTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::LinearOpBase</tt> object by checking its linear properties, and/or its adjoint,
    and/or symmetry.  In addition, it can check if two linear operators are the same.
<li><tt>Thyra::MultiVectorTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::MultiVectorBase</tt> object.  This class exposes a <tt>Thyra::LinearOpTester</tt> object
    for testing the <tt>LinearOpBase</tt> base interface of <tt>Thyra::MultiVectorBase</tt>. 
<li><tt>Thyra::VectorTester</tt> is a unit testing class that validates the implementation
    of a <tt>Thyra::VectorBase</tt> object.  This class exposes a <tt>Thyra::MultiVectorTester</tt> object
    for testing the <tt>MultiVectorBase</tt> base interface of <tt>Thyra::VectorBase</tt>. 
<li><tt>Thyra::VectorSpaceTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then proceeds to create a number of <tt>Thyra::VectorBase</tt> and
    <tt>Thyra::MultiVectorBase</tt> objects and then and validates all of these objects.
    This class class, therefore, is a unit testing class for all three interfaces <tt>%Thyra::VectorSpaceBase</tt>,
    <tt>%Thyra::VectorBase</tt>, and <tt>Thyra::MultiVectorBase</tt>.
<li><tt>Thyra::VectorStdOpsTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then tests all of the standard vector RTOp wrappers documented
    \ref Thyra_Op_Vec_VectorStdOps_grp "here".
<li><tt>Thyra::MultiVectorStdOpsTester</tt> is a unit testing class that accepts any <tt>Thyra::VectorSpaceBase</tt>
    object and then tests all of the standard multi-vector RTOp wrappers documented
    \ref Thyra_Op_Vec_MultiVectorStdOps_grp "here".
</ul>

<li> <b>Miscellaneous Tools for testing and debugging</b>

There is software included in the Thyra package to support basic
testing and debugging.

First, 100/% general output stream operators for any
<tt>Thyra::VectorBase</tt> or <tt>Thyra::LinearOpBase</tt> object are
provided in the following operator functions:

<ul>
<li><tt>Thyra::operator<<(std::ostream& o, const Thyra::VectorBase<Scalar>& v)</tt>
    is an output stream operator for printing <tt>Thyra::VectorBase</tt> objects.
<li><tt>Thyra::operator<<(std::ostream& o, const Thyra::LinearOpBase<Scalar>& M)</tt>
    is an output stream operator for printing <tt>Thyra::LinearOpBase</tt> (and therefore
also <tt>Thyra::MultiVectorBase</tt>) objects.
</ul>

<li> <b>Miscellaneous software</b>

Here is software that does not neatly fall into any of the above categories
but is still considered ANA software.

<ul>
<li><tt>Thyra::ParameterDrivenMultiVectorInput</tt> is a simple concrete
utility class that derives from <tt>Teuchos::ParameterListAcceptor</tt> that
defines a parameter sublist that specifies how to read (multi)vectors for a
file(s) or directly from the parameter list.
</ul>

</ol>

\section Thyra_Op_Vec_ANA_Development_examples_sec Examples of Abstract Numerical Algorithms

There are several code examples that one can study to see how to use
the code described here as an API for developing ANAs.

<ul>

<li><tt>sillyPowerMethod()</tt> is a simple example ANA that
implements the power method for estimating the dominate eigenvalue
of a linear operator.

<li><tt>sillyCgSolve()</tt> is a simple example ANA that
implements the conjugate gradient method for solving a symmetric
positive definite linear system.

<li><tt>sillierCgSolve()</tt> calls the function <tt>silliestCgSolve()</tt> to
implement CG using handle classes.

<li><tt>silliestCgSolve()</tt> is a simple example ANA that also implements
the conjugate gradient method for solving a symmetric positive definite linear
system but it uses the handle layer with operator overloading.

<li><tt>Thyra::LinearOpTester::check()</tt> shows how to access a
<tt>Thyra::LinearOpBase</tt> objects domain and range spaces, how to use
these spaces to create vectors and multi-vectors and how to perform
various types of operations involving vectors, multi-vectors and
linear operators.

</ul>

\section Thyra_Op_Vec_ANA_Development_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_Adapters_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_ANA_Development_support_code_grp General ANA support code
 *
 * \ingroup Thyra_Op_Vec_ANA_Development_grp
 */

/** \defgroup Thyra_Op_Vec_ANA_Development_support_code_utils_grp General ANA support code utilities
 *
 * \ingroup Thyra_Op_Vec_ANA_Development_support_code_grp
 */

/** \defgroup Thyra_Op_Vec_Adapters_grp Development of Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_use_cases_grp

\brief In order for abstract numerical algorithms (ANAs)
\ref Thyra_Op_Vec_ANA_Development_grp "developed with Thyra" or
\ref Thyra_Op_Vec_ANA_Interoperability_grp "accessed using Thyra" to be useful,
concrete implementations of the
\ref Thyra_Op_Vec_fundamental_interfaces_sec must be provided.
However, because of a number of convenient C++ subclasses described
here, a developer of such implementation subclasses does not really need to understand much at all
about the philosophy or details behind the fundamental %Thyra
interfaces in order to provide implementations for the most common use
cases.

One of the main motivations behind the design of the \ref
Thyra_Op_Vec_fundamental_interfaces_sec is the uniform support for many
different computing environments such as serial shared-memory (i.e. SMP) and a
variety of distributed-memory models (e.g. SPMD (single program, multiple
data), client-server, master-slave and client-server/master-slave).  While
this is the case, the overwhelming majority of concrete implementations of
these types will be in more typical SMP serial shared-memory or SPMD
distributed-memory environments.  Because of this, the Trilinos package %Thyra
contains a set of base subclasses that makes the development of concrete
vector space, vector, multi-vector and linear operator subclasses as easy as
possible.  However, the \ref Thyra_Op_Vec_fundamental_interfaces_sec allow
for almost limitless possibilities with respect to the types of
implementations so it is not reasonable to provide pre-packaged support for
all of the possibilities.

<b>Heads Up!</b> In case you think you will have to develop your own concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> or
<tt>Thyra::MultiVectorBase</tt> subclasses in addition to whatever
<tt>Thyra::LinearOpBase</tt> subclasses that you need for you application, you
are probably wrong!  You most likely will not need to create any concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> or
<tt>Thyra::MultiVectorBase</tt> subclasses and instead should only need to
develop concrete <tt>Thyra::LinearOpBase</tt> subclass(es) by deriving from
<tt>Thyra::SpmdLinearOpBase</tt> for serial and SPMD platforms.  As described
below, general yet efficient implementations of concrete
<tt>Thyra::VectorSpaceBase</tt>, <tt>Thyra::VectorBase</tt> and
<tt>Thyra::MultiVectorBase</tt> subclasses for serial and SPMD platforms are
already available.

Next, we provide a description of the various types of support code
for creating concrete implementations as well as concrete
implementations that are available.  Just browse the categories that
you are interested in.

\section Thyra_Op_Vec_Adapters_overview_sec Overview of Concrete Thyra Subclass Implementations

<ol>

</ul>

<li><b>\ref Thyra_Op_Vec_basic_adapter_support_grp</b>

Click \ref Thyra_Op_Vec_basic_adapter_support_grp "here" if you want to know
about high-level support subclasses for separating out the definition of the
scalar product from the data structures and factory methods for specific
computing platforms.  All of the concrete %Thyra implementation subclasses
outlined below derive from and use these base interfaces.  However, knowing
the details of these base interfaces is not critical for developing concrete
implementations in most situations unless application-defined scalar products
are needed.  The Euclidean scalar product is used automatically by default and
if that is all you need then you can ignore these base classes.

<li><b>Support subclasses for specific types of computing platforms</b>

Below we outline support code contained in the %Thyra package for
different categories of computing platforms.

<b>Note!</b> Before attempting to create your own concrete subclasses
of the \ref Thyra_Op_Vec_fundamental_interfaces_sec please browse the 
links below so that you know what support is already available.  In many
cases, most of the concrete implementation software that you need for
%Thyra is already provided.

<ol>

<li><b>\ref Thyra_Op_Vec_spmd_adapters_grp</b>

Click \ref Thyra_Op_Vec_spmd_adapters_grp "here" if you want to know about
support for developing %Thyra subclass implementations for serial and SPMD
distributed-memory platforms.  These platforms are most commonly used in
large-scale scientific computing.  Note that the above link also describes
very general and efficient concrete SPMD subclasses for vector spaces,
vectors, and multi-vectors as well as a support class for creating concrete
SPMD linear operator implementations.  All of these classes are based on a
small abstract communication layer <tt>Teuchos::Comm</tt> and is independent
of MPI or any other concrete interprocess communication protocol.

</ol>

</ol>

\section Thyra_Op_Vec_Adapters_other_sec Other Use Cases

<ul>

<li> \ref Thyra_Op_Vec_ANA_Interoperability_grp

<li> \ref Thyra_Op_Vec_ANA_Development_grp

</ul>

*/

/** \defgroup Thyra_Op_Vec_general_adapter_support_code_grp Miscellaneous Support Code for Developing Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_Adapters_grp

\brief This is some basic C++ code to support the development of Thyra subclass implementations.

*/


/** \defgroup Thyra_Op_Vec_general_adapter_support_code_utils_grp Internal Helper Code not meant for General Use

\brief Some support code that is not meant for general programmers to access.

\ingroup Thyra_Op_Vec_general_adapter_support_code_grp

*/

/** \defgroup Thyra_Op_Vec_basic_adapter_support_grp Basic Support Subclasses Abstracting Application-Specific Scalar Products

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The \ref Thyra_Op_Vec_fundamental_interfaces_sec define an interface
for providing ANAs with the functionality they need concerning
application-specific scalar products without concern for how such scalar
products are implemented or how such scalar products relate to the
implementation of vectors, multi-vectors or linear operators.  While this is
most straightforward for clients of these interfaces, it is not the most
convenient for subclass implementation developers.  The first level of basic
subclasses for supporting the development of concrete %Thyra operator/vector
implementations involves separating out the definition of the scalar product
from the basic vector and multi-vector data structures and the factory methods
for creating them.  The base subclasses for supporting application-defined
scalar products are shown in the UML class diagram below.

\image html ScalarProdVectorSpaceBase.gif "Support base subclasses for abstracting application-specific scalar products (Note: above graphic is not hyperlinked!)"

The classes shown in the above UML class diagram are described below:

<ul>

<li><tt>Thyra::ScalarProdBase</tt> defines an interface for an
application-specific scalar product independent from a vector space.

<li><tt>Thyra::ScalarProdVectorSpaceBase</tt> is subclass of
<tt>%Thyra::%VectorSpaceBase</tt> that defines the scalar product functions in
terms of an aggregate <tt>%Thyra::%ScalarProdBase</tt> object that can be
swapped in and out (see the C++ code for the
<tt>Thyra::ScalarProdVectorSpaceBase::scalarProd()</tt> function as an
example).

<li><tt>Thyra::EuclideanScalarProd</tt> is a standard implementation subclass
of <tt>%Thyra::%ScalarProdBase</tt> for Euclidean scalar products (i.e. using
the dot product).  This is the default scalar product definition used by
<tt>%Thyra::%ScalarProdVectorSpaceBase</tt> and all of its subclass objects.

<li><tt>Thyra::LinearOpScalarProd</tt> is a more general implementation of a
scalar product that uses an arbitrary symmetric positive-definite
<tt>%Thyra::%LinearOpBase</tt> object (shown using the <tt>op</tt>
relationship in the above UML class diagram).

<li><tt>Thyra::EuclideanLinearOpBase</tt> is a base subclass that allows the
development of general concrete implementations of
<tt>%Thyra::%LinearOpBase</tt> that are independent of an application-specific
scalar product.  This base subclass defines the functions
<tt>Thyra::EuclideanLinearOpBase::euclideanApply()</tt> and
<tt>Thyra::EuclideanLinearOpBase::euclideanApplyTranspose()</tt> which are
called by <tt>Thyra::ScalarProdBase::apply()</tt> to modify the application of
an Euclidean linear operator for the definition of the scalar product (see the
C++ code for the overridden <tt>Thyra::EuclideanLinearOpBase::apply()</tt> and
<tt>Thyra::EuclideanLinearOpBase::applyTranspose()</tt> functions).  This base
class is most helpful for the definition of concrete
<tt>Thyra::MultiVectorBase</tt> subclasses.  More specialized linear operators
that already define the operator with respect to application-specific scalar
product should not derive from this subclass but should instead derive
directly from <tt>%Thyra:%LinearOpBase</tt>.

</ul>

The base subclasses <tt>Thyra::ScalarProdVectorSpaceBase</tt> and
<tt>Thyra::EuclideanLinearOpBase</tt> are used for almost all of the other
adapter support subclasses and concrete implementations in the %Thyra package.

*/

/** \defgroup Thyra_Op_Vec_spmd_adapters_grp Thyra Operator/Vector Subclasses for SPMD Distributed-Memory Platforms

\ingroup Thyra_Op_Vec_Adapters_grp

\brief The package %Thyra includes subclasses for common serial and SPMD
vector spaces, vectors, and multi-vectors which are described here.

When interfacing to most other well designed packages, there should be no need
to create new concrete serial or SPMD vector space, vector or multi-vector
subclasses given the subclasses described below.

\section Thyra_Op_Vec_spmd_adapters_classes_sec Subclasses for SPMD Thyra Implementations

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_Spmd_support_grp</b>

Click \ref Thyra_Op_Vec_adapters_Spmd_support_grp "here" if you want to know
about the basic support base subclasses for a common type of SPMD
vector and multi-vector implementation that all of the concrete
implementations described below depend on.

<li> <b>Concrete SPMD subclasses</b>

Below are some concrete implementations of %Thyra classes that are
derived from the
\ref Thyra_Op_Vec_adapters_Spmd_support_grp "basic SPMD-support base subclasses"
mentioned above.

<ol>

<li> <b>\ref Thyra_Op_Vec_adapters_Spmd_concrete_std_grp</b>

Click \ref Thyra_Op_Vec_adapters_Spmd_concrete_std_grp "here" if you want to
know about some general, yet very efficient, concrete implementations of
SPMD vector spaces, vectors and multi-vectors.

<li> <b><a href="../../../../../../epetra/thyra/doc/html/index.html">Epetra to Thyra Operator/Vector Adapters</a></b> (separate doxygen collection)

Click <a href="../../../../../../epetra/thyra/doc/html/index.html">here</a> if
you want to know about some general code that takes Epetra objects and creates
%Thyra wrappers for them.

</ol>

</ol>

*/

/** \defgroup Thyra_Op_Vec_adapters_Spmd_support_grp Thyra Operator/Vector Base Support Subclasses for SPMD Thyra Implementations

\ingroup Thyra_Op_Vec_spmd_adapters_grp

\brief The package %Thyra contains base subclasses that support a
common type of SPMD implementation of vectors and
multi-vectors that are described here.

The UML class diagram below shows the subclasses described here:

\image html SpmdVectorSpaceDefaultBase.gif "Support base subclasses for SPMD distributed-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

The base subclasses described here provide support for a simple, yet general,
category of Serial and SPMD vectors, multi-vectors and vector spaces.

<ul>

<li><tt>Thyra::SpmdVectorSpaceDefaultBase</tt> abstracts the the types of
SPMD distributed-memory data distributions supported by these base
subclasses.  This vector space base class assumes a unique
partitioning of vector and multi-vector elements to a set of
processors where there exists no ghost elements.

<li><tt>Thyra::SpmdVectorBase</tt> is a base subclass for
SPMD <tt>%Thyra::%VectorBase</tt> objects.  This class defines concrete
implementations for the <tt>%Thyra::%VectorBase</tt> virtual functions
<tt>%applyOp()</tt>, <tt>%acquireDetachedView() const</tt>, <tt>%releaseDetachedView()
const</tt>, <tt>%acquireDetachedView()</tt> and <tt>%commitDetachedView()</tt>.
These functions are implemented given explicit access to local processor
elements as returned by the <tt>getLocalData()</tt> functions overridden
in a subclass object.

<li><tt>Thyra::SpmdMultiVectorBase</tt> is a base subclass for
SPMD <tt>%Thyra::%MultiVectorBase</tt> objects.  This class
defines concrete implementations for the
<tt>%Thyra::%MultiVectorBase</tt> virtual functions <tt>%applyOp()</tt>,
<tt>%acquireDetachedView() const</tt>, <tt>%releaseDetachedView()
const</tt>, <tt>%acquireDetachedView()</tt> and
<tt>%commitDetachedView()</tt>.  These functions are implemented
given explicit access to local processor elements as returned by the
<tt>getLocalData()</tt> functions overridden in a subclass object.  In
addition, this subclass derives from
<tt>Thyra::EuclideanLinearOpBase</tt> so that any
application-specific scalar product is automatically supported.  The
multi-vector version of
<tt>Thyra::SpmdMultiVectorBase::euclideanApply()</tt> is implemented
by calling <tt>Teuchos::BLAS::GEMM()</tt> on each local processor to
access level-3 BLAS.  Therefore, if %Teuchos is configured to link to
optimized BLAS then this base subclass will provided a near optimal
implementation of a SPMD multi-vector.

</ul>

One of the big advantages of deriving concrete SPMD
implementations from these base subclasses is that they provide automatic
interoperability between different concrete subclasses.  This type of
automatic interoperability is demonstrated in ???this testing program???.

\section Thyra_Op_Vec_spmd_adapters_linear_op_sec Base Subclasses for SPMD Thyra::LinearOpBase Implementations

To facilitate the creation of concrete SPMD linear operators the
following simple but very general base class is supplied:

<ul> <li><tt>Thyra::SpmdLinearOpBase</tt> is a general base subclass for
Serial and SPMD platforms that only requires concrete subclass implementations
to override one function that accepts explicit local vector or multi-vector
data. </ul>

*/

/** \defgroup Thyra_Op_Vec_adapters_Spmd_concrete_std_grp Efficient Generic SPMD Concrete Thyra Operator/Vector Subclass Implementations

\ingroup Thyra_Op_Vec_spmd_adapters_grp

\brief The package %Thyra contains highly efficient concrete
implementations of SPMD vector space, vector and multi-vector
subclasses.

\image html DefaultSpmdVectorSpace.gif "Concrete subclasses for SPMD distributed-memory Thyra implementations (Note: above graphic is not hyperlinked!)"

\section Thyra_Op_Vec_adapters_Spmd_concrete_std_classes_grp Concrete SPMD Subclasses

The concrete subclasses described here, for the most part, derive directly
from the \ref \ref Thyra_Op_Vec_adapters_Spmd_support_grp.

<ul>

<li><tt>Thyra::DefaultSpmdVectorSpaceFactory</tt> is a concrete
<tt>%Thyra::%VectorSpaceFactoryBase</tt> subclass implementation that
creates locally replicated <tt>%Thyra::%DefaultSpmdVectorSpace</tt> objects
given their dimension.  This class is meant to create domain spaces for
any SPMD multi-vector object it is is used as such (for
example, see <tt>Thyra::SpmdVectorSpaceDefaultBase::smallVecSpcFcty()</tt>).

<li><tt>Thyra::DefaultSpmdVectorSpace</tt> is a general
<tt>%Thyra::%VectorSpaceBase</tt> subclass implementation for 
SPMD vector spaces which creates <tt>%Thyra::%DefaultSpmdVector</tt> and
<tt>%Thyra::%DefaultSpmdMultiVector</tt> objects.

<li><tt>Thyra::DefaultSpmdVector</tt> is a very general, highly
efficient <tt>%Thyra::%VectorBase</tt> subclass implementation for
SPMD vectors.  Objects of this type can be constructed
from a variety of data sources due to the magic of
<tt>%Teuchos::%RCP</tt>.

<li><tt>Thyra::DefaultSpmdMultiVector</tt> is a very general, highly
efficient <tt>%Thyra::%MultiVectorBase</tt> subclass implementation for
SPMD multi-vectors.  Objects of this type can be constructed
from a variety of data sources due to the magic of
<tt>%Teuchos::%RCP</tt>.

<li><tt>Thyra::DefaultSpmdMultiVectorFileIO</tt> in a concrete implementation
of <tt>Thyra::MultiVectorFileIO</tt> that reads and writes (multi)vector to
and from files in parallel.  Each process is given its own file name and has
its own extension.

</ul>

Together, these concrete subclasses provide a complete and highly
efficient implementation for SPMD vector, multi-vector and
vector space objects.  From the standpoint of the needs of an ANA,
there is really no need for any other concrete implementations of
these subclasses for SPMD platforms.

*/

//
// Examples
//


/** \defgroup Thyra_Op_Vec_examples_grp Assorted Thyra Operator/Vector Example Code

\brief Below are links to example code that demonstrate various use cases for
%Thyra operator/vector code:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_grp

<li>\ref Thyra_Op_Vec_examples_cg_grp

<li>\ref Thyra_Op_Vec_product_vec_spc_prg_grp

<li>\ref Thyra_Op_Vec_test_scalar_product_prg_grp

</ol>

*/

//
// Silly power method example
//

/** \defgroup Thyra_Op_Vec_examples_power_method_grp Power Method Examples

\ingroup Thyra_Op_Vec_examples_grp

\brief Here we show some simple examples of using code in the %Thyra
package with an example linear ANA algorithm for the power method for
estimating the dominate eigen value of a matrix.

These example programs are meant to mimic the power method example
program shown in the <a href="../../../../../../epetra/doc/html/index.html#example">Epetra
documentation</a>.

The power method ANA is implemented in the function
<tt>sillyPowerMethod()</tt> and its implementation is shown below:

\dontinclude sillyPowerMethod.hpp

\skip template
\until end sillyPowerMethod

The above templated function <tt>%sillyPowerMethod()</tt> is used in
the following various example implementations which use several
different scalar types:

<ol>

<li>\ref Thyra_Op_Vec_examples_power_method_serial_grp

</ol>

*/

/** \example sillyPowerMethod.hpp

Click \ref Thyra_Op_Vec_examples_power_method_grp "here" for a more
detailed discussion of this example function.

*/

/** \defgroup Thyra_Op_Vec_examples_power_method_serial_grp Templated Serial Implementation of the Power Method

\ingroup Thyra_Op_Vec_examples_power_method_grp

\brief Here is an example program that shows the use of the example
serial templated matrix class <tt>ExampleTridiagSerialLinearOp</tt>
with the example linear ANA implementation <tt>sillyPowerMethod()</tt>.

This example program is contained in the source file:

\verbatim ./example/operator_vector/sillyPowerMethod_serial.cpp \endverbatim

where <tt>./</tt> is the base source directory for %Thyra
(i.e. <tt>???/Trilinos/packages/Thyra</tt>).

The class <tt>ExampleTridiagSerialLinearOp</tt> that derives from the
base class <tt>Thyra::SpmdLinearOpBase</tt> is quite simple and
its complete implementation looks like:

\dontinclude ExampleTridiagSerialLinearOp.hpp
\skip template
\until end class ExampleTridiagSerialLinearOp

\dontinclude sillyPowerMethod_serial.cpp

The above serial matrix class is used in an example program (see
<tt>runPowerMethodExample()</tt> below) that calls <tt>%sillyPowerMethod()</tt>.
In this example program, the matrix constructed and used is the
well-known tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2      & -1 \\
-1     &  2      & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -1      & 2       & -1 \\
       &         &         &  -1     & 2
\end{array}\right].
\f]

The power method is then run on the matrix \f$A\f$ run for a number of
iterations (or until convergence to some tolerance).

After this, the first diagonal element \f$A_{(1,1)}=2\f$ is then
scaled to \f$A_{(1,1)}=20\f$ and the power method is run again (which
much faster convergence).

The following templated function implements the example described
above:

\skip template
\until end runPowerMethodExample

The above templated function <tt>runPowerMethodExample()</tt> is
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
<li> Real extended-precision type <b><tt>mpf_class</tt></b>
     (if <tt>--enable-teuchos-gmp</tt> was used at configuration time)
<li> Complex extended-precision type <b><tt>std::complex<mpf_class></tt></b>
     (if <tt>--enable-teuchos-complex</tt> and <tt>--enable-teuchos-gmp</tt>
     where used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/operator_vector/sillyPowerMethod_serial.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>$TRILINOS_BUILD_DIR/packages/thyra</tt>).

This example program should run successfully with no arguments and produces
the following output:

\verbinclude sillyPowerMethod_serial.default.out

This example program also takes a number of command-line options.  To see what
the command-line options are, use the <tt>--help</tt> option.  The
command-line options returned from <tt>./sillyPowerMethod_serial.exe
--echo-command-line --help</tt> are:

\verbinclude sillyPowerMethod_serial.help.out

To see the full listing of this example program click: <a
href="sillyPowerMethod__serial_8cpp-example.html">
sillyPowerMethod_serial.cpp </a>

*/

/** \example ExampleTridiagSerialLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_power_method_serial_grp "here" and
\ref Thyra_Op_Vec_examples_cg_serial_grp "here" for example programs that
use this example class.

*/

/** \example ExampleTridiagSpmdLinearOp.hpp

Click \ref Thyra_Op_Vec_examples_power_method_Spmd_grp "here" and
\ref Thyra_Op_Vec_examples_cg_Spmd_grp "here" for example programs that
use this example class.

*/

/** \example sillyPowerMethod_serial.cpp

Click \ref Thyra_Op_Vec_examples_power_method_serial_grp "here" for a more
detailed discussion of this example program.

*/

//
// Silly CG example
//

/** \defgroup Thyra_Op_Vec_examples_cg_grp CG Examples

\ingroup Thyra_Op_Vec_examples_grp

\brief Here we show some simple examples of using code in the %Thyra
package with an example ANA algorithm for the iterative solution of
symmetric positive-definite linear systems using the conjugate
gradient (CG) method.

The CG ANA is implemented in the function <tt>sillyCgSolve()</tt> and
its implementation is shown below:

\dontinclude sillyCgSolve.hpp
\skip template
\until end sillyCgSolve

Another version of this CG algorithm is demonstrated in the below function:

\dontinclude silliestCgSolve.hpp
\skip template
\until end silliestCgSolve

This above templated functions are used in the following various example
implementations which use several different scalar types:

<ol>

<li>\ref Thyra_Op_Vec_examples_cg_serial_grp

<li>\ref Thyra_Op_Vec_examples_cg_Spmd_grp

</ol>

*/

/** \example sillyCgSolve.hpp

Click \ref Thyra_Op_Vec_examples_cg_grp "here" for a more
detailed discussion of this example function.

*/

/** \example sillierCgSolve.hpp

Click \ref Thyra_Op_Vec_examples_cg_grp "here" for a more
detailed discussion of this example function.

*/

/** \example silliestCgSolve.hpp

Click \ref Thyra_Op_Vec_examples_cg_grp "here" for a more
detailed discussion of this example function.

*/


/** \example sillyModifiedGramSchmidt.hpp

*/

/** \defgroup Thyra_Op_Vec_examples_cg_serial_grp Templated Serial Implementation of the CG Method

\ingroup Thyra_Op_Vec_examples_cg_grp

\brief Here is an example program that shows the use of the example
serial templated matrix class <tt>ExampleTridiagSerialLinearOp</tt>
with the example linear ANA implementation <tt>sillyCgSolve()</tt>.

The class <tt>ExampleTridiagSerialLinearOp</tt> that derives from the
base class <tt>Thyra::SpmdLinearOpBase</tt> is quite simple and
its complete implementation looks like:

\dontinclude ExampleTridiagSerialLinearOp.hpp
\skip template
\until end class ExampleTridiagSerialLinearOp

\dontinclude sillyCgSolve_serial.cpp

The above serial matrix class is used in an example program (see
<tt>runCgSolveExample()</tt> below) that calls <tt>%sillyCgSolve()</tt> or
<tt>%sillierCgSolve()</tt>.  In this example program, the matrix constructed
and used is the following tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2 a    & -1 \\
-r(1)  &  2 a    & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -r(n-2) & 2 a       & -1 \\
       &         &         &  -r(n-1)  & 2 a
\end{array}\right]
\f]

where \f$a\f$ is an adjustable diagonal scale factories that makes the matrix
\f$A\f$ more or less well conditioned and \f$r(i)\f$ is either \f$-1\f$ for a
symmetric operator or \f$rand()\f$ for an unsymmetric operator.

If a symmetric operator is used, then CG is run using \f$A\f$ directly.  If
\f$A\f$ is unsymmetric, then the normal equations

\f[

  A^H A x = A^H b

\f]

are solved and the operator used is

\f[
A \Rightarrow A^H A
\f]

The CG method is then run on the matrix \f$A\f$ or \f$A^H A\f$ for a number of
iterations or until convergence to some tolerance is achieved.

The following templated function <tt>runCgSolveExample()</tt>
implements the example described above:

\skip template
\until end runCgSolveExample

The above templated function <tt>runCgSolveExample()</tt> is then
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
<li> Real extended-precision type <b><tt>mpf_class</tt></b>
     (if <tt>--enable-teuchos-gmp</tt> was used at configuration time)
<li> Complex extended-precision type <b><tt>std::complex<mpf_class></tt></b>
     (if <tt>--enable-teuchos-complex</tt> and <tt>--enable-teuchos-gmp</tt>
     where used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/operator_vector/sillyCgSolve_serial.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>$TRILINOS_BUILD_DIR/packages/thyra</tt>).

This example program should run successfully with no arguments and produces
the following output:

\verbinclude sillyCgSolve_serial.default.out

This example program also takes a number of command-line options.  To see what
the command-line options are, use the <tt>--help</tt> option.  The
command-line options for this program returned from
<tt>./sillyCgSolve_serial.exe --echo-command-line --help</tt> are:

\verbinclude sillyCgSolve_serial.help.out

When the option <tt>--unsym-op</tt> is selected, the normal equations are
solved which is shown in the following example:

\verbinclude sillyCgSolve_serial.unsym-op.out

Note in the above example how the normal operator \f$A^H A\f$ is described.
This aggregate operator is created by the function calls
<tt>Thyra::adjoint()</tt> and <tt>Thyra::multiply()</tt> which create implicit
<tt>Thyra::ScaledAdjointedLinearOp</tt> and
<tt>Thyra::DefaultMultipliedLinearOp</tt> objects.

To see the full listing of this example program click: <a
href="sillyCgSolve__serial_8cpp-example.html">
sillyCgSolve_serial.cpp </a>

*/

/** \example sillyCgSolve_serial.cpp

Click \ref Thyra_Op_Vec_examples_cg_serial_grp "here" for a more
detailed discussion of this example program.

*/

/** \defgroup Thyra_Op_Vec_examples_cg_Spmd_grp Templated SPMD Implementation of the CG Method

\ingroup Thyra_Op_Vec_examples_cg_grp

\brief Here is an example program that shows the use of the example SPMD
templated matrix class <tt>ExampleTridiagSpmdLinearOp</tt> with the example
linear ANA implementation <tt>sillyCgSolve()</tt> or
<tt>silliestCgSolve()</tt>.

The class <tt>ExampleTridiagSpmdLinearOp</tt> that derives from the base class
<tt>Thyra::SpmdLinearOpBase</tt> is quite simple and its implementation (minus
the <tt>communication()</tt> function) looks like:

\dontinclude ExampleTridiagSpmdLinearOp.hpp
\skip template
\until end class ExampleTridiagSpmdLinearOp

\dontinclude sillyCgSolve_mpi.cpp

The above SPMD matrix class is used in an example program (see
<tt>runCgSolveExample()</tt> below) that calls <tt>%sillyCgSolve()</tt> or
<tt>%silliestCgSolve()</tt>.  In this example program, the matrix constructed
and used is the well-known tridiagonal matrix

\f[

A=
\left[\begin{array}{rrrrrrrrrr}
2 a    & -1 \\
-1     &  2 a    & -1 \\
       & \ddots  & \ddots  & \ddots \\
       &         & -1      & 2 a     & -1 \\
       &         &         &  -1     & 2 a
\end{array}\right]
\f]

where \f$a\f$ is an adjustable diagonal scale factor that makes the
matrix \f$A\f$ more or less well conditioned.

The CG method is then run on the matrix \f$A\f$ for a number of
iterations or until convergence to some tolerance is achieved.

The following templated function <tt>runCgSolveExample()</tt>
implements the example described above:

\skip template
\until end runCgSolveExample

The above templated function <tt>runCgSolveExample()</tt> is then
instantiated with the following scalar types:

<ul>
<li> Real types <b><tt>float</tt></b> and <b><tt>double</tt></b>
<li> Complex real types <b><tt>std::complex<float></tt></b> and
     <b><tt>std::complex<double></tt></b> (if <tt>--enable-teuchos-complex</tt>
     was used at configuration time)
</ul>

and is called multiple times from within the following <tt>main()</tt>
program function:

\skip int main
\until end main

The above example program is built as part of the %Thyra package
(unless examples where disabled at configure time) and the executable
can be found at:

\verbatim ./example/operator_vector/sillyCgSolve_mpi.exe \endverbatim

where <tt>./</tt> is the base build directory for %Thyra
(e.g. <tt>$TRILINOS_BUILD_DIR/packages/thyra</tt>).

This example program should run successfully with no arguments for any number
of processors and for one processor produces the following output:

\verbinclude sillyCgSolve_mpi.default.out

This example program also takes a number of command-line options.  To see what
the command-line options are, use the <tt>--help</tt> option.  The
command-line options returned from <tt>./sillyCgSolve_mpi.exe
--echo-command-line --help</tt> are:

\verbinclude sillyCgSolve_mpi.help.out

To see the full listing of this example program click: <a
href="sillyCgSolve__mpi_8cpp-example.html">
sillyCgSolve_mpi.cpp </a>

*/

/** \example sillyCgSolve_mpi.cpp

Click \ref Thyra_Op_Vec_examples_cg_Spmd_grp "here" for a more
detailed discussion of this example program.

*/

//
// Misc examples
//

/** \defgroup Thyra_Op_Vec_product_vec_spc_prg_grp Testing Program for Composite Product VectorBase Spaces and Product Vectors

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__product__space_8cpp-example.html">
test_product_space.cpp </a>.

*/

/** \example test_product_space.cpp

Click \ref Thyra_Op_Vec_product_vec_spc_prg_grp "here" for a more
detailed discussion of this example/test program.

*/

/** \defgroup Thyra_Op_Vec_test_composite_linear_ops_grp Testing Program for Composite Linear Operators

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__composite__linear__ops_8cpp-example.html">
test_composite_linear_ops.cpp </a>.

*/

/** \example exampleImplicitlyComposedLinearOperators.cpp

*/

/** \example test_composite_linear_ops.cpp

*/

/** \defgroup Thyra_Op_Vec_test_std_ops_grp Testing Program for Standard Vector and Multi-Vector Reduction/Transformation Operators

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__std__ops_8cpp-example.html">
test_std_ops.cpp </a>.

*/

/** \example test_std_ops.cpp

*/

/** \defgroup Thyra_Op_Vec_test_scalar_product_prg_grp Testing Program for non-Euclidean Scalar Products

\ingroup Thyra_Op_Vec_examples_grp

To see the full listing of this click: <a
href="test__scalar__product_8cpp-example.html">
test_scalar_product.cpp </a>.

*/

/** \example test_scalar_product.cpp

Click \ref Thyra_Op_Vec_test_scalar_product_prg_grp "here" for a more
detailed discussion of this example/test program.

*/
