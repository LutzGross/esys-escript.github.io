
% $Id$

\chapter{The module \escript}

\declaremodule{extension}{escript} 
\modulesynopsis{Data manipulation}

\begin{figure}
\includegraphics[width=\textwidth]{EscriptDiagram1.eps}
\caption{\label{ESCRIPT DEP}Dependency of Function Spaces. An arrow indicates that a function in the 
function space at the starting point can be interpreted as a function in the function space of the arrow target.}
\end{figure}

\escript is an extension of Python to handle functions represented by their values on
\DataSamplePoints for the geometrical region on which
the function is defined. The region as well as the method which is used 
to interpolate value on the \DataSamplePoints is defined by     
\Domain class objects. For instance when using 
the finite element method (FEM) \index{finite element method} 
\Domain object holds the information about the FEM mesh, eg. 
a table of nodes and a table of elements. Although \Domain contains
the discretization method to be used \escript does not use this information directly.
\Domain objects are created from a module which want to make use 
\escript, e.g. \finley.

The solution of a PDE is a function of its location in the domain of interest $\Omega$. 
When solving a partial differential equation \index{partial differential equation} (PDE) using FEM
the solution is (piecewise) differentiable but, in general, its gradient
is discontinuous. To reflect these different degrees of smoothness different
representations of the functions are used. For instance; in FEM
the displacement field is represented by its values at the nodes of the mesh, while the 
strain, which is the symmetric part of the gradient of the displacement field, is stored on the 
element centers. To be able to classify functions with respect to their smoothness, \escript has the
concept of the "function space". A function space is described by a \FunctionSpace object.
The following statement generates the object \var{solution_space} which is 
a \FunctionSpace object and provides access to the function space of 
PDE solutions on the \Domain \var{mydomain}:
\begin{python}
solution_space=Solution(mydomain)
\end{python}
The following generators for function spaces on a \Domain \var{mydomain} are available: 
\begin{itemize}
\item \var{Solution(mydomain)}: solutions of a PDE.  
\item \var{ContinuousFunction(mydomain)}: continuous functions, eg. a temperature distribution.
\item \var{Function(mydomain)}: general functions which are not necessarily continuous, eg. a stress field.
\item \var{FunctionOnBoundary(mydomain)}: functions on the boundary of the domain, eg. a surface pressure.
\item \var{FunctionOnContact0(mydomain)}: functions on side $0$ of the discontinuity. 
\item \var{FunctionOnContact1(mydomain)}: functions on side $1$ of the discontinuity.
\end{itemize}
A discontinuity \index{discontinuity} is a region within the domain across which functions may be discontinuous.  
The location of discontinuity is defined in the \Domain object.
\fig{ESCRIPT DEP} shows the dependency between the types of function spaces. 
The solution of a PDE is a continuous function. Any continuous function can be seen as a general function
on the domain and can be restricted to the boundary as well as to any side of the 
discontinuity (the result will be different depending on 
which side is chosen). Functions on any side of the  
discontinuity can be seen as a function on the corresponding other side. 
A function on the boundary or on one side of
the discontinuity cannot be seen as a general function on the domain as there are no values 
defined for the interior. For most PDE solver libraries
the space of the solution and continuous functions is identical, however in some cases, eg.
when periodic boundary conditions are used in \finley, a solution 
fulfils periodic boundary conditions while a continuous function does not have to be periodic.
   
The concept of function spaces describes the properties of 
functions and allows abstraction from the actual representation 
of the function in the context of a particular application. For instance, 
in the FEM context a
function in the \Function function space
is typically represented by its values at the element center, 
but in a finite difference scheme the edge midpoint of cells is preferred. 
Using the concept of function spaces 
allows the user to run the same script on different
PDE solver libraries by just changing the creator of the \Domain object.     
Changing the function space of a particular function
will typically lead to a change of its representation. 
So, when seen as a general function,
a continuous function which is typically represented by its values
on the node of the FEM mesh or finite difference grid 
must be interpolated to the element centers or the cell edges,
respectively.

\Data class objects store functions of the location in a domain. 
The function is represented through its values on \DataSamplePoints where
the \DataSamplePoints are chosen according to the function space 
of the function.  
\Data class objects are used to define the coefficients
of the PDEs to be solved by a PDE solver library 
and to store the returned solutions.

The values of the function have a rank which gives the
number of indices, and a \Shape defining the range of each index.
The rank in \escript is limited to the range $0$ through $4$ and
it is assumed that the rank and \Shape is the same for all \DataSamplePoints.
The \Shape of a \Data object is a tuple \var{s} of integers. The length
of \var{s} is the rank of the \Data object and \var{s[i]} is the maximum
value for the \var{i}-th index.
For instance, a stress field has rank $2$ and 
\Shape $(d,d)$ where $d$ is the spatial dimension.
The following statement creates the \Data object
\var{mydat} representing a 
continuous function with values 
of \Shape $(2,3)$ and rank $2$:
\begin{python}
mydat=Data(value=1,what=ContinuousFunction(myDomain),shape=(2,3))
\end{python}
The initial value is the constant $1$ for all \DataSamplePoints and
all components.

\Data objects can also be created from any \numarray
array or any object, such as a list of floating point numbers, 
that can be converted into a \numarray.NumArray \Ref{NUMARRAY}. 
The following two statements
create objects which are equivalent to \var{mydat}:
\begin{python}
mydat1=Data(value=numarray.ones((2,3)),what=ContinuousFunction(myDomain))
mydat2=Data(value=[[1,1],[1,1],[1,1]],what=ContinuousFunction(myDomain))
\end{python}
In the first case the initial value is \var{numarray.ones((2,3))}
which generates a $2 \times 3$ matrix as a \numarray.NumArray 
filled with ones. The \Shape of the created \Data object
it taken from the \Shape of the array. In the second
case, the creator converts the initial value, which is a list of lists,
and converts it into a \numarray.NumArray before creating the actual
\Data object.      

For convenience \escript provides creators for the most common types
of \Data objects in the following forms (\var{d} defines the 
spatial dimension):
\begin{itemize}
\item \var{Scalar(0,Function(mydomain))} is the same as \var{Data(0,Function(myDomain),(,))}, 
e.g a temperature field. 
\item \var{Vector(0,Function(mydomain))}is the same as \var{Data(0,Function(myDomain),(d))}, e.g
a velocity field.   
\item \var{Tensor(0,Function(mydomain))} is the same as \var{Data(0,Function(myDomain),(d,d))},
eg. a stress field.  
\item \var{Tensor4(0,Function(mydomain))} is the same as \var{Data(0,Function(myDomain),(d,d,d,d))}
eg. a Hook tensor field.   
\end{itemize}
Here the initial value is $0$ but any object that can be converted into a \numarray.NumArray and whose \Shape
is consistent with \Shape of the \Data object to be created can be used as the initial value.

\Data objects can be manipulated by applying unitary operations (eg. cos, sin, log) 
and can be combined by applying binary operations (eg. +, - ,* , /). 
It is to be emphasized that \escript itself does not handle any spatial dependencies as 
it does not know how values are interpreted by the processing PDE solver library. 
However \escript invokes interpolation if this is needed during data manipulations. 
Typically, this occurs in binary operation when both arguments belong to different
function spaces or when data are handed over to a PDE solver library 
which requires functions to be represented in a particular way. 

The following example shows the usage of {\tt Data} objects: Assume we have a
displacement field $u$ and we want to calculate the corresponding stress field
$\sigma$ using the linear--elastic isotropic material model
\begin{eqnarray}\label{eq: linear elastic stress}
\sigma\hackscore {ij}=\lambda u\hackscore {k,k} \delta\hackscore {ij} + \mu ( u\hackscore {i,j} + u\hackscore {j,i})
\end{eqnarray}
where $\delta\hackscore {ij}$ is the Kronecker symbol and 
$\lambda$ and $\mu$ are the Lame coefficients. The following function
takes the displacement {\tt u} and the Lame coefficients
\var{lam} and \var{mu} as arguments and returns the corresponding stress:
\begin{python}
import numarray
def getStress(u,lam,mu):
  d=u.getDomain().getDim()
  g=grad(u)
  stress=lam*trace(g)*numarray.identity(d)+ \
                                 mu*(g+transpose(g))
  return stress     
\end{python}
The variable 
\var{d} gives the spatial dimension of the 
domain on which the displacements are defined.
\var{identity} is a \numarray function which returns the Kronecker symbol with indexes 
$i$ and $j$ running from $0$ to \var{d}-1. The call \var{grad(u)} requires 
the displacement field \var{u} to be in the \var{Solution} or \ContinuousFunction
function space. The result \var{g} as well as the returned stress will be in the \Function function space. 
If \var{u} is available, eg. by solving a PDE, \var{getStress} might be called
in the following way:
\begin{python}
s=getStress(u,1.,2.)
\end{python}
However \var{getStress} can also be called with \Data objects as values for
\var{lam} and \var{mu} which,
for instance in the case of a temperature dependency, are calculated by an expression. 
The following call is equivalent to the previous example:
\begin{python}
lam=Scalar(1.,ContinuousFunction(mydomain))
mu=Scalar(2.,Function(mydomain))
s=getStress(u,lam,mu)
\end{python}
The function \var{lam} belongs to the \ContinuousFunction function space
but with \var{g} the function \var{trace(g)} is in the \Function function space.
Therefore the evaluation of the product \var{lam*trace(g)} in the stress calculation 
produces a problem, as both functions are represented differently, eg. in FEM
\var{lam} by its values on the node, and in \var{trace(g)} by its values at the element centers.
In the case of inconsistent function spaces of arguments in a binary operation, \escript 
interprets the arguments in the appropriate function space according to the inclusion 
defined in Table~\ref{ESCRIPT DEP}. In this example that means
 \escript sees \var{lam} as a function of the \Function function space. 
In the context of FEM this means the nodal values of 
\var{lam} are interpolated to the element centers. Behind the scenes
\escript calls the appropriate function from the PDE solver library.

\begin{figure}
\includegraphics[width=\textwidth]{EscriptDiagram2.eps}
\caption{\label{Figure: tag}Element Tagging. A rectangular mesh over a region with two rock types {\it white} and {\it gray}.
The number in each cell refers to the major rock type present in the cell ($1$ for {\it white} and $2$ for {\it gray}).
}
\end{figure}

Material parameters such as the Lame coefficients are typically dependent on rock types present in the 
area of interest. A common technique to handle these kinds of material parameters is "tagging". \fig{Figure: tag}
shows an example. In this case two rock types {\it white} and {\it gray} can be found in the domain. The domain
is subdivided into rectangular shaped cells (which is not necessarily the best subdivision for this case). Each 
cell has a tag indicating the rock type predominately found in this cell. Here $1$ is used to indicate
rock type {\it white} and $2$ for rock type {\it gray}. The tags are assigned at the time when the cells are generated
(\escript provides tools to manipulate tags at a later stage) 
and stored in the \Domain class object. The following statements show how for the
example of \fig{Figure: tag} and the stress calculation discussed before tagged values are used for
\var{lam}:
\begin{python}
lam=Scalar(value=2.,what=Function(mydomain))
lam.setTaggedValue(1,30.)
lam.setTaggedValue(2,5000.)
s=getStress(u,lam,2.)
\end{python}
In this example \var{lam} is set to $30$ for those cells with tag $1$ and to $5000.$ for those cells 
with tag $2$. The initial value $2$ of \var{lam} is used as a default value for the case when a tag
is encountered which has not been linked with a value. Note that the \var{getStress} method
is called without modification. \escript resolves the tags when \var{lam*trace(g)} is calculated.

The \Data class provides a transparent interface to various data representations and the 
translations between them. As shown in the example of stress calculation, this allows the user to
develop and test algorithms for a simple case (for instance with the Lame coefficients as constants)
and then without further modifications of the program code to apply the algorithm in a
more complex application (for instance a definition of the Lame coefficients using tags). 
As described here, there are three ways in which \Data objects are represented internally, constant, tagged, and expanded (other representions will become available in later versions of \escript):
In the constant case, if the same value is used at each sample point a single value is stored to save memory and compute time. 
Any operation on this constant data will only be performed on the single value. 
In the expanded case, each sample point has an individual value, eg. the solution of a PDE,
and the values are stored as a complete array. The tagged case has already been discussed above.
 
Values are accessed through a sample reference number. Operations on expanded \Data
objects have to be performed for each sample point individually. If tagged values are used values are
held in a dictionary. Operations on tagged data require processing the set of tagged values only, rather than 
processing the value for each individual sample point. 
\escript allows use of constant, tagged and expanded data in a single expression.



\section{\Domain class}
\begin{classdesc}{Domain}{}
A \Domain object is used to describe a geometrical region together with 
a way of representing functions over this region.
The \Domain class provides an abstract access to the domain of \FunctionSpace and \Data objects. 
\Domain itself has no initialization but implementations of \Domain are 
instantiated by numerical libraries making use of \Data objects. 
\end{classdesc}
The following methds are available:
\begin{methoddesc}[Domain]{getDim}{}
returns the spatial dimension of the \Domain.
\end{methoddesc}

\begin{methoddesc}[Domain]{getX}{}
returns the locations in the \Domain. The \FunctionSpace of the returned
\Data object is chosen by the \Domain implementation. Typically it will be
in the \Function.
\end{methoddesc}

\begin{methoddesc}[Domain]{setX}{newX}
assigns a new location to the \Domain. \var{newX} has to have \Shape $(d,)$
where $d$ is the spatial dimension of the domain. Typically \var{newX} must be
in the \ContinuousFunction but the space actually to be used depends on the \Domain implementation.
\end{methoddesc}

\begin{methoddesc}[Domain]{getNormal}{}
returns the surface normals on the boundary of the \Domain as \Data object.
\end{methoddesc}

\begin{methoddesc}[Domain]{getSize}{}
returns the local sample size, e.g. the element diameter, as \Data object.
\end{methoddesc}

\begin{methoddesc}[Domain]{__eq__}{arg}
returns \True of the \Domain \var{arg} describes the same domain. Otherwise
\False is returned.
\end{methoddesc}

\begin{methoddesc}[Domain]{__ne__}{arg}
returns \True of the \Domain \var{arg} does not describe the same domain. 
Otherwise \False is returned.
\end{methoddesc}

\begin{methoddesc}[Domain]{__str__}{g}
returns string represention of the \Domain.
\end{methoddesc}

\section{\Domain class}
\begin{classdesc}{FunctionSpace}{}
\FunctionSpace objects are used to define properties of \Data objects, such as continuity. \FunctionSpace objects
are instantiated by generator functions. \Data objects in particular \FunctionSpace are
represented by their values at \DataSamplePoints which are defined by the type and the \Domain of the
\FunctionSpace.
\end{classdesc}
The following methds are available:
\begin{methoddesc}[FunctionSpace]{getDim}{}
returns the spatial dimension of the \Domain of the \FunctionSpace.
\end{methoddesc}

\begin{methoddesc}[FunctionSpace]{getX}{}
returns the location of the \DataSamplePoints.
\end{methoddesc}

\begin{methoddesc}[FunctionSpace]{getNormal}{}
If the domain of functions in the \FunctionSpace 
is a hypermanifold (e.g. the boundary of a domain)
the method returns the outer normal at each of the 
\DataSamplePoints. Otherwise an exception is raised.
\end{methoddesc}

\begin{methoddesc}[FunctionSpace]{getSize}{}
returns a \Data objects measuring the spacing of the \DataSamplePoints.  
The size may be zero.
\end{methoddesc}

\begin{methoddesc}[FunctionSpace]{getDomain}{}
returns the \Domain of the \FunctionSpace.
\end{methoddesc}

\begin{methoddesc}[FunctionSpace]{__eq__}{arg}
returns \True of the \Domain \var{arg} describes the same domain. Otherwise
\False is returned.
\end{methoddesc}

\begin{methoddesc}[FunctionSpace]{__ne__}{arg}
returns \True of the \Domain \var{arg} describes the note same domain. 
Otherwise \False is returned.
\end{methoddesc}

\begin{methoddesc}[Domain]{__str__}{g}
returns string represention of the \Domain.
\end{methoddesc}

The following function provide generators for \FunctionSpace objects:
\begin{funcdesc}{Function}{domain}
returns the \Function on the \Domain \var{domain}. \Data objects in this type of \Function
are defined over the whole geometrical region defined by \var{domain}. 
\end{funcdesc}

\begin{funcdesc}{ContinuousFunction}{domain}
returns the \ContinuousFunction on the \Domain domain. \Data objects in this type of \Function
are defined over the whole geometrical region defined by \var{domain} and assumed to represent
a continuous function.
\end{funcdesc}

\begin{funcdesc}{FunctionOnBoundary}{domain}
returns the \ContinuousFunction on the \Domain domain. \Data objects in this type of \Function
are defined on the boundary of the geometrical region defined by \var{domain}. 
\end{funcdesc}

\begin{funcdesc}{FunctionOnContactZero}{domain}
returns the \FunctionOnContactZero the \Domain domain. \Data objects in this type of \Function
are defined on side 0 of a discontinutiy  within the geometrical region defined by \var{domain}.
The discontinutiy is defined when \var{domain} is instantiated.
\end{funcdesc}

\begin{funcdesc}{FunctionOnContactOne}{domain}
returns the \FunctionOnContactOne on the \Domain domain. 
\Data objects in this type of \Function
are defined on side 1 of a discontinutiy  within the geometrical region defined by \var{domain}.
The discontinutiy is defined when \var{domain} is instantiated.
\end{funcdesc}

\begin{funcdesc}{Solution}{domain}
returns the \SolutionFS on the \Domain domain. \Data objects in this type of \Function
are defined on geometrical region defined by \var{domain} and are solutions of
partial differential equations \index{partial differential equation}. 
\end{funcdesc}

\begin{funcdesc}{ReducedSolution}{domain}
returns the \ReducedSolutionFS on the \Domain domain. \Data objects in this type of \Function
are defined on geometrical region defined by \var{domain} and are solutions of
partial differential equations \index{partial differential equation} with a reduced smoothness 
for the solution approximation.
\end{funcdesc}

\section{\Data Class}
\label{SEC ESCRIPT DATA}

The following table shows binary and unitary operations that can be applied to
\Data objects:
\begin{tableii}{l|l}{textrm}{expression}{Description}
\lineii{+\var{arg1}} {just \var{arg} \index{+}}
\lineii{-\var{arg1}} {swapping the sign\index{-}}
\lineii{\var{arg1}+\var{arg2}} {adds \var{arg1} and \var{arg2} \index{+}}
\lineii{\var{arg1}*\var{arg2}} {multiplies \var{arg1} and \var{arg2} \index{*}}
\lineii{\var{arg1}-\var{arg2}} {difference \var{arg2} from\var{arg2} \index{-}}
\lineii{\var{arg1}/\var{arg2}} {ratio \var{arg1} by \var{arg2} \index{/}}
\lineii{\var{arg1}**\var{arg2}} {raises \var{arg1} to the power of \var{arg2} \index{**}}
\end{tableii}
At least one of the arguments \var{arg1} or \var{arg2} must be a
\Data object. One of the arguments may be an object that can be
converted into a \Data object. If \var{arg1} or \var{arg2} are
defined on different \FunctionSpace an attempt is made to embed \var{arg1}
into the \FunctionSpace of \var{arg2} or to embed \var{arg2} into
the \FunctionSpace of \var{arg1}. Boths arguments must have the same
\Shape or one of the arguments my be of rank 0 or \Shape (1,). In the
latter case it is assumed that the particular argument is of the same
\Shape as the other argument but constant over all components.

The returned \Data object has the same \Shape and is defined on
the \DataSamplePoints as \var{arg1} or \var{arg2}.

The following table shows the update operations that can be applied to
\Data objects:
\begin{tableii}{l|l}{textrm}{expression}{Description}
\lineii{\var{arg1}+=\var{arg2}} {adds \var{arg1} to \var{arg2} \index{+}}
\lineii{\var{arg1}*=\var{arg2}} {multiplies \var{arg1} with \var{arg2} \index{*}}
\lineii{\var{arg1}-=\var{arg2}} {subtracts \var{arg2} from\var{arg2} \index{-}}
\lineii{\var{arg1}/=\var{arg2}} {divides \var{arg1} by \var{arg2} \index{/}}
\end{tableii}
\var{arg1} must be a \Data object. \var{arg1} must be a
\Data object or an object that can be converted into a
\Data object. \var{arg1} must have the same \Shape like
\var{arg1} or has rank 0 or \Shape (1,).  In the latter case it is
assumed that the values of \var{arg1} are constant for all
components. \var{arg2} must be defined on the same \DataSamplePoints as
\var{arg1} or it must be possible to interpolate \var{arg2} onto the
\DataSamplePoints where \var{arg1} is held.

The \Data class supports getting slices as well as assigning new values to components in an existing
\Data object. \index{slicing}
The following expression for getting (expression on the right hand side of the
equal sign) and setting slices (expression on the left hand side of the
equal sign) are valid:
\begin{tableiii}{l|ll}{textrm}{rank of \var{arg}}{slicing expression}{\Shape of returned and assigned object}
\lineiii{0}{ no slicing }                      {-}
\lineiii{1}{\var{arg[l0:u0]}}                   {(\var{u0}-\var{l0},)}
\lineiii{2}{\var{arg[l0:u0,l1:u1]}}             {(\var{u0}-\var{l0},\var{u1}-\var{l1})}
\lineiii{3}{\var{arg[l0:u0,l1:u1,l2:u2]} }      {(\var{u0}-\var{l0},\var{u1}-\var{l1},\var{u2}-\var{l2})}
\lineiii{4}{\var{arg[l0:u0,l1:u1,l2:u2,l3:u3]}} {(\var{u0}-\var{l0},\var{u1}-\var{l1},\var{u2}-\var{l2},\var{u3}-\var{l3})}
\end{tableiii}
where 
$0 \le \var{l0} \le \var{u0} \le \var{s[0]}$,
$0 \le \var{l1} \le \var{u1} \le \var{s[1]}$, 
$0 \le \var{l2} \le \var{u2} \le \var{s[2]}$, 
$0 \le \var{l3} \le \var{u3} \le \var{s[3]}$ and \var{s} the \Shape if \var{arg}. 
Any of the lower indexes \var{l0}, \var{l1}, \var{l2} and \var{l3} may not be present in which case 
$0$ is assumed. 
Any of the upper indexes \var{u0}, \var{u1}, \var{u2} and \var{u3} may not be present in which case 
\var{s} is assumed. The lower and upper index may be identical, in which case the column and the lower or upper
index may be dropped. In the returned or in the object assigned to a slice the corresponding component is dropped,
i.e. the rank is reduced by one in comparison to \var{arg}.
The following examples show slicing usage:  
\begin{python}
t=Data(1.,(4,4,6,6),Function(mydomain))
t[1,1,1,0]=9.
s=t[:2,:,2:6,5] # s has rank 3
s[:,:,1]=1.
t[:2,:2,5,5]=s[2:4,1,:2]
\end{python}

\subsection{Generation of \Data class objects}
\begin{classdesc}{Data}{value=0,shape=(,),what=FunctionSpace(),expand=\False}
creates a \Data object with \Shape \var{shape} in the \FunctionSpace \var{what}.
The values at all \DataSamplePoints are set to the double value \var{value}. If \var{expanded} is \True
the \Data object is represented in expanded from.
\end{classdesc}

\begin{classdesc}{Data}{value,what=FunctionSpace(),expand=\False}
creates a \Data object in the \FunctionSpace \var{what}. 
The value for each \DataSamplePoints is set to \numarray, \Data object \var{value} or a dictionary of 
\numarray or floating point numbers. In the latter case the keys muts be integers and are used
as tags.
The \Shape of the returned object is equal to the \Shape of \var{value}. If \var{expanded} is \True
the \Data object is represented in expanded from.
\end{classdesc}

\begin{classdesc}{Data}{}
creates an \EmptyData object. The \EmptyData object is used to indicate that an argument is not present
where a \Data object is required.
\end{classdesc}

\begin{funcdesc}{Scalar}{value=0.,what=escript::FunctionSpace(),expand=\False}
returns a \Data object of rank 0 in the \FunctionSpace \var{what}.
Values are initialed with the double \var{value}. If \var{expanded} is \True
the \Data object is represented in expanded from.
\end{funcdesc}

\begin{funcdesc}{Vector}{value=0.,what=escript::FunctionSpace(),expand=\False}
returns a \Data object of \Shape \var{(d,)} in the \FunctionSpace \var{what} 
where \var{d} is the spatial dimension of the \Domain of \var{what}.
Values are initialed with the double \var{value}. If \var{expanded} is \True
the \Data object is represented in expanded from.
\end{funcdesc}

\begin{funcdesc}{Tensor}{value=0.,what=escript::FunctionSpace(),expand=\False}
returns a \Data object of \Shape \var{(d,d)} in the \FunctionSpace \var{what} 
where \var{d} is the spatial dimension of the \Domain of \var{what}.
Values are initialed with the double \var{value}. If \var{expanded} is \True
the \Data object is represented in expanded from.
\end{funcdesc}

\begin{funcdesc}{Tensor3}{value=0.,what=escript::FunctionSpace(),expand=\False}
returns a \Data object of \Shape \var{(d,d,d)} in the \FunctionSpace \var{what} 
where \var{d} is the spatial dimension of the \Domain of \var{what}.
Values are initialed with the double \var{value}. If \var{expanded} is \True
the \Data object is re\var{arg}presented in expanded from.
\end{funcdesc}

\begin{funcdesc}{Tensor4}{value=0.,what=escript::FunctionSpace(),expand=\False}
returns a \Data object of \Shape \var{(d,d,d,d)} in the \FunctionSpace \var{what} 
where \var{d} is the spatial dimension of the \Domain of \var{what}.
Values are initialed with the double \var{value}. If \var{expanded} is \True
the \Data object is represented in expanded from.
\end{funcdesc}

\subsection{\Data class methods}
This is a list of frequently used methods of the 
\Data class. A complete list can be fond on \ReferenceGuide.
\begin{methoddesc}[Data]{getFunctionSpace}{}
returns the \FunctionSpace of the object.
\end{methoddesc}

\begin{methoddesc}[Data]{getDomain}{}
returns the \Domain  of the object.
\end{methoddesc}

\begin{methoddesc}[Data]{getShape}{}
returns the \Shape  of the object as a \class{tuple} of
integers.
\end{methoddesc}

\begin{methoddesc}[Data]{getRank}{}
returns the rank of the data on each data point. \index{rank}
\end{methoddesc}

\begin{methoddesc}[Data]{isEmpty}{}
returns \True id the \Data object is the \EmptyData object.
Otherwise \False is returned.
\end{methoddesc}

\begin{methoddesc}[Data]{setTaggedValue}{tag,value}
assigns the \var{value} to all \DataSamplePoints which have the tag
\var{tag}. \var{value} must be an object of class
\class{numarray.NumArray} or must be convertible into a
\class{numarray.NumArray} object. \var{value} (or the corresponding
\class{numarray.NumArray} object) must be of rank $0$ or must have the
same rank like the object.
If a value has already be defined for tag \var{tag} within the object
it is overwritten by the new \var{value}.  If the object is expanded,
the value assigned to \DataSamplePoints with tag \var{tag} is replaced by
\var{value}.
\end{methoddesc}

\begin{methoddesc}[Data]{__str__}{}
returns a string representation of the object.
\end{methoddesc}

\section{Functions of \Data class objects}
This section lists the most important functions for \Data class objects \var{a}.
A complete list and a more detailed description of the functionality can be fond on \ReferenceGuide.
\begin{funcdesc}{saveVTK}{filename,\optional{domain},**data}
writes a 
\end{funcdesc}
\begin{funcdesc}{saveDX}{filename,domain=None,**data}
\end{funcdesc}
\begin{funcdesc}{kronecker}{d}
returns a \RankTwo \Data object \var{o} in \FunctionSpace \var{d} such that
\begin{equation}
o\left[ i,j\right] = \left\{ 
\begin{array}{cc}
1 & \mbox{ if } i=j \\
0 & \mbox{ otherwise }
\end{array}
\right.
\end{equation}
\end{funcdesc}

\begin{funcdesc}{identityTensor}{d}
\end{funcdesc}
\begin{funcdesc}{identityTensor4}{d}
\end{funcdesc}
\begin{funcdesc}{unitVector}{i,d}
\end{funcdesc}

\begin{funcdesc}{Lsup}{a}
returns the $L^{sup}$ norm of \var{arg}. This is the maximum of the absolute values
 over all components and all \DataSamplePoints of \var{a}. 
\end{funcdesc}

\begin{funcdesc}{sup}{a}
returns the maximum value over all components and all \DataSamplePoints of \var{a}.
\end{funcdesc}

\begin{funcdesc}{inf}{a}
returns the minimum value over all components and all \DataSamplePoints of \var{a}
\end{funcdesc}

\begin{funcdesc}{sin}{a}
applies sine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{cos}{a}
applies cosine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{tan}{a}
applies tangent function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{asin}{a}
applies arc (inverse) sine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{acos}{a}
applies arc (inverse) cosine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{atan}{a}
applies arc (inverse) tangent function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{sinh}{a}
applies hyperbolic sine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{cosh}{a}
applies hyperbolic cosine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{tanh}{a}
applies hyperbolic tangent function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{asinh}{a}
applies arc (inverse) hyperbolic sine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{acosh}{a}
applies arc (inverse) hyperbolic cosine function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{atanh}{a}
applies arc (inverse) hyperbolic tangent function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{exp}{a}
applies exponential function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{sqrt}{a}
applies square root function to \var{a}.
\end{funcdesc}

\begin{funcdesc}{log}{a}
\end{funcdesc}

\begin{funcdesc}{log10}{a}
\end{funcdesc}

\begin{funcdesc}{sign}{a}
\end{funcdesc}

\begin{funcdesc}{wherePositive}{a}
\end{funcdesc}
\begin{funcdesc}{whereNegative}{a}
\end{funcdesc}
\begin{funcdesc}{whereNonNegative}{a}
\end{funcdesc}
\begin{funcdesc}{whereNonPositive}{a}
\end{funcdesc}
\begin{funcdesc}{whereZero}{a,tol=0.}
\end{funcdesc}
\begin{funcdesc}{whereNonZero}{a,tol=0.}
\end{funcdesc}
\begin{funcdesc}{minval}{a}
\end{funcdesc}
\begin{funcdesc}{maxval}{a}
\end{funcdesc}
\begin{funcdesc}{length}{a}
\end{funcdesc}
\begin{funcdesc}{trace}{a,axis_offset=0}
\end{funcdesc}
\begin{funcdesc}{transpose}{a,axis_offset=None}
\end{funcdesc}
\begin{funcdesc}{symmetric}{a}
\end{funcdesc}
\begin{funcdesc}{nonsymmetric}{a}
\end{funcdesc}
\begin{funcdesc}{inverse}{a}
\end{funcdesc}
\begin{funcdesc}{eigenvalues}{a}
\end{funcdesc}
\begin{funcdesc}{eigenvalues_and_eigenvectors}{a}
\end{funcdesc}
\begin{funcdesc}{maximum}{a}
\end{funcdesc}
\begin{funcdesc}{minimum}{a}
\end{funcdesc}
\begin{funcdesc}{clip}{a,minval=0.,maxval=1.}
\end{funcdesc}
\begin{funcdesc}{inner}{a0,a1}
\end{funcdesc}
\begin{funcdesc}{matrixmult}{a0,a1}
\end{funcdesc}
\begin{funcdesc}{outer}{a0,a1}
\end{funcdesc}
\begin{funcdesc}{tensormult}{a0,a1}
\end{funcdesc}
\begin{funcdesc}{grad}{a,where=None}
\end{funcdesc}
\begin{funcdesc}{integrate}{a,where=None}
\end{funcdesc}
\begin{funcdesc}{interpolate}{a,where}
\end{funcdesc}
\begin{funcdesc}{div}{a,where=None}
\end{funcdesc}
\begin{funcdesc}{jump}{a,domain=None}
\end{funcdesc}
\begin{funcdesc}{L2}{a}
\end{funcdesc}

====


\begin{funcdesc}{wherePositive}{a}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is positive and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{wherePositive}{a}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is non-positive and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{whereNonnegative}{a}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is non-negative and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{whereNegative}{a}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is negative and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{whereZero}{a,tol=1.e-8}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is nearly zero, i.e. where the absolute value is less
than \var{tolerance}, and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{whereNonzero}{tolerance=1.e-8}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is nearly non-zero, i.e. where the absolute value is
greater or equal than \var{tolerance}, and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{sign}{a}
returns \Data object which has the same \Shape and is defined on
the same \FunctionSpace like the object. The returned values are $1$
where the object is positive, $-1$ where the value is negative and $0$ elsewhere.
\end{funcdesc}

\begin{funcdesc}{Lsup}{a}
returns the $L^{sup}$-norm of the object. This is maximum absolute values over all components and all \DataSamplePoints. \index{$L^{sup}$-norm}.
\end{funcdesc}
\begin{funcdesc}{Linf}{a}
returns the minimum absolute value over all components and all \DataSamplePoints. \index{$L^{inf}$-norm}.
\end{funcdesc}
\begin{funcdesc}{inf}{a}
returns the minimum value (infimum) of the object. The minimum is
taken over all components and all \DataSamplePoints .  \index{infimum}
\end{funcdesc}

\begin{funcdesc}{sup}{a}
returns the maximum value (supremum) of the object. The maximum is
taken over all components and all \DataSamplePoints .  \index{supremum}
\end{funcdesc}

\begin{funcdesc}{grad}{a,\optional{where}}
returns the gradient of the function represented by the object.
\Data object is in \FunctionSpace \var{on} and has rank r+1 where r is the rank of the object.
If \var{on} is not present, a suitbale \FunctionSpace is used. 
\index{gradient}
\end{funcdesc}

\begin{funcdesc}{integrate}{a,\optional{where}}
returns the integral of the function represented by the object. The method returns
a \class{numarray.NumArray} object of the same \Shape like the object.  A
component of the returned object is the integral of the corresponding
component of the object. \index{integral}
\end{funcdesc}

\begin{funcdesc}{interpolate}{a,where}
interpolates 
the function represented by the object
into the \FunctionSpace\var{where}.
\index{interpolation}
\end{funcdesc}

\begin{funcdesc}{abs}{a} 
applies the absolute value function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the exponential
function. \index{function!absolute value}
\end{funcdesc}

\begin{funcdesc}{exp}{a} 
applies the exponential function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the exponential
function. \index{function!exponential}
\end{funcdesc}

\begin{funcdesc}{sqrt}{a}
applies the square root function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the square root function. 
An exception is
raised if the value is negative.  \index{function!square root}
\end{funcdesc}

\begin{funcdesc}{sin}{a}
applies the sine function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the sine function. \index{function!sine}
\end{funcdesc}

\begin{funcdesc}{cos}{a}
applies the cosine function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the cosine function. \index{function!cosine}
\end{funcdesc}

\begin{funcdesc}{tan}{a}
applies the tangent function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the tangent function. \index{function!tangent}
\end{funcdesc}

\begin{funcdesc}{log}{a}
applies the logarithmic function to the object. The
return \Data object has the same \Shape and is in the same
\FunctionSpace like the object. For all \DataSamplePoints and all
components the value is calculated by applying the logarithmic function. An exception is
raised if the value is negative.\index{function!logarithmic}
\end{funcdesc}

\begin{funcdesc}{maxval}{}
returns the maximum value over all components. The
return value is a \Data object of rank 0 
and is in the same
\FunctionSpace like the object. For all \DataSamplePoints
the value is calculated as the maximum value over all components. \index{function!maximum}
\end{funcdesc}

\begin{funcdesc}{minval}{}
returns the minimum value over all components. The
return value is a \Data object of rank 0 
and is in the same
\FunctionSpace like the object. For all \DataSamplePoints
the value is calculated as the minimum value over all components. \index{function!minimum}
\end{funcdesc}

\begin{funcdesc}{length}{}
returns the Euclidean length at all \DataSamplePoints. The
return value is a \Data object of rank 0 
and is in the same
\FunctionSpace like the object. For all \DataSamplePoints
the value is calculated as the square root of the sum of the square over all over all components. \index{function!length}
\end{funcdesc}
\begin{funcdesc}{transpose}{axis}
returns the transpose of the object around \var{axis}. \var{axis} is a non-negative integer
which is less the rank $r$ of the object. Transpose swaps the indexes $0$ to \var{axis}
with the indexes \var{axis}+1 to $r$. If the \var{d} is \RankFour one has 
\begin{python}
d[i,j,k,l]=d.transpose(0)[i,j,k,l]
d[i,j,k,l]=d.transpose(1)[j,k,l,i]
d[i,j,k,l]=d.transpose(2)[k,l,i,j]
d[i,j,k,l]=d.transpose(3)[l,i,j,k]
\end{python}
\index{function!transpose}
\end{funcdesc}

\begin{funcdesc}{trace}{}
returns sum of the components with identical indexes. 
The
return value is a \Data object of rank 0 
and is in the same
\FunctionSpace like the object.
\index{function!trace}
\end{funcdesc}
\begin{funcdesc}{saveDX}{fileName}
saves the object to an openDX format file of name \var{fileName}, see
\ulink{www.opendx.org}{\url{www.opendx.org}}.  \index{openDX}
\end{funcdesc}


\begin{funcdesc}{abs}{arg} 
returns the absolute value of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{sin}{arg}
returns the sine of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{cos}{arg}
returns the cosine of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{exp}{arg}
returns the value of the exponential function for \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{sqrt}{arg}
returns the square root of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{maxval}{arg}
returns the maximum value over all component of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{minval}{arg}
returns the minumum value over all component of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{length}{arg}
returns the length of \var{arg} which is the
square root of the sum of the squares of all component of \var{arg}. \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{sign}{arg}
return the sign of \var{arg} where \var{arg}
can be double, a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{transpose}{arg,\optional{axis}}
returns the transpose of \var{arg} around \var{axis}. \var{axis} is a non-negative integer
which is less the rank $r$ of the object. Transpose swaps the indexes $0$ to \var{axis}
with the indexes \var{axis}+1 to $r$. If \var{axis} is not present, \var{axis}=$r/2$ is assumed.
\var{arg}
may be a \Data object or an \numarray object.
\end{funcdesc}

\begin{funcdesc}{transpose}{arg,\optional{axis}}
returns the trace the object of \var{arg}. The trace is the sum over those components
with identical indexed. 
\var{arg}
may be a \Data object or a \numarray object.
\end{funcdesc}

\begin{funcdesc}{sum}{arg}
returns the sum over all components and all 
\DataSamplePoints of \var{arg}, where \var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{sup}{arg}
returns the maximum over all components and all 
\DataSamplePoints of \var{arg}, where \var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{inf}{arg}
returns the mimumum over all components and all 
\DataSamplePoints of \var{arg}, where \var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{L2}{arg}
returns the $L^2$ norm of \var{arg}. This is the square root 
of the sum of the squared value over all components and all 
\DataSamplePoints of \var{arg}, where \var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{Lsup}{arg}
returns the $L^{sup}$ norm of \var{arg}. This is the maximum of the absolute values
 over all components and all 
\DataSamplePoints of \var{arg}, where \var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{dot}{arg1,arg2}
returns the dot product of of \var{arg1} and \var{arg2}. This is sum
of the product of corresponding entries in \var{arg1} and \var{arg2} over all
components and and all 
\DataSamplePoints. \var{arg1} and \var{arg2} are \Data objects of the
same \Shape and in the same \FunctionSpace.
\end{funcdesc}

\begin{funcdesc}{grad}{arg,\optional{where}}
returns the gradient of \var{arg} as a function in the \FunctionSpace \var{where}.
If \var{where} is not present a reasonable \FunctionSpace is chosen.
\var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{integrate}{arg}
returns the integral of \var{arg} as a \numarray object.
If \var{where} is not present a reasonable \FunctionSpace is chosen.
\var{arg}
is a \Data object. 
\end{funcdesc}

\begin{funcdesc}{interpolate}{arg,where}
interpolate \Data object \var{arg} into the \FunctionSpace \var{where}
\end{funcdesc}


\section{\Operator Class}

The \Operator class provides an abstract access to operators build
within the \LinearPDE class. \Operator objects are created 
when a PDE is handed over to a PDE solver library and handled
by the \LinearPDE class defining the PDE. The user can gain access
to the \Operator of a \LinearPDE object through the \var{getOperator}
method.

\begin{classdesc}{Operator}{}
creates an empty \Operator object.
\end{classdesc}

\begin{methoddesc}[Operator]{isEmpty}{fileName}
returns \True is the object is empty. Otherwise \True is returned.
\end{methoddesc}

\begin{methoddesc}[Operator]{setValue}{value}
resets all entires in the obeject representation to \var{value}
\end{methoddesc}

\begin{methoddesc}[Operator]{solves}{rhs}
solves the operator equation with right hand side \var{rhs}
\end{methoddesc}

\begin{methoddesc}[Operator]{of}{u}
applies the operator to the \Data object \var{u}
\end{methoddesc}

\begin{methoddesc}[Operator]{saveMM}{fileName}
saves the object to a matrix market format file of name
\var{fileName}, see
\ulink{maths.nist.gov/MatrixMarket}{\url{http://maths.nist.gov/MatrixMarket}}.
\index{Matrix Market}
\end{methoddesc}

