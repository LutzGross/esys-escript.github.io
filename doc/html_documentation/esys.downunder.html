
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>esys.downunder Package &#8212; esys.escript 5.5 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="esys.downunder.dcresistivityforwardmodeling Package" href="esys.downunder.dcresistivityforwardmodeling.html" />
    <link rel="prev" title="Documentation for esys.escript" href="index.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="esys.downunder.dcresistivityforwardmodeling.html" title="esys.downunder.dcresistivityforwardmodeling Package"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Documentation for esys.escript"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">esys.escript 5.5 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-esys.downunder">
<span id="esys-downunder-package"></span><h1>esys.downunder Package<a class="headerlink" href="#module-esys.downunder" title="Permalink to this headline">¶</a></h1>
<p>Data inversion module built on escript</p>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#esys.downunder.AbstractMinimizer" title="esys.downunder.AbstractMinimizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AbstractMinimizer</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.AcousticVelocityMapping" title="esys.downunder.AcousticVelocityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AcousticVelocityMapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.AcousticWaveForm" title="esys.downunder.AcousticWaveForm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AcousticWaveForm</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.ArithmeticTuple" title="esys.downunder.ArithmeticTuple"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ArithmeticTuple</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.BoundedRangeMapping" title="esys.downunder.BoundedRangeMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BoundedRangeMapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.CartesianReferenceSystem" title="esys.downunder.CartesianReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CartesianReferenceSystem</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.DataSource" title="esys.downunder.DataSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.DcRes" title="esys.downunder.DcRes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DcRes</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.DcResistivityForward" title="esys.downunder.DcResistivityForward"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DcResistivityForward</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.DipoleDipoleSurvey" title="esys.downunder.DipoleDipoleSurvey"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DipoleDipoleSurvey</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.ErMapperData" title="esys.downunder.ErMapperData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ErMapperData</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.ForwardModel" title="esys.downunder.ForwardModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForwardModel</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.ForwardModelWithPotential" title="esys.downunder.ForwardModelWithPotential"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForwardModelWithPotential</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.FunctionJob" title="esys.downunder.FunctionJob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionJob</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.GeodeticCoordinateTransformation" title="esys.downunder.GeodeticCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeodeticCoordinateTransformation</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.GeodeticReferenceSystem" title="esys.downunder.GeodeticReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeodeticReferenceSystem</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.GravityInversion" title="esys.downunder.GravityInversion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GravityInversion</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.GravityModel" title="esys.downunder.GravityModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GravityModel</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.HTIWave" title="esys.downunder.HTIWave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">HTIWave</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.InversionCostFunction" title="esys.downunder.InversionCostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InversionCostFunction</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.InversionDriver" title="esys.downunder.InversionDriver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InversionDriver</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.IsostaticPressure" title="esys.downunder.IsostaticPressure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IsostaticPressure</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.Job" title="esys.downunder.Job"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Job</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.JointGravityMagneticInversion" title="esys.downunder.JointGravityMagneticInversion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">JointGravityMagneticInversion</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.LinearMapping" title="esys.downunder.LinearMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearMapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.Locator" title="esys.downunder.Locator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Locator</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MT2DModelTEMode" title="esys.downunder.MT2DModelTEMode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MT2DModelTEMode</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MT2DModelTMMode" title="esys.downunder.MT2DModelTMMode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MT2DModelTMMode</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MTMapping" title="esys.downunder.MTMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MTMapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MagneticIntensityModel" title="esys.downunder.MagneticIntensityModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MagneticIntensityModel</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MagneticInversion" title="esys.downunder.MagneticInversion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MagneticInversion</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MagneticModel" title="esys.downunder.MagneticModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MagneticModel</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.Mapping" title="esys.downunder.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MeteredCostFunction" title="esys.downunder.MeteredCostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeteredCostFunction</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MinimizerException" title="esys.downunder.MinimizerException"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerException</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MinimizerIterationIncurableBreakDown" title="esys.downunder.MinimizerIterationIncurableBreakDown"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerIterationIncurableBreakDown</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MinimizerLBFGS" title="esys.downunder.MinimizerLBFGS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerLBFGS</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MinimizerMaxIterReached" title="esys.downunder.MinimizerMaxIterReached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerMaxIterReached</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.MinimizerNLCG" title="esys.downunder.MinimizerNLCG"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerNLCG</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.NetCdfData" title="esys.downunder.NetCdfData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NetCdfData</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.NumpyData" title="esys.downunder.NumpyData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NumpyData</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.PoleDipoleSurvey" title="esys.downunder.PoleDipoleSurvey"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PoleDipoleSurvey</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.PolePoleSurvey" title="esys.downunder.PolePoleSurvey"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PolePoleSurvey</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.Ricker" title="esys.downunder.Ricker"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Ricker</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SchlumbergerSurvey" title="esys.downunder.SchlumbergerSurvey"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SchlumbergerSurvey</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SeismicSource" title="esys.downunder.SeismicSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SeismicSource</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SelfDemagnetizationModel" title="esys.downunder.SelfDemagnetizationModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SelfDemagnetizationModel</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SimpleSEGYWriter" title="esys.downunder.SimpleSEGYWriter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimpleSEGYWriter</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SmoothAnomaly" title="esys.downunder.SmoothAnomaly"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SmoothAnomaly</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SonicHTIWave" title="esys.downunder.SonicHTIWave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SonicHTIWave</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SonicWave" title="esys.downunder.SonicWave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SonicWave</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SplitInversionCostFunction" title="esys.downunder.SplitInversionCostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitInversionCostFunction</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SplitMinimizerLBFGS" title="esys.downunder.SplitMinimizerLBFGS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitMinimizerLBFGS</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SplitRegularization" title="esys.downunder.SplitRegularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitRegularization</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.StrongJointGravityMagneticInversion" title="esys.downunder.StrongJointGravityMagneticInversion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StrongJointGravityMagneticInversion</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.Subsidence" title="esys.downunder.Subsidence"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Subsidence</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SyntheticData" title="esys.downunder.SyntheticData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SyntheticData</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SyntheticDataBase" title="esys.downunder.SyntheticDataBase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SyntheticDataBase</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.SyntheticFeatureData" title="esys.downunder.SyntheticFeatureData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SyntheticFeatureData</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.TTIWave" title="esys.downunder.TTIWave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TTIWave</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.VTIWave" title="esys.downunder.VTIWave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VTIWave</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.WaveBase" title="esys.downunder.WaveBase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WaveBase</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.WennerSurvey" title="esys.downunder.WennerSurvey"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WennerSurvey</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.xrange" title="esys.downunder.xrange"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrange</span></code></a></li>
</ul>
<dl class="class">
<dt id="esys.downunder.AbstractMinimizer">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">AbstractMinimizer</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for function minimization methods.</p>
<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a new minimizer for a given cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</li>
<li><strong>m_tol</strong> (<em>float</em>) – terminate interations when relative change of the level set 
function is less than or equal m_tol</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>return the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.getOptions">
<code class="descname">getOptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.getOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of minimizer-specific options.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.getResult">
<code class="descname">getResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.getResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of the minimization.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.logSummary">
<code class="descname">logSummary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.logSummary" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a summary of the completed minimization process to the logger.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>x0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the minimization algorithm for <em>f</em> starting with the initial
guess <code class="docutils literal notranslate"><span class="pre">x0</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the result of the minimization</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.setCallback">
<code class="descname">setCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.setCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a callback function to be called after every iteration.
It is up to the specific implementation what arguments are passed
to the callback. Subclasses should at least pass the current
iteration number k, the current estimate x, and possibly f(x),
grad f(x), and the current error.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>J</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>set the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.setMaxIterations">
<code class="descname">setMaxIterations</code><span class="sig-paren">(</span><em>imax</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.setMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of iterations before the minimizer terminates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.setOptions">
<code class="descname">setOptions</code><span class="sig-paren">(</span><em>**opts</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.setOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets minimizer-specific options. For a list of possible options see
<a class="reference internal" href="#esys.downunder.AbstractMinimizer.getOptions" title="esys.downunder.AbstractMinimizer.getOptions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getOptions()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AbstractMinimizer.setTolerance">
<code class="descname">setTolerance</code><span class="sig-paren">(</span><em>m_tol=0.0001</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AbstractMinimizer.setTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the tolerance for the stopping criterion. The minimizer stops
when an appropriate norm is less than <code class="xref py py-obj docutils literal notranslate"><span class="pre">m_tol</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.AcousticVelocityMapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">AcousticVelocityMapping</code><span class="sig-paren">(</span><em>V_prior</em>, <em>Q_prior</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticVelocityMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.mappings.Mapping</span></code></p>
<p>Maps a p-velocity and Q-index to slowness square sigma=(V*(1-i*1/(2*Q))^{-2}
in the form sigma=e^{Mr+m[0])}*( cos(Mi+m[1])) + i * sin(Mi+m[1])</p>
<dl class="method">
<dt id="esys.downunder.AcousticVelocityMapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>V_prior</em>, <em>Q_prior</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticVelocityMapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the mapping</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>V_prior</strong> – a-priori p-wave velocity</li>
<li><strong>Q_prior</strong> – a-priori Q-index (must be positive)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticVelocityMapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticVelocityMapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticVelocityMapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticVelocityMapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for s</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticVelocityMapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticVelocityMapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticVelocityMapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticVelocityMapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.AcousticWaveForm">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">AcousticWaveForm</code><span class="sig-paren">(</span><em>domain</em>, <em>omega</em>, <em>w</em>, <em>data</em>, <em>F</em>, <em>coordinates=None</em>, <em>fixAtBottom=False</em>, <em>tol=1e-10</em>, <em>saveMemory=True</em>, <em>scaleF=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModel" title="esys.downunder.forwardmodels.base.ForwardModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModel</span></code></a></p>
<p>Forward Model for acoustic waveform inversion in the frequency domain.
It defines a cost function:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Math:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">defect</span> <span class="pre">=</span> <span class="pre">1/2</span> <span class="pre">integrate(</span> <span class="pre">(</span> <span class="pre">w</span> <span class="pre">*</span> <span class="pre">(</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">u</span> <span class="pre">-</span> <span class="pre">data</span> <span class="pre">)</span> <span class="pre">)</span> <span class="pre">**</span> <span class="pre">2</span> <span class="pre">)</span></code></td>
</tr>
</tbody>
</table>
<p>where w are weighting factors, data are the measured data (as a 2-comp
vector of real and imaginary part) for real frequency omega, and u is
the corresponding result produced by the forward model.
u (as a 2-comp vector) is the solution of the complex Helmholtz equation
for frequency omega, source F and complex, inverse, squared p-velocity
sigma:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Math:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">-u_{ii}</span> <span class="pre">-</span> <span class="pre">omega**2</span> <span class="pre">*</span> <span class="pre">sigma</span> <span class="pre">*</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">F</span></code></td>
</tr>
</tbody>
</table>
<p>It is assumed that the exact scale of source F is unknown and the scaling
factor a of F is calculated by minimizing the defect.</p>
<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>omega</em>, <em>w</em>, <em>data</em>, <em>F</em>, <em>coordinates=None</em>, <em>fixAtBottom=False</em>, <em>tol=1e-10</em>, <em>saveMemory=True</em>, <em>scaleF=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a new forward model with acoustic wave form inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – weighting factors</li>
<li><strong>data</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – real and imaginary part of data</li>
<li><strong>F</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – real and imaginary part of source given at Dirac points,
on surface or at volume.</li>
<li><strong>coordinates</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a> or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used (not supported yet)</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
<li><strong>saveMemory</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true stiffness matrix is deleted after solution
of PDE to minimize memory requests. This will
require more compute time as the matrix needs to be
reallocated.</li>
<li><strong>scaleF</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true source F is scaled to minimize defect.</li>
<li><strong>fixAtBottom</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true pressure is fixed to zero at the bottom of
the domain</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.AcousticWaveForm.getDefect" title="esys.downunder.AcousticWaveForm.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.AcousticWaveForm.getGradient" title="esys.downunder.AcousticWaveForm.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – a suggestion for complex 1/V**2</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">solution,  uTar, uTai, uTu</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,), 3 x <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>sigma</em>, <em>u</em>, <em>uTar</em>, <em>uTai</em>, <em>uTu</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the defect value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – a suggestion for complex 1/V**2</li>
<li><strong>u</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – a u vector</li>
<li><strong>uTar</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate(</span> <span class="pre">w</span>&#160; <span class="pre">*</span> <span class="pre">(data[0]*u[0]+data[1]*u[1]))</span></code></li>
<li><strong>uTai</strong> – equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate(</span> <span class="pre">w</span>&#160; <span class="pre">*</span> <span class="pre">(data[1]*u[0]-data[0]*u[1]))</span></code></li>
<li><strong>uTu</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate(</span> <span class="pre">w</span>&#160; <span class="pre">*</span> <span class="pre">(u,u))</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>sigma</em>, <em>u</em>, <em>uTar</em>, <em>uTai</em>, <em>uTu</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – a suggestion for complex 1/V**2</li>
<li><strong>u</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – a u vector</li>
<li><strong>uTar</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate(</span> <span class="pre">w</span>&#160; <span class="pre">*</span> <span class="pre">(data[0]*u[0]+data[1]*u[1]))</span></code></li>
<li><strong>uTai</strong> – equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate(</span> <span class="pre">w</span>&#160; <span class="pre">*</span> <span class="pre">(data[1]*u[0]-data[0]*u[1]))</span></code></li>
<li><strong>uTu</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate(</span> <span class="pre">w</span>&#160; <span class="pre">*</span> <span class="pre">(u,u))</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getSourceScaling">
<code class="descname">getSourceScaling</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getSourceScaling" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the scaling factor s required to rescale source F to minimize defect <code class="docutils literal notranslate"><span class="pre">|s</span> <span class="pre">*</span> <span class="pre">u-</span> <span class="pre">data|^2</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong> (<code class="docutils literal notranslate"><span class="pre">escript.Data</span></code> of shape (2,)) – value of pressure solution (real and imaginary part)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.getSurvey">
<code class="descname">getSurvey</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.getSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair (data, weight)</p>
<p>If argument index is ignored.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.rescaleWeights">
<code class="descname">rescaleWeights</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>sigma_scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.rescaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>rescales the weights such that</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Math:</th><td class="field-body"><p class="first">integrate( ( w omega**2 * sigma_scale * data * ((1/L_j)**2)**-1) +1 )/(data*omega**2 * ((1/L_j)**2)**-1) * sigma_scale )=scale</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – scale of data weighting factors</li>
<li><strong>sigma_scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – scale of 1/vp**2 velocity.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.AcousticWaveForm.setUpPDE">
<code class="descname">setUpPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.AcousticWaveForm.setUpPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and returns the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lpde.LinearPDE</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.ArithmeticTuple">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">ArithmeticTuple</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ArithmeticTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Tuple supporting inplace update x+=y and scaling x=a*y where <code class="docutils literal notranslate"><span class="pre">x,y</span></code> is an
ArithmeticTuple and <code class="docutils literal notranslate"><span class="pre">a</span></code> is a float.</p>
<p>Example of usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">esys.escript</span> <span class="k">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
<span class="n">a</span><span class="o">=</span><span class="n">eData</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">b</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span>
<span class="n">x</span><span class="o">=</span><span class="n">ArithmeticTuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">y</span><span class="o">=</span><span class="mf">5.</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<dl class="method">
<dt id="esys.downunder.ArithmeticTuple.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ArithmeticTuple.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes object with elements <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> – tuple of objects that support inplace add (x+=y) and
scaling (x=a*y)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.BoundedRangeMapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">BoundedRangeMapping</code><span class="sig-paren">(</span><em>s_min=0</em>, <em>s_max=1</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.BoundedRangeMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.mappings.Mapping</span></code></p>
<p>Maps an unbounded parameter to a bounded range. The mapping is smooth and
continuous.</p>
<dl class="method">
<dt id="esys.downunder.BoundedRangeMapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>s_min=0</em>, <em>s_max=1</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.BoundedRangeMapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.BoundedRangeMapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.BoundedRangeMapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.BoundedRangeMapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.BoundedRangeMapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for s</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.BoundedRangeMapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.BoundedRangeMapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.BoundedRangeMapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.BoundedRangeMapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.CartesianReferenceSystem">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">CartesianReferenceSystem</code><span class="sig-paren">(</span><em>name='CARTESIAN'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.coordinates.ReferenceSystem</span></code></p>
<p>Identifies the Cartesian coordinate system</p>
<dl class="method">
<dt id="esys.downunder.CartesianReferenceSystem.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name='CARTESIAN'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianReferenceSystem.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>set up Cartesian coordinate system</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CartesianReferenceSystem.createTransformation">
<code class="descname">createTransformation</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianReferenceSystem.createTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an appropriate coordinate transformation on a given domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code>) – domain of transformation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CartesianReferenceSystem.getName">
<code class="descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianReferenceSystem.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the name of the reference system</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CartesianReferenceSystem.isCartesian">
<code class="descname">isCartesian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianReferenceSystem.isCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>returns if the reference system is Cartesian</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CartesianReferenceSystem.isTheSame">
<code class="descname">isTheSame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianReferenceSystem.isTheSame" title="Permalink to this definition">¶</a></dt>
<dd><p>test if argument <code class="docutils literal notranslate"><span class="pre">other</span></code> defines the same reference system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – a second reference system</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">other</span></code> is a <a class="reference internal" href="#esys.downunder.CartesianReferenceSystem" title="esys.downunder.CartesianReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CartesianReferenceSystem</span></code></a> instance.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">every two <a class="reference internal" href="#esys.downunder.CartesianReferenceSystem" title="esys.downunder.CartesianReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CartesianReferenceSystem</span></code></a> instances are considered
as being the same.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.CostFunction">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">CostFunction</code><a class="headerlink" href="#esys.downunder.CostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A function <em>f(x)</em> that can be minimized (base class).</p>
<p>Example of usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cf</span><span class="o">=</span><span class="n">DerivedCostFunction</span><span class="p">()</span>
<span class="c1"># ... calculate x ...</span>
<span class="n">args</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">getArguments</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1"># this could be potentially expensive!</span>
<span class="n">f</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">getValue</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="c1"># ... it could be required to update x without using the gradient...</span>
<span class="c1"># ... but then ...</span>
<span class="n">gf</span><span class="o">=</span><span class="n">cf</span><span class="o">.</span><span class="n">getGradient</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>The class distinguishes between the representation of the solution
x (x-type) and the gradients (r-type).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">The provides_inverse_Hessian_approximation class member should be set to <code class="docutils literal notranslate"><span class="pre">True</span></code> in subclasses that provide a valid implementation of
<a class="reference internal" href="#esys.downunder.CostFunction.getInverseHessianApproximation" title="esys.downunder.CostFunction.getInverseHessianApproximation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getInverseHessianApproximation()</span></code></a></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.CostFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor. Initializes logger.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>returns precalculated values that are shared in the calculation of
<em>f(x)</em> and <em>grad f(x)</em> and the Hessian operator. The default
implementation returns an empty tuple.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tuple returned by this call will be passed back to this <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a> in other
calls(eg: <a class="reference internal" href="#esys.downunder.CostFunction.getGradient" title="esys.downunder.CostFunction.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient</span></code></a>). Its contents are not specified at this level because no code, 
other than the <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>
which created it, will be interacting with it.
That is, the implementor can put whatever information they find useful in it.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – location of derivative</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>x</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.CostFunction.getArguments" title="esys.downunder.CostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.CostFunction.getArguments" title="esys.downunder.CostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">x-type</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"><p class="first">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculated in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">Subclasses that implement this method should set the class
variable <a class="reference internal" href="#esys.downunder.CostFunction.provides_inverse_Hessian_approximation" title="esys.downunder.CostFunction.provides_inverse_Hessian_approximation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">provides_inverse_Hessian_approximation</span></code></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code> to
enable the solver to call this method.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value <em>f(x)</em> using the precalculated values for <em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – a solution approximation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.CostFunction.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = False</em><a class="headerlink" href="#esys.downunder.CostFunction.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.CostFunction.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CostFunction.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class that the Hessian operator needs to be updated.
This method is called by the solver class.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.DataSource">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">DataSource</code><span class="sig-paren">(</span><em>reference_system=None</em>, <em>tags=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A class that provides survey data for the inversion process.
This is an abstract base class that implements common functionality.
Methods to be overwritten by subclasses are marked as such.
This class assumes 2D data which is mapped to a slice of a 3D domain.
For other setups override the methods as required.</p>
<dl class="method">
<dt id="esys.downunder.DataSource.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>reference_system=None</em>, <em>tags=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor. Sets some defaults and initializes logger.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tags</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of almost any type (typically <code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>)) – a list of tags associated with the data set.</li>
<li><strong>reference_system</strong> (<code class="docutils literal notranslate"><span class="pre">None</span></code> or <a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – the reference coordinate system</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.DataSource.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.DataSource.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.DataSource.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.DataSource.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.DataSource.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.DataSource.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.DataSource.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.DataSource.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a tuple of tuples <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">(x0,</span> <span class="pre">y0),</span> <span class="pre">(nx,</span> <span class="pre">ny),</span> <span class="pre">(dx,</span> <span class="pre">dy)</span> <span class="pre">)</span></code>, where</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">y0</span></code> = coordinates of data origin</li>
<li><code class="docutils literal notranslate"><span class="pre">nx</span></code>, <code class="docutils literal notranslate"><span class="pre">ny</span></code> = number of data points in x and y</li>
<li><code class="docutils literal notranslate"><span class="pre">dx</span></code>, <code class="docutils literal notranslate"><span class="pre">dy</span></code> = spacing of data points in x and y</li>
</ul>
<p>This method must be implemented in subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of survey data managed by this source.
Subclasses must return <a class="reference internal" href="#esys.downunder.DataSource.GRAVITY" title="esys.downunder.DataSource.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GRAVITY</span></code></a> or <a class="reference internal" href="#esys.downunder.DataSource.MAGNETIC" title="esys.downunder.DataSource.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAGNETIC</span></code></a> or <a class="reference internal" href="#esys.downunder.DataSource.ACOUSTIC" title="esys.downunder.DataSource.ACOUSTIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ACOUSTIC</span></code></a> as appropriate.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.DataSource.setSubsamplingFactor" title="esys.downunder.DataSource.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>NE</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called by the <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a> to retrieve the survey
data as <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects on the given domain.</p>
<p>Subclasses should return one or more <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects with survey data
interpolated on the given <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript</span></code> domain. The exact return type
depends on the type of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<a class="reference internal" href="esys.escript.html#esys.escript.Domain" title="esys.escript.Domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Domain</span></code></a>) – the escript domain to use</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the origin coordinates of the domain</li>
<li><strong>NE</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the number of domain elements in each dimension</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the cell sizes (node spacing) in the domain</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>All data source coordinates are converted to UTM (Universal Transverse
Mercator) in order to have useful domain extents. Subclasses should
implement this method and return the UTM zone number of the projected
coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DataSource.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DataSource.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.DcRes">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">DcRes</code><span class="sig-paren">(</span><em>domain</em>, <em>locator</em>, <em>delphiIn</em>, <em>sampleTags</em>, <em>phiPrimary</em>, <em>sigmaPrimary</em>, <em>w=1.0</em>, <em>coordinates=None</em>, <em>tol=1e-08</em>, <em>saveMemory=True</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModel" title="esys.downunder.forwardmodels.base.ForwardModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModel</span></code></a></p>
<p>Forward Model for DC resistivity, with a given source pair.
The cost function is defined as:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Math:</th><td class="field-body">defect = 1/2 (sum_s sum_pq w_pqs * ((phi_sp-phi_sq)-v_pqs)**2</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.DcRes.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>locator</em>, <em>delphiIn</em>, <em>sampleTags</em>, <em>phiPrimary</em>, <em>sigmaPrimary</em>, <em>w=1.0</em>, <em>coordinates=None</em>, <em>tol=1e-08</em>, <em>saveMemory=True</em>, <em>b=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>setup new forward model</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> – the domain of the model</li>
<li><strong>locator</strong> – contains locator to the measurement pairs</li>
<li><strong>sampleTags</strong> (<em>list of tuples</em>) – tags of measurement points from which potential
differences will be calculated.</li>
<li><strong>phiPrimary</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – primary potential.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Type:</th><td class="field-body"><p class="first">escript domain</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body"><p class="first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Locator</span></code></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Param:</th><td class="field-body"><p class="first last">delphiIn: this is v_pq, the potential difference for the
current source and a set of measurement pairs.
A list of measured potential differences is expected.
Note this should be the secondary potential only.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.DcRes.getDefect" title="esys.downunder.DcRes.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.DcRes.getGradient" title="esys.downunder.DcRes.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (1,)) – conductivity</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">phi</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (1,)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>sigma</em>, <em>phi</em>, <em>loc_phi</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the defect value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (1,)) – a suggestion for conductivity</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (1,)) – potential field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>sigma</em>, <em>phi</em>, <em>loc_phi</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (1,)) – a suggestison for conductivity</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (1,)) – potential field</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.getPrimaryPotential">
<code class="descname">getPrimaryPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.getPrimaryPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the primary potential
:rtype: <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcRes.setUpPDE">
<code class="descname">setUpPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcRes.setUpPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.DcResistivityForward">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">DcResistivityForward</code><a class="headerlink" href="#esys.downunder.DcResistivityForward" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class allows for the solution of dc resistivity forward problems via
the calculation of a primary and secondary potential. Conductivity values
are to be provided for the primary problem which is a homogeneous half space
of a chosen conductivity and for the secondary problem which typically 
varies it conductivity spatially across the domain. The primary potential
acts as a reference point typically based of some know reference conductivity
however any value will suffice. The primary potential is implemented to 
avoid the use of dirac delta functions.</p>
<dl class="method">
<dt id="esys.downunder.DcResistivityForward.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcResistivityForward.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a skeleton class for all the other forward modeling classes.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcResistivityForward.checkBounds">
<code class="descname">checkBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcResistivityForward.checkBounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DcResistivityForward.getApparentResistivity">
<code class="descname">getApparentResistivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcResistivityForward.getApparentResistivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DcResistivityForward.getElectrodes">
<code class="descname">getElectrodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcResistivityForward.getElectrodes" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the list of electrodes with locations</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DcResistivityForward.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DcResistivityForward.getPotential" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.DensityMapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">DensityMapping</code><span class="sig-paren">(</span><em>domain</em>, <em>z0=None</em>, <em>rho0=None</em>, <em>drho=None</em>, <em>beta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DensityMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.mappings.LinearMapping</span></code></p>
<p>Density mapping with depth weighting</p>
<p><em>rho =  rho0 + drho  * ( (x_2 - z0)/l_z)^(beta/2) ) * m</em></p>
<dl class="method">
<dt id="esys.downunder.DensityMapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>z0=None</em>, <em>rho0=None</em>, <em>drho=None</em>, <em>beta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DensityMapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the mapping</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the mapping</li>
<li><strong>z0</strong> (<em>scalar</em>) – depth weighting offset. If not present no depth scaling is applied.</li>
<li><strong>rho0</strong> (<em>scalar</em>) – reference density, defaults to 0</li>
<li><strong>drho</strong> (<em>scalar</em>) – density scale. By default density of granite = 2750kg/m**3 is used.</li>
<li><strong>beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – depth weighting exponent, defaults to 2</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DensityMapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DensityMapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DensityMapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DensityMapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for s</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DensityMapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DensityMapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DensityMapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DensityMapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.DipoleDipoleSurvey">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">DipoleDipoleSurvey</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>n</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#esys.downunder.dcresistivityforwardmodeling.DcResistivityForward" title="esys.downunder.dcresistivityforwardmodeling.DcResistivityForward"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.dcresistivityforwardmodeling.DcResistivityForward</span></code></a></p>
<p>DipoleDipoleSurvey forward modeling</p>
<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>n</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a skeleton class for all the other forward modeling classes.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.checkBounds">
<code class="descname">checkBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.checkBounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.getApparentResistivity">
<code class="descname">getApparentResistivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.getApparentResistivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.getApparentResistivityPrimary">
<code class="descname">getApparentResistivityPrimary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.getApparentResistivityPrimary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.getApparentResistivitySecondary">
<code class="descname">getApparentResistivitySecondary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.getApparentResistivitySecondary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.getApparentResistivityTotal">
<code class="descname">getApparentResistivityTotal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.getApparentResistivityTotal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.getElectrodes">
<code class="descname">getElectrodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.getElectrodes" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the list of electrodes with locations</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DipoleDipoleSurvey.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DipoleDipoleSurvey.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3 list each made up of a number of list containing primary, secondary and total
potentials diferences. Each of the lists contain a list for each value of n.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.DomainBuilder">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">DomainBuilder</code><span class="sig-paren">(</span><em>dim=3</em>, <em>reference_system=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This class is responsible for constructing an escript Domain object with
suitable extents and resolution for survey data (<a class="reference internal" href="#esys.downunder.DataSource" title="esys.downunder.DataSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource</span></code></a> objects)
that are added to it.</p>
<p>The domain covers a region above and below the Earth surface. The
East-West direction is used as the x- or longitudinal or x[0] direction,
the North-South direction is used as the y- or latitudinal or x[1]
direction, the vertical direction is denoted by z or radial or x[2]
direction. The corresponding terms are used synonymously.</p>
<dl class="method">
<dt id="esys.downunder.DomainBuilder.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dim=3</em>, <em>reference_system=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dim</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – Dimensionality (2 or 3) of the target domain.
This has implications for the survey data than can be
added. By default a 3D domain is created.</li>
<li><strong>reference_system</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – reference coordinate system. By default the 
Cartesian coordinate system is used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.addSource">
<code class="descname">addSource</code><span class="sig-paren">(</span><em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.addSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a survey data provider to the domain builder.
An exception is raised if the domain has already been built.
An exception is also reported if the reference system used is
cartesian and the UTM zone of <code class="xref py py-obj docutils literal notranslate"><span class="pre">source</span></code> does not match the UTM zone of
sources already added to the domain builder (see Inversion Cookbook
for more information).
The dimensionality of the data source must be compatible with this
domain builder. That is, the dimensionality of the data must be one
less than the dimensionality of the domain (specified in the
constructor).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>source</strong> (<a class="reference internal" href="#esys.downunder.DataSource" title="esys.downunder.DataSource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource</span></code></a>) – The data source to be added. Its reference system needs
to match the reference system of the DomainBuilder.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.fixDensityBelow">
<code class="descname">fixDensityBelow</code><span class="sig-paren">(</span><em>depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.fixDensityBelow" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the depth below which the density anomaly is set to a given
value. If no value is given zero is assumed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – depth below which the density is fixed. If not set, no
constraint at depth is applied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.fixSusceptibilityBelow">
<code class="descname">fixSusceptibilityBelow</code><span class="sig-paren">(</span><em>depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.fixSusceptibilityBelow" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the depth below which the susceptibility anomaly is set to a
given value. If no value is given zero is assumed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – depth below which the susceptibility is fixed. If not
set, no constraint at depth is applied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.fixVelocityBelow">
<code class="descname">fixVelocityBelow</code><span class="sig-paren">(</span><em>depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.fixVelocityBelow" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the depth below which the velocity and Q index is set to a
given value. If no value is given zero is assumed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – depth below which the velocity is fixed. If not
set, no constraint at depth is applied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getBackgroundMagneticFluxDensity">
<code class="descname">getBackgroundMagneticFluxDensity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getBackgroundMagneticFluxDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the background magnetic flux density.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a domain that spans the data area plus padding.</p>
<p>The domain is created the first time this method is called,
subsequent calls return the same domain so anything that affects
the domain (such as padding) needs to be set beforehand.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The escript domain for this data source</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Domain" title="esys.escript.Domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Domain</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getGravitySurveys">
<code class="descname">getGravitySurveys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getGravitySurveys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of gravity surveys, see <a class="reference internal" href="#esys.downunder.DomainBuilder.getSurveys" title="esys.downunder.DomainBuilder.getSurveys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSurveys</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getMagneticSurveys">
<code class="descname">getMagneticSurveys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getMagneticSurveys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of magnetic surveys, see <a class="reference internal" href="#esys.downunder.DomainBuilder.getSurveys" title="esys.downunder.DomainBuilder.getSurveys"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSurveys</span></code></a> for details.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getSetDensityMask">
<code class="descname">getSetDensityMask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getSetDensityMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the density mask data object which is non-zero for cells
whose density value is fixed, zero otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getSetSusceptibilityMask">
<code class="descname">getSetSusceptibilityMask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getSetSusceptibilityMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the susceptibility mask data object which is non-zero for
cells whose susceptibility value is fixed, zero otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getSurveys">
<code class="descname">getSurveys</code><span class="sig-paren">(</span><em>datatype</em>, <em>tags=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getSurveys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects for all surveys of type <code class="xref py py-obj docutils literal notranslate"><span class="pre">datatype</span></code>
available to this domain builder. If a list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">tags</span></code> is given 
only data sources whose tag matches the tag list are returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">List of surveys which are tuples (anomaly,error).</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of all tags in use by the attached data sources.
The list may be empty.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.setBackgroundMagneticFluxDensity">
<code class="descname">setBackgroundMagneticFluxDensity</code><span class="sig-paren">(</span><em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.setBackgroundMagneticFluxDensity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the background magnetic flux density B=(B_East, B_North, B_Vertical)</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.setElementPadding">
<code class="descname">setElementPadding</code><span class="sig-paren">(</span><em>pad_x=None</em>, <em>pad_y=None</em>, <em>pad_lat=None</em>, <em>pad_lon=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.setElementPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the amount of padding around the dataset in number of elements
(cells).</p>
<p>When the domain is constructed <code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_x</span></code> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_y</span></code>) elements are added
on each side of the x- (y-) dimension. The arguments must be
non-negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pad_x</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – Padding per side in x direction (default: no padding)</li>
<li><strong>pad_y</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – Padding per side in y direction (default: no padding)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_y</span></code> is ignored for 2-dimensional datasets.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.setFractionalPadding">
<code class="descname">setFractionalPadding</code><span class="sig-paren">(</span><em>pad_x=None</em>, <em>pad_y=None</em>, <em>pad_lat=None</em>, <em>pad_lon=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.setFractionalPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the amount of padding around the dataset as a fraction of the
dataset side lengths.</p>
<p>For example, calling <code class="docutils literal notranslate"><span class="pre">setFractionalPadding(0.2,</span> <span class="pre">0.1)</span></code> with a data
source of size 10x20 will result in the padded data set size
14x24 (10*(1+2*0.2), 20*(1+2*0.1))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pad_x</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – Padding per side in x direction (default: no padding)</li>
<li><strong>pad_y</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – Padding per side in y direction (default: no padding)</li>
<li><strong>pad_lat</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – Padding per side in latitudinal direction (default: no padding)</li>
<li><strong>pad_lon</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – Padding per side in longitudinal direction (default: no padding)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_y</span></code> is ignored for 2-dimensional domains.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.setGeoPadding">
<code class="descname">setGeoPadding</code><span class="sig-paren">(</span><em>pad_lat=None</em>, <em>pad_lon=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.setGeoPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the amount of padding around the dataset in longitude and latitude.</p>
<p>The final domain size will be the extent in the latitudinal (in
longitudinal) direction of the dataset plus twice the value of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_lat</span></code> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_lon</span></code>). The arguments must be non-negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pad_lat</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> in units of degree) – Padding per side in latitudinal direction (default: 0)</li>
<li><strong>pad_lon</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>  in units of degree) – Padding per side in longitudinal direction (default: 0)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_lon</span></code> is ignored for 2-dimensional domains.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">this function can only be used if the reference system is not Cartesian</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.setPadding">
<code class="descname">setPadding</code><span class="sig-paren">(</span><em>pad_x=None</em>, <em>pad_y=None</em>, <em>pad_lat=None</em>, <em>pad_lon=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.setPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the amount of padding around the dataset in absolute length units.</p>
<p>The final domain size will be the length in x (in y) of the dataset
plus twice the value of <code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_x</span></code> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_y</span></code>). The arguments must be
non-negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pad_x</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> in units of length (meter)) – Padding per side in x direction (default: no padding)</li>
<li><strong>pad_y</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> in units of length (meter)) – Padding per side in y direction (default: no padding)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad_y</span></code> is ignored for 2-dimensional domains.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">this function can only be used if the reference system is Cartesian</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.DomainBuilder.setVerticalExtents">
<code class="descname">setVerticalExtents</code><span class="sig-paren">(</span><em>depth=40000.0</em>, <em>air_layer=10000.0</em>, <em>num_cells=25</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.DomainBuilder.setVerticalExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>This method sets the target domain parameters for the vertical
dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – Depth of the domain (in meters)</li>
<li><strong>air_layer</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – Depth of the layer above sea level (in meters)</li>
<li><strong>num_cells</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – Number of domain elements for the entire vertical
dimension</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.ErMapperData">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">ErMapperData</code><span class="sig-paren">(</span><em>data_type</em>, <em>headerfile</em>, <em>datafile=None</em>, <em>altitude=0.0</em>, <em>error=None</em>, <em>scale_factor=None</em>, <em>null_value=None</em>, <em>reference_system=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.DataSource</span></code></p>
<p>Data Source for ER Mapper raster data.
Note that this class only accepts a very specific type of ER Mapper data
input and will raise an exception if other data is found.</p>
<dl class="method">
<dt id="esys.downunder.ErMapperData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data_type</em>, <em>headerfile</em>, <em>datafile=None</em>, <em>altitude=0.0</em>, <em>error=None</em>, <em>scale_factor=None</em>, <em>null_value=None</em>, <em>reference_system=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_type</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – type of data, must be <a class="reference internal" href="#esys.downunder.ErMapperData.GRAVITY" title="esys.downunder.ErMapperData.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GRAVITY</span></code></a> or <a class="reference internal" href="#esys.downunder.ErMapperData.MAGNETIC" title="esys.downunder.ErMapperData.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAGNETIC</span></code></a></li>
<li><strong>headerfile</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – ER Mapper header file (usually ends in .ers)</li>
<li><strong>datafile</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – ER Mapper binary data file name. If not supplied the
name of the header file without ‘.ers’ is assumed</li>
<li><strong>altitude</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – altitude of measurements above ground in meters</li>
<li><strong>error</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – constant value to use for the data uncertainties.
If a value is supplied, it is scaled by the same factor
as the measurements. If not provided the error is
assumed to be 2 units for all measurements (i.e. 0.2
mGal and 2 nT for gravity and magnetic, respectively)</li>
<li><strong>scale_factor</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – the measurements and error values are scaled by
this factor. By default, gravity data is assumed
to be given in 1e-6 m/s^2 (0.1 mGal), while
magnetic data is assumed to be in 1e-9 T (1 nT).</li>
<li><strong>null_value</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – value that is used in the file to mark undefined
areas. This information is usually included in the
file.</li>
<li><strong>reference_system</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – reference coordinate system to be used.
For a Cartesian reference (default) the
appropriate UTM transformation is applied.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">consistence in the reference coordinate system and the reference
coordinate system used in the data source is not checked.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.ErMapperData.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.ErMapperData.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.ErMapperData.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.ErMapperData.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.ErMapperData.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.ErMapperData.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.ErMapperData.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.ErMapperData.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns ( (x0, y0), (nx, ny), (dx, dy) )</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of survey data managed by this source.
Subclasses must return <a class="reference internal" href="#esys.downunder.ErMapperData.GRAVITY" title="esys.downunder.ErMapperData.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GRAVITY</span></code></a> or <a class="reference internal" href="#esys.downunder.ErMapperData.MAGNETIC" title="esys.downunder.ErMapperData.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAGNETIC</span></code></a> or <a class="reference internal" href="#esys.downunder.ErMapperData.ACOUSTIC" title="esys.downunder.ErMapperData.ACOUSTIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ACOUSTIC</span></code></a> as appropriate.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.ErMapperData.setSubsamplingFactor" title="esys.downunder.ErMapperData.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>NE</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called by the <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a> to retrieve the survey
data as <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects on the given domain.</p>
<p>Subclasses should return one or more <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects with survey data
interpolated on the given <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript</span></code> domain. The exact return type
depends on the type of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<a class="reference internal" href="esys.escript.html#esys.escript.Domain" title="esys.escript.Domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Domain</span></code></a>) – the escript domain to use</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the origin coordinates of the domain</li>
<li><strong>NE</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the number of domain elements in each dimension</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the cell sizes (node spacing) in the domain</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>All data source coordinates are converted to UTM (Universal Transverse
Mercator) in order to have useful domain extents. Subclasses should
implement this method and return the UTM zone number of the projected
coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ErMapperData.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ErMapperData.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.ForwardModel">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">ForwardModel</code><a class="headerlink" href="#esys.downunder.ForwardModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract forward model that can be plugged into a cost function.
Subclasses need to implement <a class="reference internal" href="#esys.downunder.ForwardModel.getDefect" title="esys.downunder.ForwardModel.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a>, <a class="reference internal" href="#esys.downunder.ForwardModel.getGradient" title="esys.downunder.ForwardModel.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>, and possibly
<a class="reference internal" href="#esys.downunder.ForwardModel.getArguments" title="esys.downunder.ForwardModel.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a> and ‘getCoordinateTransformation’.</p>
<dl class="method">
<dt id="esys.downunder.ForwardModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModel.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModel.getArguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModel.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModel.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModel.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModel.getDefect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModel.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModel.getGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.ForwardModelWithPotential">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">ForwardModelWithPotential</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>data</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModel" title="esys.downunder.forwardmodels.base.ForwardModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModel</span></code></a></p>
<p>Base class for a forward model using a potential such as magnetic or
gravity. It defines a cost function:</p>
<blockquote>
<div>defect = 1/2 sum_s integrate( ( weight_i[s] * ( r_i - data_i[s] ) )**2 )</div></blockquote>
<p>where s runs over the survey, weight_i are weighting factors, data_i are
the data, and r_i are the results produced by the forward model.
It is assumed that the forward model is produced through postprocessing
of the solution of a potential PDE.</p>
<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>data</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a new forward model with potential.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – data weighting factors</li>
<li><strong>data</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – data</li>
<li><strong>coordinates</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a> or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>fixPotentialAtBottom</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true potential is fixed to zero at the bottom of the domain
in addition to the top.</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getArguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getData">
<code class="descname">getData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getDataFunctionSpace">
<code class="descname">getDataFunctionSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getDataFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code> of the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getDefect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getDefectGradient">
<code class="descname">getDefectGradient</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getDefectGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getMisfitWeights">
<code class="descname">getMisfitWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getMisfitWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weights of the misfit function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ForwardModelWithPotential.getSurvey">
<code class="descname">getSurvey</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ForwardModelWithPotential.getSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair (data_index, weight_index), where data_i is the data
of survey i, weight_i is the weighting factor for survey i.
If index is None, all surveys will be returned in a pair of lists.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.FunctionJob">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">FunctionJob</code><span class="sig-paren">(</span><em>fn</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.escriptcore.splitworld.Job</span></code></p>
<p>Takes a python function (with only self and keyword params) to be called as the work method</p>
<dl class="method">
<dt id="esys.downunder.FunctionJob.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>fn</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>It ignores all of its parameters, except that, it requires the following as keyword arguments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.modellib.geometry.html#esys.modellib.geometry.DomainReader.domain" title="esys.modellib.geometry.DomainReader.domain"><strong>domain</strong></a> – Domain to be used as the basis for all <code class="docutils literal notranslate"><span class="pre">Data</span></code> and PDEs in this Job.</li>
<li><strong>jobid</strong> – sequence number of this job. The first job has id=1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.clearExports">
<code class="descname">clearExports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.clearExports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove exported values from the map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.clearImports">
<code class="descname">clearImports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.clearImports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove imported values from their map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.declareImport">
<code class="descname">declareImport</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.declareImport" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds name to the list of imports</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.exportValue">
<code class="descname">exportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.exportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Make value v available to other Jobs under the label name.
name must have already been registered with the SplitWorld instance.
For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – registered label for exported value</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.importValue">
<code class="descname">importValue</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.importValue" title="Permalink to this definition">¶</a></dt>
<dd><p>For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label for imported value.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.setImportValue">
<code class="descname">setImportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.setImportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Use to make a value available to the job (ie called from outside the job)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label used to identify this import</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.FunctionJob.work">
<code class="descname">work</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.FunctionJob.work" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to be overloaded for the job to actually do anthing.
A return value of True indicates this job thinks it is done.
A return value of False indicates work still to be done</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.GeodeticCoordinateTransformation">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">GeodeticCoordinateTransformation</code><span class="sig-paren">(</span><em>domain</em>, <em>reference=&lt;esys.downunder.coordinates.GeodeticReferenceSystem object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.coordinates.SpatialCoordinateTransformation</span></code></p>
<p>A geodetic coordinate transformation</p>
<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>reference=&lt;esys.downunder.coordinates.GeodeticReferenceSystem object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the orthogonal coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code>) – domain in the domain of the coordinate transformation</li>
<li><strong>reference</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – the reference system</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of a scalar function in direction of the
coordinate axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Vector" title="esys.escript.Vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Vector</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference system used to to define the coordinate transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.getScalingFactors">
<code class="descname">getScalingFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.getScalingFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the scaling factors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Vector" title="esys.escript.Vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Vector</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.getVolumeFactor">
<code class="descname">getVolumeFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.getVolumeFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the volume factor for the coordinate transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Scalar" title="esys.escript.Scalar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Scalar</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.isCartesian">
<code class="descname">isCartesian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.isCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the scaling factors (and the volume factor) are equal to 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticCoordinateTransformation.isTheSame">
<code class="descname">isTheSame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticCoordinateTransformation.isTheSame" title="Permalink to this definition">¶</a></dt>
<dd><p>test if argument <code class="docutils literal notranslate"><span class="pre">other</span></code> defines the same coordinate transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – a second coordinate transformation</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if other defines then same coordinate transformation</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.GeodeticReferenceSystem">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">GeodeticReferenceSystem</code><span class="sig-paren">(</span><em>a=6378137.0</em>, <em>f=0.0033528106647474805</em>, <em>angular_unit=0.017453292519943295</em>, <em>height_unit=1000.0</em>, <em>name='WGS84'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.coordinates.ReferenceSystem</span></code></p>
<p>Identifies a Geodetic coordinate system</p>
<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>a=6378137.0</em>, <em>f=0.0033528106647474805</em>, <em>angular_unit=0.017453292519943295</em>, <em>height_unit=1000.0</em>, <em>name='WGS84'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a geodetic reference system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> (positive <code class="docutils literal notranslate"><span class="pre">double</span></code>) – semi-major axis in meter</li>
<li><strong>f</strong> (non-negative <code class="docutils literal notranslate"><span class="pre">double</span></code>, less than one) – flattening</li>
<li><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the reference system</li>
<li><strong>angular_unit</strong> (positive <code class="docutils literal notranslate"><span class="pre">double</span></code>) – factor to scale the unit of latitude and
longitude to radians.</li>
<li><strong>height_unit</strong> (positive <code class="docutils literal notranslate"><span class="pre">double</span></code>) – factor to scale the unit of latitude and
longitude to radians.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.createTransformation">
<code class="descname">createTransformation</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.createTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an appropriate coordinate transformation on a given domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code>) – domain of transformation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.getAngularUnit">
<code class="descname">getAngularUnit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.getAngularUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the angular unit</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.getFlattening">
<code class="descname">getFlattening</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.getFlattening" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the flattening</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.getHeightUnit">
<code class="descname">getHeightUnit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.getHeightUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height unit</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.getName">
<code class="descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the name of the reference system</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.getSemiMajorAxis">
<code class="descname">getSemiMajorAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.getSemiMajorAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the length of semi major axis</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.getSemiMinorAxis">
<code class="descname">getSemiMinorAxis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.getSemiMinorAxis" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the length of semi minor axis</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.isCartesian">
<code class="descname">isCartesian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.isCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>returns if the reference system is Cartesian</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GeodeticReferenceSystem.isTheSame">
<code class="descname">isTheSame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GeodeticReferenceSystem.isTheSame" title="Permalink to this definition">¶</a></dt>
<dd><p>test if <code class="docutils literal notranslate"><span class="pre">other</span></code> defines the same reference system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – a second reference system</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if other defines then same reference system</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">two <a class="reference internal" href="#esys.downunder.GeodeticReferenceSystem" title="esys.downunder.GeodeticReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeodeticReferenceSystem</span></code></a> are considered to be the same
if the use the same semi major axis, the same flattening
and the same angular unit.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.GravityInversion">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">GravityInversion</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.inversions.InversionDriver</span></code></p>
<p>Driver class to perform an inversion of Gravity (Bouguer) anomaly data.
The class uses the standard <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a> class for a single level set
function, <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a> mapping, and the gravity forward model
<a class="reference internal" href="#esys.downunder.GravityModel" title="esys.downunder.GravityModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GravityModel</span></code></a>.</p>
<dl class="method">
<dt id="esys.downunder.GravityInversion.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an instance of an inversion driver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>solverclass</strong> (<em>'AbstractMinimizer'.</em>) – class of the solver to be used.</li>
<li><strong>self_demagnetization</strong> – if True self-demagnitization is applied.</li>
<li><strong>magnetic_intensity_data</strong> – if True magnetic intensity is used in the cost function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.fixGravityPotentialAtBottom">
<code class="descname">fixGravityPotentialAtBottom</code><span class="sig-paren">(</span><em>status=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.fixGravityPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the gravity potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True gravity potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.fixMagneticPotentialAtBottom">
<code class="descname">fixMagneticPotentialAtBottom</code><span class="sig-paren">(</span><em>status=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.fixMagneticPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the magnetic potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True magnetic potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the cost function of the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘InversionCostFunction’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the inversion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.getLevelSetFunction">
<code class="descname">getLevelSetFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.getLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the level set function as solution of the optimization problem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.getSolver">
<code class="descname">getSolver</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.getSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver to be used in the inversion process. See the minimizers
module for available solvers. By default, the L-BFGS minimizer is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘AbstractMinimizer’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.isSetUp">
<code class="descname">isSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.isSetUp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns True if the inversion is set up and is ready to run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">physical parameters as result of the inversion</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of physical parameters or a physical parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>costfunction</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the cost function of the inversion. This function needs to be
called before the inversion iteration can be started.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>costfunction</strong> (<em>'InversionCostFunction'</em>) – domain of the inversion</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.setInitialGuess">
<code class="descname">setInitialGuess</code><span class="sig-paren">(</span><em>rho=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.setInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>set the initial guess <em>rho</em> for density the inversion iteration. If no <em>rho</em> present
then an appropriate initial guess is chosen.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rho</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – initial value for the density anomaly.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.setSolverCallback">
<code class="descname">setSolverCallback</code><span class="sig-paren">(</span><em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.setSolverCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the callback function which is called after every solver
iteration.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.setSolverMaxIterations">
<code class="descname">setSolverMaxIterations</code><span class="sig-paren">(</span><em>maxiter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.setSolverMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of solver iterations to run.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">maxiter</span></code> is reached the iteration is terminated and
<a class="reference internal" href="#esys.downunder.MinimizerMaxIterReached" title="esys.downunder.MinimizerMaxIterReached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerMaxIterReached</span></code></a> is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxiter</strong> (positive <code class="docutils literal notranslate"><span class="pre">int</span></code>) – maximum number of iteration steps.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.setSolverTolerance">
<code class="descname">setSolverTolerance</code><span class="sig-paren">(</span><em>m_tol=None</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.setSolverTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the error tolerance for the solver. An acceptable solution is
considered to be found once the tolerance is reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to level set function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>
changes to the level set function are not checked for
convergence during iteration.</li>
<li><strong>J_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to cost function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> changes
to the cost function are not checked for convergence
during iteration.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if both arguments are <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> the default setting m_tol=1e-4,
J_tol=None is used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>domainbuilder</em>, <em>rho0=None</em>, <em>drho=None</em>, <em>z0=None</em>, <em>beta=None</em>, <em>w0=None</em>, <em>w1=None</em>, <em>rho_at_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the inversion parameters from a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domainbuilder</strong> (<a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>) – Domain builder object with gravity source(s)</li>
<li><strong>rho0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference density, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>drho</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – density scale, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, 2750kg/m^3 is used.</li>
<li><strong>z0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference depth for depth weighting, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – exponent for  depth weighting, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>w0</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for level set term regularization. If not set zero is assumed.</li>
<li><strong>w1</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for the gradient term in the regularization. If not set zero is assumed</li>
<li><strong>rho_at_depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – value for density at depth, see <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityInversion.siloWriterCallback">
<code class="descname">siloWriterCallback</code><span class="sig-paren">(</span><em>k</em>, <em>x</em>, <em>Jx</em>, <em>g_Jx</em>, <em>norm_dJ=None</em>, <em>norm_dx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityInversion.siloWriterCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function that can be used to track the solution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> – iteration count</li>
<li><strong>x</strong> – current approximation</li>
<li><strong>Jx</strong> – value of cost function</li>
<li><strong>g_Jx</strong> – gradient of f at x</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.GravityModel">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">GravityModel</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>g</em>, <em>gravity_constant=6.6742e-11</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModelWithPotential" title="esys.downunder.forwardmodels.base.ForwardModelWithPotential"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModelWithPotential</span></code></a></p>
<p>Forward Model for gravity inversion as described in the inversion
cookbook.</p>
<dl class="method">
<dt id="esys.downunder.GravityModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>g</em>, <em>gravity_constant=6.6742e-11</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new gravity model on the given domain with one or more
surveys (w, g).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – data weighting factors</li>
<li><strong>g</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – gravity anomaly data</li>
<li><strong>coordinates</strong> (ReferenceSystem` or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
<li><strong>fixPotentialAtBottom</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true potential is fixed to zero at the
base of the domain in addition to the top</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">It is advisable to call rescaleWeights() to rescale weights
before starting the inversion.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.GravityModel.getDefect" title="esys.downunder.GravityModel.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.GravityModel.getGradient" title="esys.downunder.GravityModel.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – a suggestion for the density distribution</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">gravity potential and corresponding gravity field.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Vector</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getData">
<code class="descname">getData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getDataFunctionSpace">
<code class="descname">getDataFunctionSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getDataFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code> of the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>rho</em>, <em>phi</em>, <em>gravity_force</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the defect</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – density distribution</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>gravity_force</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – gravity force</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getDefectGradient">
<code class="descname">getDefectGradient</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getDefectGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>rho</em>, <em>phi</em>, <em>gravity_force</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – density distribution</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>gravity_force</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – gravity force</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getMisfitWeights">
<code class="descname">getMisfitWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getMisfitWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weights of the misfit function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the gravity potential for a given density distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – a suggestion for the density distribution</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">gravity potential</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.getSurvey">
<code class="descname">getSurvey</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.getSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair (data_index, weight_index), where data_i is the data
of survey i, weight_i is the weighting factor for survey i.
If index is None, all surveys will be returned in a pair of lists.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.GravityModel.rescaleWeights">
<code class="descname">rescaleWeights</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>rho_scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GravityModel.rescaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>rescales the weights such that</p>
<p><em>sum_s integrate( ( w_i[s] *g_i[s]) (w_j[s]*1/L_j) * L**2 * 4*pi*G*rho_scale )=scale</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – scale of data weighting factors</li>
<li><strong>rho_scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – scale of density.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.HTIWave">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">HTIWave</code><span class="sig-paren">(</span><em>domain, v_p, v_s, wavelet, source_tag, source_vector=[1.0, 0.0, 0.0], eps=0.0, gamma=0.0, delta=0.0, rho=1.0, dt=None, u0=None, v0=None, absorption_zone=None, absorption_cut=0.01, lumping=True, disable_fast_assemblers=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.HTIWave" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.seismic.html#esys.downunder.seismic.WaveBase" title="esys.downunder.seismic.WaveBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.seismic.WaveBase</span></code></a></p>
<p>Solving the HTI wave equation (along the x_0 axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">In case of a two dimensional domain a horizontal domain is considered, i.e. the depth component is dropped.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.HTIWave.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain, v_p, v_s, wavelet, source_tag, source_vector=[1.0, 0.0, 0.0], eps=0.0, gamma=0.0, delta=0.0, rho=1.0, dt=None, u0=None, v0=None, absorption_zone=None, absorption_cut=0.01, lumping=True, disable_fast_assemblers=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.HTIWave.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the VTI wave solver</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the problem</li>
<li><strong>v_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical p-velocity field</li>
<li><strong>v_s</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical s-velocity field</li>
<li><strong>wavelet</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Wavelet</span></code>) – wavelet to describe the time evolution of source term</li>
<li><strong>source_tag</strong> (<em>'str'</em><em> or </em><em>'int'</em>) – tag of the source location</li>
<li><strong>source_vector</strong> – source orientation vector</li>
<li><strong>eps</strong> – first Thompsen parameter</li>
<li><strong>delta</strong> – second Thompsen parameter</li>
<li><strong>gamma</strong> – third Thompsen parameter</li>
<li><strong>rho</strong> – density</li>
<li><strong>dt</strong> – time step size. If not present a suitable time step size is calculated.</li>
<li><strong>u0</strong> – initial solution. If not present zero is used.</li>
<li><strong>v0</strong> – initial solution change rate. If not present zero is used.</li>
<li><strong>absorption_zone</strong> – thickness of absorption zone</li>
<li><strong>absorption_cut</strong> – boundary value of absorption decay factor</li>
<li><strong>lumping</strong> – if True mass matrix lumping is being used. This is accelerates the computing but introduces some diffusion.</li>
<li><strong>disable_fast_assemblers</strong> – if True, forces use of slower and more general PDE assemblers</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.HTIWave.getTimeStepSize">
<code class="descname">getTimeStepSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.HTIWave.getTimeStepSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.HTIWave.setQ">
<code class="descname">setQ</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.HTIWave.setQ" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the PDE q value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>q</strong> – the value to set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.HTIWave.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.HTIWave.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the solution for the next time marker t which needs to greater than the time marker from the
previous call.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.InversionCostFunction">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">InversionCostFunction</code><span class="sig-paren">(</span><em>regularization</em>, <em>mappings</em>, <em>forward_models</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.MeteredCostFunction</span></code></p>
<p>Class to define cost function <em>J(m)</em> for inversion with one or more
forward models based on a multi-valued level set function <em>m</em>:</p>
<p><em>J(m) = J_reg(m) + sum_f mu_f * J_f(p)</em></p>
<p>where <em>J_reg(m)</em> is the regularization and cross gradient component of the
cost function applied to a level set function <em>m</em>, <em>J_f(p)</em> are the data
defect cost functions involving a physical forward model using the
physical parameter(s) <em>p</em> and <em>mu_f</em> is the trade-off factor for model f.</p>
<p>A forward model depends on a set of physical parameters <em>p</em> which are
constructed from components of the level set function <em>m</em> via mappings.</p>
<dl class="docutils">
<dt>Example 1 (single forward model):</dt>
<dd>m=Mapping()
f=ForwardModel()
J=InversionCostFunction(Regularization(), m, f)</dd>
<dt>Example 2 (two forward models on a single valued level set)</dt>
<dd><p class="first">m0=Mapping()
m1=Mapping()
f0=ForwardModel()
f1=ForwardModel()</p>
<p class="last">J=InversionCostFunction(Regularization(), mappings=[m0, m1], forward_models=[(f0, 0), (f1,1)])</p>
</dd>
<dt>Example 3 (two forward models on 2-valued level set)</dt>
<dd><p class="first">m0=Mapping()
m1=Mapping()
f0=ForwardModel()
f1=ForwardModel()</p>
<p class="last">J=InversionCostFunction(Regularization(self.numLevelSets=2), mappings=[(m0,0), (m1,0)], forward_models=[(f0, 0), (f1,1)])</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">If provides_inverse_Hessian_approximation is true, then the class
provides an approximative inverse of the Hessian operator.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.InversionCostFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>regularization</em>, <em>mappings</em>, <em>forward_models</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>constructor for the cost function.
Stores the supplied object references and sets default weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>regularization</strong> (<a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a>) – the regularization part of the cost function</li>
<li><strong>mappings</strong> (<a class="reference internal" href="#esys.downunder.Mapping" title="esys.downunder.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the mappings to calculate physical parameters from the
regularization. This is a list of 2-tuples <em>(map, i)</em>
where the first component map defines a <a class="reference internal" href="#esys.downunder.Mapping" title="esys.downunder.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a> and
the second component <em>i</em> defines the index of the
component of level set function to be used to
calculate the mapping. Items in the list may also be
just <a class="reference internal" href="#esys.downunder.Mapping" title="esys.downunder.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a> objects in which case the entire level
set function is fed into the <a class="reference internal" href="#esys.downunder.Mapping" title="esys.downunder.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a> (typically used
for a single-component level set function.</li>
<li><strong>forward_models</strong> – the forward models involved in the calculation
of the cost function. This is a list of 2-tuples
<em>(f, ii)</em> where the first component f defines a
<a class="reference internal" href="#esys.downunder.ForwardModel" title="esys.downunder.ForwardModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForwardModel</span></code></a> and the second component <em>ii</em> a
list of indexes referring to the physical
parameters in the <code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> list. The 2-tuple
can be replaced by a <a class="reference internal" href="#esys.downunder.ForwardModel" title="esys.downunder.ForwardModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForwardModel</span></code></a> if the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> list has a single entry.</li>
<li><strong>forward_models</strong> – <a class="reference internal" href="#esys.downunder.ForwardModel" title="esys.downunder.ForwardModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForwardModel</span></code></a> or <code class="docutils literal notranslate"><span class="pre">list</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.createLevelSetFunction">
<code class="descname">createLevelSetFunction</code><span class="sig-paren">(</span><em>*props</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.createLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an instance of an object used to represent a level set function
initialized with zeros. Components can be overwritten by physical
properties <code class="xref py py-obj docutils literal notranslate"><span class="pre">props</span></code>. If present entries must correspond to the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> arguments in the constructor. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for properties
for which no value is given.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>returns precalculated values that are shared in the calculation of
<em>f(x)</em> and <em>grad f(x)</em> and the Hessian operator</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tuple returned by this call will be passed back to this <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a> in other
calls(eg: <code class="docutils literal notranslate"><span class="pre">getGradient</span></code>). Its contents are not specified at this level because no code, other than the <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>
which created it, will be interacting with it.
That is, the implementor can put whatever information they find useful in it.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – location of derivative</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getComponentValues">
<code class="descname">getComponentValues</code><span class="sig-paren">(</span><em>m</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getComponentValues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the cost function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>x</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getForwardModel">
<code class="descname">getForwardModel</code><span class="sig-paren">(</span><em>idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getForwardModel" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <em>idx</em>-th forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idx</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – model index. If cost function contains one model only <code class="xref py py-obj docutils literal notranslate"><span class="pre">idx</span></code>
can be omitted.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.InversionCostFunction.getArguments" title="esys.downunder.InversionCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculate in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated.</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.InversionCostFunction.getArguments" title="esys.downunder.InversionCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">x-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getNumTradeOffFactors">
<code class="descname">getNumTradeOffFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getNumTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of trade-off factors being used including the
trade-off factors used in the regularization component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getProperties">
<code class="descname">getProperties</code><span class="sig-paren">(</span><em>m</em>, <em>return_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the physical properties from a given level set
function <em>m</em> using the mappings of the cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – level set function</li>
<li><strong>return_list</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> a list is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getRegularization">
<code class="descname">getRegularization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the regularization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getTradeOffFactors">
<code class="descname">getTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the trade-off factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getTradeOffFactorsModels">
<code class="descname">getTradeOffFactorsModels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getTradeOffFactorsModels" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the trade-off factors for the forward models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value <em>f(x)</em> using the precalculated values for <em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – a solution approximation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.InversionCostFunction.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = True</em><a class="headerlink" href="#esys.downunder.InversionCostFunction.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.resetCounters">
<code class="descname">resetCounters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.resetCounters" title="Permalink to this definition">¶</a></dt>
<dd><p>resets all statistical counters</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.setTradeOffFactors">
<code class="descname">setTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.setTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the forward model and regularization
terms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – list of trade-off factors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.setTradeOffFactorsModels">
<code class="descname">setTradeOffFactorsModels</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.setTradeOffFactorsModels" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the forward model components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> in case of a single model or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of
<code class="docutils literal notranslate"><span class="pre">float</span></code> with the length of the number of models.) – list of the trade-off factors. If not present ones are used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.setTradeOffFactorsRegularization">
<code class="descname">setTradeOffFactorsRegularization</code><span class="sig-paren">(</span><em>mu=None</em>, <em>mu_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.setTradeOffFactorsRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the regularization component of the
cost function, see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mu</strong> – trade-off factors for the level-set variation part</li>
<li><strong>mu_c</strong> – trade-off factors for the cross gradient variation part</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionCostFunction.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionCostFunction.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class that the Hessian operator needs to be updated.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.InversionDriver">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">InversionDriver</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base class for running an inversion</p>
<dl class="method">
<dt id="esys.downunder.InversionDriver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an instance of an inversion driver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>solverclass</strong> (<em>'AbstractMinimizer'.</em>) – class of the solver to be used.</li>
<li><strong>self_demagnetization</strong> – if True self-demagnitization is applied.</li>
<li><strong>magnetic_intensity_data</strong> – if True magnetic intensity is used in the cost function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.fixGravityPotentialAtBottom">
<code class="descname">fixGravityPotentialAtBottom</code><span class="sig-paren">(</span><em>status=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.fixGravityPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the gravity potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True gravity potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.fixMagneticPotentialAtBottom">
<code class="descname">fixMagneticPotentialAtBottom</code><span class="sig-paren">(</span><em>status=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.fixMagneticPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the magnetic potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True magnetic potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the cost function of the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘InversionCostFunction’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the inversion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.getLevelSetFunction">
<code class="descname">getLevelSetFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.getLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the level set function as solution of the optimization problem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.getSolver">
<code class="descname">getSolver</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.getSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver to be used in the inversion process. See the minimizers
module for available solvers. By default, the L-BFGS minimizer is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘AbstractMinimizer’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.isSetUp">
<code class="descname">isSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.isSetUp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns True if the inversion is set up and is ready to run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">physical parameters as result of the inversion</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of physical parameters or a physical parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>costfunction</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the cost function of the inversion. This function needs to be
called before the inversion iteration can be started.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>costfunction</strong> (<em>'InversionCostFunction'</em>) – domain of the inversion</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.setInitialGuess">
<code class="descname">setInitialGuess</code><span class="sig-paren">(</span><em>*props</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.setInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the initial guess for the inversion iteration.
By default zero is used.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.setSolverCallback">
<code class="descname">setSolverCallback</code><span class="sig-paren">(</span><em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.setSolverCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the callback function which is called after every solver
iteration.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.setSolverMaxIterations">
<code class="descname">setSolverMaxIterations</code><span class="sig-paren">(</span><em>maxiter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.setSolverMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of solver iterations to run.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">maxiter</span></code> is reached the iteration is terminated and
<a class="reference internal" href="#esys.downunder.MinimizerMaxIterReached" title="esys.downunder.MinimizerMaxIterReached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerMaxIterReached</span></code></a> is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxiter</strong> (positive <code class="docutils literal notranslate"><span class="pre">int</span></code>) – maximum number of iteration steps.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.setSolverTolerance">
<code class="descname">setSolverTolerance</code><span class="sig-paren">(</span><em>m_tol=None</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.setSolverTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the error tolerance for the solver. An acceptable solution is
considered to be found once the tolerance is reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to level set function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>
changes to the level set function are not checked for
convergence during iteration.</li>
<li><strong>J_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to cost function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> changes
to the cost function are not checked for convergence
during iteration.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if both arguments are <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> the default setting m_tol=1e-4,
J_tol=None is used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.InversionDriver.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>*args</em>, <em>**k_args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.InversionDriver.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>sets up the inversion. The default implementation does nothing but
it is advised to call this method before calling <a class="reference internal" href="#esys.downunder.InversionDriver.run" title="esys.downunder.InversionDriver.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.IsostaticPressure">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">IsostaticPressure</code><span class="sig-paren">(</span><em>domain</em>, <em>p0=0.0</em>, <em>level0=0</em>, <em>gravity0=-9.81</em>, <em>background_density=2670.0</em>, <em>gravity_constant=6.6742e-11</em>, <em>coordinates=None</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.IsostaticPressure" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>class to calculate isostatic pressure field correction due to gravity forces</p>
<dl class="method">
<dt id="esys.downunder.IsostaticPressure.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>p0=0.0</em>, <em>level0=0</em>, <em>gravity0=-9.81</em>, <em>background_density=2670.0</em>, <em>gravity_constant=6.6742e-11</em>, <em>coordinates=None</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.IsostaticPressure.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>p0</strong> (scalar <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>) – pressure at level0</li>
<li><strong>background_density</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – defines background_density in kg/m^3</li>
<li><strong>coordinates</strong> (ReferenceSystem` or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
<li><strong>level0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – pressure for z&gt;=`level0` is set to zero.</li>
<li><strong>gravity0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – vertical background gravity at <code class="xref py py-obj docutils literal notranslate"><span class="pre">level0</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.IsostaticPressure.getPressure">
<code class="descname">getPressure</code><span class="sig-paren">(</span><em>g=None</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.IsostaticPressure.getPressure" title="Permalink to this definition">¶</a></dt>
<dd><p>return the pressure for gravity force anomaly <code class="xref py py-obj docutils literal notranslate"><span class="pre">g</span></code> and
density anomaly <code class="xref py py-obj docutils literal notranslate"><span class="pre">rho</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>g</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – gravity anomaly data</li>
<li><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – gravity anomaly data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">pressure distribution</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.Job">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">Job</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes a sequence of work to be carried out in a subworld.
The instances of this class used in the subworlds will
be constructed by the system.
To do specific work, this class should be subclassed and the work() 
(and possibly __init__ methods overloaded).
The majority of the work done by the job will be in the <em>overloaded</em> work() method.
The work() method should retrieve values from the outside using importValue() and pass values to
the rest of the system using exportValue().
The rest of the methods should be considered off limits.</p>
<dl class="method">
<dt id="esys.downunder.Job.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>It ignores all of its parameters, except that, it requires the following as keyword arguments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.modellib.geometry.html#esys.modellib.geometry.DomainReader.domain" title="esys.modellib.geometry.DomainReader.domain"><strong>domain</strong></a> – Domain to be used as the basis for all <code class="docutils literal notranslate"><span class="pre">Data</span></code> and PDEs in this Job.</li>
<li><strong>jobid</strong> – sequence number of this job. The first job has id=1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.clearExports">
<code class="descname">clearExports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.clearExports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove exported values from the map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.clearImports">
<code class="descname">clearImports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.clearImports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove imported values from their map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.declareImport">
<code class="descname">declareImport</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.declareImport" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds name to the list of imports</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.exportValue">
<code class="descname">exportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.exportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Make value v available to other Jobs under the label name.
name must have already been registered with the SplitWorld instance.
For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – registered label for exported value</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.importValue">
<code class="descname">importValue</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.importValue" title="Permalink to this definition">¶</a></dt>
<dd><p>For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label for imported value.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.setImportValue">
<code class="descname">setImportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.setImportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Use to make a value available to the job (ie called from outside the job)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label used to identify this import</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Job.work">
<code class="descname">work</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Job.work" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to be overloaded for the job to actually do anthing.
A return value of True indicates this job thinks it is done.
A return value of False indicates work still to be done</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.JointGravityMagneticInversion">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">JointGravityMagneticInversion</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.inversions.InversionDriver</span></code></p>
<p>Driver class to perform a joint inversion of Gravity (Bouguer) and
magnetic anomaly data. The class uses the standard <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a> class
for two level set functions with cross-gradient correlation,
<a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a> and <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a> mappings, the gravity forward
model <a class="reference internal" href="#esys.downunder.GravityModel" title="esys.downunder.GravityModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GravityModel</span></code></a> and the linear magnetic forward model <a class="reference internal" href="#esys.downunder.MagneticModel" title="esys.downunder.MagneticModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MagneticModel</span></code></a>.</p>
<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an instance of an inversion driver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>solverclass</strong> (<em>'AbstractMinimizer'.</em>) – class of the solver to be used.</li>
<li><strong>self_demagnetization</strong> – if True self-demagnitization is applied.</li>
<li><strong>magnetic_intensity_data</strong> – if True magnetic intensity is used in the cost function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.JointGravityMagneticInversion.DENSITY">
<code class="descname">DENSITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.DENSITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.JointGravityMagneticInversion.SUSCEPTIBILITY">
<code class="descname">SUSCEPTIBILITY</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.SUSCEPTIBILITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.fixGravityPotentialAtBottom">
<code class="descname">fixGravityPotentialAtBottom</code><span class="sig-paren">(</span><em>status=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.fixGravityPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the gravity potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True gravity potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.fixMagneticPotentialAtBottom">
<code class="descname">fixMagneticPotentialAtBottom</code><span class="sig-paren">(</span><em>status=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.fixMagneticPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the magnetic potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True magnetic potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the cost function of the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘InversionCostFunction’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the inversion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.getLevelSetFunction">
<code class="descname">getLevelSetFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.getLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the level set function as solution of the optimization problem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.getSolver">
<code class="descname">getSolver</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.getSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver to be used in the inversion process. See the minimizers
module for available solvers. By default, the L-BFGS minimizer is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘AbstractMinimizer’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.isSetUp">
<code class="descname">isSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.isSetUp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns True if the inversion is set up and is ready to run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">physical parameters as result of the inversion</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of physical parameters or a physical parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>costfunction</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the cost function of the inversion. This function needs to be
called before the inversion iteration can be started.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>costfunction</strong> (<em>'InversionCostFunction'</em>) – domain of the inversion</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.setInitialGuess">
<code class="descname">setInitialGuess</code><span class="sig-paren">(</span><em>rho=None</em>, <em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.setInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>set the initial guess <em>rho</em> for density and <em>k</em> for susceptibility for the inversion iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rho</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – initial value for the density anomaly.</li>
<li><strong>k</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – initial value for the susceptibility anomaly.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.setSolverCallback">
<code class="descname">setSolverCallback</code><span class="sig-paren">(</span><em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.setSolverCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the callback function which is called after every solver
iteration.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.setSolverMaxIterations">
<code class="descname">setSolverMaxIterations</code><span class="sig-paren">(</span><em>maxiter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.setSolverMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of solver iterations to run.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">maxiter</span></code> is reached the iteration is terminated and
<a class="reference internal" href="#esys.downunder.MinimizerMaxIterReached" title="esys.downunder.MinimizerMaxIterReached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerMaxIterReached</span></code></a> is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxiter</strong> (positive <code class="docutils literal notranslate"><span class="pre">int</span></code>) – maximum number of iteration steps.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.setSolverTolerance">
<code class="descname">setSolverTolerance</code><span class="sig-paren">(</span><em>m_tol=None</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.setSolverTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the error tolerance for the solver. An acceptable solution is
considered to be found once the tolerance is reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to level set function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>
changes to the level set function are not checked for
convergence during iteration.</li>
<li><strong>J_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to cost function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> changes
to the cost function are not checked for convergence
during iteration.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if both arguments are <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> the default setting m_tol=1e-4,
J_tol=None is used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>domainbuilder</em>, <em>rho0=None</em>, <em>drho=None</em>, <em>rho_z0=None</em>, <em>rho_beta=None</em>, <em>k0=None</em>, <em>dk=None</em>, <em>k_z0=None</em>, <em>k_beta=None</em>, <em>w0=None</em>, <em>w1=None</em>, <em>w_gc=None</em>, <em>rho_at_depth=None</em>, <em>k_at_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the inversion from an instance <code class="docutils literal notranslate"><span class="pre">domainbuilder</span></code> of a
<a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>. Gravity and magnetic data attached to the
<code class="docutils literal notranslate"><span class="pre">domainbuilder</span></code> are considered in the inversion.
If magnetic data are given as scalar it is assumed that values are
collected in direction of the background magnetic field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domainbuilder</strong> (<a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>) – Domain builder object with gravity source(s)</li>
<li><strong>rho0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference density, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>drho</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – density scale, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, 2750kg/m^3 is used.</li>
<li><strong>rho_z0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference depth for depth weighting for density, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>rho_beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – exponent for  depth weighting  for density, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>k0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference susceptibility, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>dk</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility scale, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, 2750kg/m^3 is used.</li>
<li><strong>k_z0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference depth for depth weighting for susceptibility, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>k_beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – exponent for  depth weighting for susceptibility, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>w0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">es.Data</span></code> or <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of shape (2,)) – weighting factors for level set term regularization, see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a>. If not set zero is assumed.</li>
<li><strong>w1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">es.Data</span></code> or <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of shape (2,DIM)) – weighting factor for the gradient term in the regularization see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a>. If not set zero is assumed</li>
<li><strong>w_gc</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for the cross gradient term in the regularization, see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a>. If not set one is assumed</li>
<li><strong>k_at_depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – value for susceptibility at depth, see <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</li>
<li><strong>rho_at_depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – value for density at depth, see <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.JointGravityMagneticInversion.siloWriterCallback">
<code class="descname">siloWriterCallback</code><span class="sig-paren">(</span><em>k</em>, <em>x</em>, <em>Jx</em>, <em>g_Jx</em>, <em>norm_dJ=None</em>, <em>norm_dx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.JointGravityMagneticInversion.siloWriterCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function that can be used to track the solution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> – iteration count</li>
<li><strong>x</strong> – current approximation</li>
<li><strong>Jx</strong> – value of cost function</li>
<li><strong>g_Jx</strong> – gradient of f at x</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.LinearMapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">LinearMapping</code><span class="sig-paren">(</span><em>a=1.0</em>, <em>p0=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.mappings.Mapping</span></code></p>
<p>Maps a parameter by a linear transformation p = a * m + p0</p>
<dl class="method">
<dt id="esys.downunder.LinearMapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>a=1.0</em>, <em>p0=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearMapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearMapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearMapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearMapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearMapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for s</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearMapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearMapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearMapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearMapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.LinearPDE">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">LinearPDE</code><span class="sig-paren">(</span><em>domain</em>, <em>numEquations=None</em>, <em>numSolutions=None</em>, <em>isComplex=False</em>, <em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.escriptcore.linearPDEs.LinearProblem</span></code></p>
<p>This class is used to define a general linear, steady, second order PDE
for an unknown function <em>u</em> on a given domain defined through a
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code> object.</p>
<p>For a single PDE having a solution with a single component the linear PDE
is defined in the following form:</p>
<p><em>-(grad(A[j,l]+A_reduced[j,l])*grad(u)[l]+(B[j]+B_reduced[j])u)[j]+(C[l]+C_reduced[l])*grad(u)[l]+(D+D_reduced)=-grad(X+X_reduced)[j,j]+(Y+Y_reduced)</em></p>
<p>where <em>grad(F)</em> denotes the spatial derivative of <em>F</em>. Einstein’s
summation convention, ie. summation over indexes appearing twice in a term
of a sum performed, is used.
The coefficients <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>X</em> and <em>Y</em> have to be specified
through <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects in <code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code> and
the coefficients <em>A_reduced</em>, <em>B_reduced</em>, <em>C_reduced</em>, <em>D_reduced</em>,
<em>X_reduced</em> and <em>Y_reduced</em> have to be specified through
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects in <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>.
It is also allowed to use objects that can be converted into such
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects. <em>A</em> and <em>A_reduced</em> are rank two, <em>B</em>,
<em>C</em>, <em>X</em>, <em>B_reduced</em>, <em>C_reduced</em> and <em>X_reduced</em> are rank one and
<em>D</em>, <em>D_reduced</em>, <em>Y</em> and <em>Y_reduced</em> are scalar.</p>
<p>The following natural boundary conditions are considered:</p>
<p><em>n[j]*((A[i,j]+A_reduced[i,j])*grad(u)[l]+(B+B_reduced)[j]*u)+(d+d_reduced)*u=n[j]*(X[j]+X_reduced[j])+y</em></p>
<p>where <em>n</em> is the outer normal field. Notice that the coefficients <em>A</em>,
<em>A_reduced</em>, <em>B</em>, <em>B_reduced</em>, <em>X</em> and <em>X_reduced</em> are defined in the
PDE. The coefficients <em>d</em> and <em>y</em> are each a scalar in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnBoundary</span></code> and the coefficients
<em>d_reduced</em> and <em>y_reduced</em> are each a scalar in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnBoundary</span></code>.</p>
<p>Constraints for the solution prescribe the value of the solution at certain
locations in the domain. They have the form</p>
<p><em>u=r</em> where <em>q&gt;0</em></p>
<p><em>r</em> and <em>q</em> are each scalar where <em>q</em> is the characteristic function
defining where the constraint is applied. The constraints override any
other condition set by the PDE or the boundary condition.</p>
<p>The PDE is symmetrical if</p>
<p><em>A[i,j]=A[j,i]</em>  and <em>B[j]=C[j]</em> and <em>A_reduced[i,j]=A_reduced[j,i]</em>
and <em>B_reduced[j]=C_reduced[j]</em></p>
<p>For a system of PDEs and a solution with several components the PDE has the
form</p>
<p><em>-grad((A[i,j,k,l]+A_reduced[i,j,k,l])*grad(u[k])[l]+(B[i,j,k]+B_reduced[i,j,k])*u[k])[j]+(C[i,k,l]+C_reduced[i,k,l])*grad(u[k])[l]+(D[i,k]+D_reduced[i,k]*u[k] =-grad(X[i,j]+X_reduced[i,j])[j]+Y[i]+Y_reduced[i]</em></p>
<p><em>A</em> and <em>A_reduced</em> are of rank four, <em>B</em>, <em>B_reduced</em>, <em>C</em> and
<em>C_reduced</em> are each of rank three, <em>D</em>, <em>D_reduced</em>, <em>X_reduced</em> and
<em>X</em> are each of rank two and <em>Y</em> and <em>Y_reduced</em> are of rank one.
The natural boundary conditions take the form:</p>
<p><em>n[j]*((A[i,j,k,l]+A_reduced[i,j,k,l])*grad(u[k])[l]+(B[i,j,k]+B_reduced[i,j,k])*u[k])+(d[i,k]+d_reduced[i,k])*u[k]=n[j]*(X[i,j]+X_reduced[i,j])+y[i]+y_reduced[i]</em></p>
<p>The coefficient <em>d</em> is of rank two and <em>y</em> is of rank one both in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnBoundary</span></code>. The coefficients
<em>d_reduced</em> is of rank two and <em>y_reduced</em> is of rank one both in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnBoundary</span></code>.</p>
<p>Constraints take the form</p>
<p><em>u[i]=r[i]</em>  where  <em>q[i]&gt;0</em></p>
<p><em>r</em> and <em>q</em> are each rank one. Notice that at some locations not
necessarily all components must have a constraint.</p>
<p>The system of PDEs is symmetrical if</p>
<blockquote>
<div><ul class="simple">
<li><em>A[i,j,k,l]=A[k,l,i,j]</em></li>
<li><em>A_reduced[i,j,k,l]=A_reduced[k,l,i,j]</em></li>
<li><em>B[i,j,k]=C[k,i,j]</em></li>
<li><em>B_reduced[i,j,k]=C_reduced[k,i,j]</em></li>
<li><em>D[i,k]=D[i,k]</em></li>
<li><em>D_reduced[i,k]=D_reduced[i,k]</em></li>
<li><em>d[i,k]=d[k,i]</em></li>
<li><em>d_reduced[i,k]=d_reduced[k,i]</em></li>
</ul>
</div></blockquote>
<p><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a> also supports solution discontinuities over a contact region
in the domain. To specify the conditions across the discontinuity we are
using the generalised flux <em>J</em> which, in the case of a system of PDEs
and several components of the solution, is defined as</p>
<p><em>J[i,j]=(A[i,j,k,l]+A_reduced[[i,j,k,l])*grad(u[k])[l]+(B[i,j,k]+B_reduced[i,j,k])*u[k]-X[i,j]-X_reduced[i,j]</em></p>
<p>For the case of single solution component and single PDE <em>J</em> is defined as</p>
<p><em>J[j]=(A[i,j]+A_reduced[i,j])*grad(u)[j]+(B[i]+B_reduced[i])*u-X[i]-X_reduced[i]</em></p>
<p>In the context of discontinuities <em>n</em> denotes the normal on the
discontinuity pointing from side 0 towards side 1 calculated from
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace.getNormal</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactZero</span></code>.
For a system of PDEs the contact condition takes the form</p>
<p><em>n[j]*J0[i,j]=n[j]*J1[i,j]=(y_contact[i]+y_contact_reduced[i])- (d_contact[i,k]+d_contact_reduced[i,k])*jump(u)[k]</em></p>
<p>where <em>J0</em> and <em>J1</em> are the fluxes on side 0 and side 1 of the
discontinuity, respectively. <em>jump(u)</em>, which is the difference of the
solution at side 1 and at side 0, denotes the jump of <em>u</em> across
discontinuity along the normal calculated by <code class="xref py py-obj docutils literal notranslate"><span class="pre">jump</span></code>.
The coefficient <em>d_contact</em> is of rank two and <em>y_contact</em> is of rank one
both in <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactZero</span></code> or
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactOne</span></code>.
The coefficient <em>d_contact_reduced</em> is of rank two and <em>y_contact_reduced</em>
is of rank one both in <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactZero</span></code>
or <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactOne</span></code>.
In case of a single PDE and a single component solution the contact
condition takes the form</p>
<p><em>n[j]*J0_{j}=n[j]*J1_{j}=(y_contact+y_contact_reduced)-(d_contact+y_contact_reduced)*jump(u)</em></p>
<p>In this case the coefficient <em>d_contact</em> and <em>y_contact</em> are each scalar
both in <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactZero</span></code> or
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactOne</span></code> and the coefficient
<em>d_contact_reduced</em> and <em>y_contact_reduced</em> are each scalar both in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactZero</span></code> or
<code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactOne</span></code>.</p>
<p>Typical usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">LinearPDE</span><span class="p">(</span><span class="n">dom</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">setValue</span><span class="p">(</span><span class="n">A</span><span class="o">=</span><span class="n">kronecker</span><span class="p">(</span><span class="n">dom</span><span class="p">),</span> <span class="n">D</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Y</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">getSolution</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="esys.downunder.LinearPDE.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>numEquations=None</em>, <em>numSolutions=None</em>, <em>isComplex=False</em>, <em>debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a new linear PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the PDE</li>
<li><strong>numEquations</strong> – number of equations. If <code class="docutils literal notranslate"><span class="pre">None</span></code> the number of
equations is extracted from the PDE coefficients.</li>
<li><strong>numSolutions</strong> – number of solution components. If <code class="docutils literal notranslate"><span class="pre">None</span></code> the number
of solution components is extracted from the PDE
coefficients.</li>
<li><strong>debug</strong> – if True debug information is printed</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.addPDEToLumpedSystem">
<code class="descname">addPDEToLumpedSystem</code><span class="sig-paren">(</span><em>operator</em>, <em>a</em>, <em>b</em>, <em>c</em>, <em>hrz_lumping</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.addPDEToLumpedSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a PDE to the lumped system, results depend on domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OperatorAdapter</span></code>) – </li>
<li><strong>rhs</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>a</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>b</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>c</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>hrz_lumping</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.addPDEToRHS">
<code class="descname">addPDEToRHS</code><span class="sig-paren">(</span><em>righthandside</em>, <em>X</em>, <em>Y</em>, <em>y</em>, <em>y_contact</em>, <em>y_dirac</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.addPDEToRHS" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a PDE to the right hand side, results depend on domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OperatorAdapter</span></code>) – </li>
<li><strong>righthandside</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>Y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>y_contact</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>y_dirac</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.addPDEToSystem">
<code class="descname">addPDEToSystem</code><span class="sig-paren">(</span><em>operator</em>, <em>righthandside</em>, <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em>, <em>X</em>, <em>Y</em>, <em>d</em>, <em>y</em>, <em>d_contact</em>, <em>y_contact</em>, <em>d_dirac</em>, <em>y_dirac</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.addPDEToSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a PDE to the system, results depend on domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OperatorAdapter</span></code>) – </li>
<li><strong>rhs</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>A</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>B</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>C</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>D</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>X</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>Y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>d</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>d_contact</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>y_contact</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>d_dirac</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>y_dirac</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.addToRHS">
<code class="descname">addToRHS</code><span class="sig-paren">(</span><em>rhs</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.addToRHS" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a PDE to the right hand side, results depend on domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OperatorAdapter</span></code>) – </li>
<li><strong>righthandside</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>data</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.addToSystem">
<code class="descname">addToSystem</code><span class="sig-paren">(</span><em>op</em>, <em>rhs</em>, <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.addToSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>adds a PDE to the system, results depend on domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mat</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">OperatorAdapter</span></code>) – </li>
<li><strong>rhs</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – </li>
<li><strong>data</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.alteredCoefficient">
<code class="descname">alteredCoefficient</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.alteredCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Announces that coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code> has been changed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – name of the coefficient affected</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.IllegalCoefficient" title="esys.escript.linearPDEs.IllegalCoefficient"><strong>IllegalCoefficient</strong></a> – if <code class="docutils literal notranslate"><span class="pre">name</span></code> is not a coefficient of the PDE</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">if <code class="docutils literal notranslate"><span class="pre">name</span></code> is q or r, the method will not trigger a rebuild of the
system as constraints are applied to the solved system.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.checkReciprocalSymmetry">
<code class="descname">checkReciprocalSymmetry</code><span class="sig-paren">(</span><em>name0</em>, <em>name1</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.checkReciprocalSymmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests two coefficients for reciprocal symmetry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name0</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the first coefficient</li>
<li><strong>name1</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the second coefficient</li>
<li><strong>verbose</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if set to True or not present a report on coefficients
which break the symmetry is printed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if coefficients <code class="docutils literal notranslate"><span class="pre">name0</span></code> and <code class="docutils literal notranslate"><span class="pre">name1</span></code> are reciprocally
symmetric.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.checkSymmetricTensor">
<code class="descname">checkSymmetricTensor</code><span class="sig-paren">(</span><em>name</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.checkSymmetricTensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests a coefficient for symmetry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the coefficient</li>
<li><strong>verbose</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if set to True or not present a report on coefficients
which break the symmetry is printed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">True if coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code> is symmetric</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.checkSymmetry">
<code class="descname">checkSymmetry</code><span class="sig-paren">(</span><em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.checkSymmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests the PDE for symmetry.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>verbose</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if set to True or not present a report on coefficients
which break the symmetry is printed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if the PDE is symmetric</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">This is a very expensive operation. It should be used for
degugging only! The symmetry flag is not altered.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.createCoefficient">
<code class="descname">createCoefficient</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.createCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object corresponding to coefficient
<code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code> initialized to 0</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.IllegalCoefficient" title="esys.escript.linearPDEs.IllegalCoefficient"><strong>IllegalCoefficient</strong></a> – if <code class="docutils literal notranslate"><span class="pre">name</span></code> is not a coefficient of the PDE</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.createOperator">
<code class="descname">createOperator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.createOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an instance of a new operator.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.createRightHandSide">
<code class="descname">createRightHandSide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.createRightHandSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an instance of a new right hand side.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.createSolution">
<code class="descname">createSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.createSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an instance of a new solution.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getCoefficient">
<code class="descname">getCoefficient</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – name of the coefficient requested</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the value of the coefficient</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.IllegalCoefficient" title="esys.escript.linearPDEs.IllegalCoefficient"><strong>IllegalCoefficient</strong></a> – if <code class="docutils literal notranslate"><span class="pre">name</span></code> is not a coefficient of the PDE</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getCurrentOperator">
<code class="descname">getCurrentOperator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getCurrentOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the operator in its current state.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getCurrentRightHandSide">
<code class="descname">getCurrentRightHandSide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getCurrentRightHandSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the right hand side in its current state.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getCurrentSolution">
<code class="descname">getCurrentSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getCurrentSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution in its current state.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getDim">
<code class="descname">getDim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getDim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the spatial dimension of the PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the spatial dimension of the PDE domain</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the domain of the PDE</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getDomainStatus">
<code class="descname">getDomainStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getDomainStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the status indicator of the domain</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getFlux">
<code class="descname">getFlux</code><span class="sig-paren">(</span><em>u=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getFlux" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the flux <em>J</em> for a given <em>u</em>.</p>
<p><em>J[i,j]=(A[i,j,k,l]+A_reduced[A[i,j,k,l]]*grad(u[k])[l]+(B[i,j,k]+B_reduced[i,j,k])u[k]-X[i,j]-X_reduced[i,j]</em></p>
<p>or</p>
<p><em>J[j]=(A[i,j]+A_reduced[i,j])*grad(u)[l]+(B[j]+B_reduced[j])u-X[j]-X_reduced[j]</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> or None) – argument in the flux. If u is not present or equals <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> the
current solution is used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">flux</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getFunctionSpaceForCoefficient">
<code class="descname">getFunctionSpaceForCoefficient</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getFunctionSpaceForCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code> to be used for
coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – name of the coefficient enquired</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the function space to be used for coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.IllegalCoefficient" title="esys.escript.linearPDEs.IllegalCoefficient"><strong>IllegalCoefficient</strong></a> – if <code class="docutils literal notranslate"><span class="pre">name</span></code> is not a coefficient of the PDE</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getFunctionSpaceForEquation">
<code class="descname">getFunctionSpaceForEquation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getFunctionSpaceForEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code> used to discretize
the equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation space of equation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getFunctionSpaceForSolution">
<code class="descname">getFunctionSpaceForSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getFunctionSpaceForSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code> used to represent
the solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">representation space of solution</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getNumEquations">
<code class="descname">getNumEquations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getNumEquations" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of equations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of equations</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.UndefinedPDEError" title="esys.escript.linearPDEs.UndefinedPDEError"><strong>UndefinedPDEError</strong></a> – if the number of equations is not specified yet</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getNumSolutions">
<code class="descname">getNumSolutions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getNumSolutions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of unknowns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of unknowns</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.UndefinedPDEError" title="esys.escript.linearPDEs.UndefinedPDEError"><strong>UndefinedPDEError</strong></a> – if the number of unknowns is not specified yet</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getOperator">
<code class="descname">getOperator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the operator of the linear problem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the operator of the problem</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getOperatorType">
<code class="descname">getOperatorType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getOperatorType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current system type.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getRequiredOperatorType">
<code class="descname">getRequiredOperatorType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getRequiredOperatorType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the system type which needs to be used by the current set up.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getResidual">
<code class="descname">getResidual</code><span class="sig-paren">(</span><em>u=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getResidual" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the residual of u or the current solution if u is not present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>u</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> or None) – argument in the residual calculation. It must be representable
in <code class="xref py py-obj docutils literal notranslate"><span class="pre">self.getFunctionSpaceForSolution()</span></code>. If u is not present
or equals <code class="docutils literal notranslate"><span class="pre">None</span></code> the current solution is used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">residual of u</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getRightHandSide">
<code class="descname">getRightHandSide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getRightHandSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the right hand side of the linear problem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the right hand side of the problem</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getShapeOfCoefficient">
<code class="descname">getShapeOfCoefficient</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getShapeOfCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape of the coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – name of the coefficient enquired</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the shape of the coefficient <code class="docutils literal notranslate"><span class="pre">name</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.IllegalCoefficient" title="esys.escript.linearPDEs.IllegalCoefficient"><strong>IllegalCoefficient</strong></a> – if <code class="docutils literal notranslate"><span class="pre">name</span></code> is not a coefficient of the PDE</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getSolution">
<code class="descname">getSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solution of the PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the solution</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getSolverOptions">
<code class="descname">getSolverOptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solver options</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverOptions</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getSystem">
<code class="descname">getSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the operator and right hand side of the PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the discrete version of the PDE</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">Operator</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.getSystemStatus">
<code class="descname">getSystemStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.getSystemStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the domain status used to build the current system</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.hasCoefficient">
<code class="descname">hasCoefficient</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.hasCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of a coefficient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – name of the coefficient enquired</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of a coefficient of the general PDE,
False otherwise</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.initializeSystem">
<code class="descname">initializeSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.initializeSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the system clearing the operator, right hand side and solution.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.insertConstraint">
<code class="descname">insertConstraint</code><span class="sig-paren">(</span><em>rhs_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.insertConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the constraints defined by q and r to the PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rhs_only</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True only the right hand side is altered by the
constraint</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.introduceCoefficients">
<code class="descname">introduceCoefficients</code><span class="sig-paren">(</span><em>**coeff</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.introduceCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduces new coefficients into the problem.</p>
<p>Use:</p>
<p>p.introduceCoefficients(A=PDECoef(…), B=PDECoef(…))</p>
<p>to introduce the coefficients <em>A</em> and <em>B</em>.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.invalidateOperator">
<code class="descname">invalidateOperator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.invalidateOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates the operator has to be rebuilt next time it is used.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.invalidateRightHandSide">
<code class="descname">invalidateRightHandSide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.invalidateRightHandSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates the right hand side has to be rebuilt next time it is used.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.invalidateSolution">
<code class="descname">invalidateSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.invalidateSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates the PDE has to be resolved if the solution is requested.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.invalidateSystem">
<code class="descname">invalidateSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.invalidateSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Announces that everything has to be rebuilt.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isComplex">
<code class="descname">isComplex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isComplex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this is a complex-valued LinearProblem, false if
real-valued.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isHermitian">
<code class="descname">isHermitian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isHermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the pde is indicated to be Hermitian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if a Hermitian PDE is indicated, False otherwise</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">the method is equivalent to use getSolverOptions().isHermitian()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isOperatorValid">
<code class="descname">isOperatorValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isOperatorValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the operator is still valid.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isRightHandSideValid">
<code class="descname">isRightHandSideValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isRightHandSideValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the operator is still valid.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isSolutionValid">
<code class="descname">isSolutionValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isSolutionValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the solution is still valid.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isSymmetric">
<code class="descname">isSymmetric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isSymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if symmetry is indicated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if a symmetric PDE is indicated, False otherwise</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">the method is equivalent to use getSolverOptions().isSymmetric()</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isSystemValid">
<code class="descname">isSystemValid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isSystemValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the system (including solution) is still vaild.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.isUsingLumping">
<code class="descname">isUsingLumping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.isUsingLumping" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if matrix lumping is the current solver method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if the current solver method is lumping</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.preservePreconditioner">
<code class="descname">preservePreconditioner</code><span class="sig-paren">(</span><em>preserve=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.preservePreconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Notifies the PDE that the preconditioner should not be reset when
making changes to the operator.</p>
<p>Building the preconditioner data can be quite expensive (e.g. for
multigrid methods) so if it is known that changes to the operator are
going to be minor calling this method can speed up successive PDE
solves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">Not all operator types support this.</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>preserve</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True, preconditioner will be preserved, otherwise
it will be reset when making changes to the operator,
which is the default behaviour.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.reduceEquationOrder">
<code class="descname">reduceEquationOrder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.reduceEquationOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the status of order reduction for the equation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if reduced interpolation order is used for the
representation of the equation, False otherwise</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.reduceSolutionOrder">
<code class="descname">reduceSolutionOrder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.reduceSolutionOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the status of order reduction for the solution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">True if reduced interpolation order is used for the
representation of the solution, False otherwise</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.resetAllCoefficients">
<code class="descname">resetAllCoefficients</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.resetAllCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all coefficients to their default values.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.resetOperator">
<code class="descname">resetOperator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.resetOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes sure that the operator is instantiated and returns it initialized
with zeros.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.resetRightHandSide">
<code class="descname">resetRightHandSide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.resetRightHandSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the right hand side to zero.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.resetRightHandSideCoefficients">
<code class="descname">resetRightHandSideCoefficients</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.resetRightHandSideCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all coefficients defining the right hand side</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.resetSolution">
<code class="descname">resetSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.resetSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the solution to zero.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setDebug">
<code class="descname">setDebug</code><span class="sig-paren">(</span><em>flag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setDebug" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches debug output on if <code class="docutils literal notranslate"><span class="pre">flag</span></code> is True otherwise it is switched off.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flag</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – desired debug status</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setDebugOff">
<code class="descname">setDebugOff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setDebugOff" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches debug output off.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setDebugOn">
<code class="descname">setDebugOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setDebugOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches debug output on.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setHermitian">
<code class="descname">setHermitian</code><span class="sig-paren">(</span><em>flag=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setHermitian" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the Hermitian flag to <code class="docutils literal notranslate"><span class="pre">flag</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flag</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – If True, the Hermitian flag is set otherwise reset.</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">The method overwrites the Hermitian flag set by the solver options</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setHermitianOff">
<code class="descname">setHermitianOff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setHermitianOff" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the Hermitian flag.
:note: The method overwrites the Hermitian flag set by the solver options</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setHermitianOn">
<code class="descname">setHermitianOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setHermitianOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the Hermitian flag.
:note: The method overwrites the Hermitian flag set by the solver options</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderForEquationOff">
<code class="descname">setReducedOrderForEquationOff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderForEquationOff" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches reduced order off for equation representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderForEquationOn">
<code class="descname">setReducedOrderForEquationOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderForEquationOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches reduced order on for equation representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderForEquationTo">
<code class="descname">setReducedOrderForEquationTo</code><span class="sig-paren">(</span><em>flag=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderForEquationTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets order reduction state for equation representation according to flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flag</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if flag is True, the order reduction is switched on for
equation representation, otherwise or if flag is not present
order reduction is switched off</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderForSolutionOff">
<code class="descname">setReducedOrderForSolutionOff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderForSolutionOff" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches reduced order off for solution representation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderForSolutionOn">
<code class="descname">setReducedOrderForSolutionOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderForSolutionOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches reduced order on for solution representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderForSolutionTo">
<code class="descname">setReducedOrderForSolutionTo</code><span class="sig-paren">(</span><em>flag=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderForSolutionTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets order reduction state for solution representation according to flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flag</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if flag is True, the order reduction is switched on for
solution representation, otherwise or if flag is not present
order reduction is switched off</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderOff">
<code class="descname">setReducedOrderOff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderOff" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches reduced order off for solution and equation representation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderOn">
<code class="descname">setReducedOrderOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Switches reduced order on for solution and equation representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setReducedOrderTo">
<code class="descname">setReducedOrderTo</code><span class="sig-paren">(</span><em>flag=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setReducedOrderTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets order reduction state for both solution and equation representation
according to flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flag</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True, the order reduction is switched on for both solution
and equation representation, otherwise or if flag is not
present order reduction is switched off</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><strong>RuntimeError</strong> – if order reduction is altered after a coefficient has
been set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setSolution">
<code class="descname">setSolution</code><span class="sig-paren">(</span><em>u</em>, <em>validate=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the solution assuming that makes the system valid with the tolrance
defined by the solver options</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setSolverOptions">
<code class="descname">setSolverOptions</code><span class="sig-paren">(</span><em>options=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the solver options.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>options</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverOptions</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – the new solver options. If equal <code class="docutils literal notranslate"><span class="pre">None</span></code>, the solver options are set to the default.</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">The symmetry flag of options is overwritten by the symmetry flag of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearProblem</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setSymmetry">
<code class="descname">setSymmetry</code><span class="sig-paren">(</span><em>flag=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setSymmetry" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the symmetry flag to <code class="docutils literal notranslate"><span class="pre">flag</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flag</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – If True, the symmetry flag is set otherwise reset.</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">The method overwrites the symmetry flag set by the solver options</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setSymmetryOff">
<code class="descname">setSymmetryOff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setSymmetryOff" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the symmetry flag.
:note: The method overwrites the symmetry flag set by the solver options</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setSymmetryOn">
<code class="descname">setSymmetryOn</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setSymmetryOn" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the symmetry flag.
:note: The method overwrites the symmetry flag set by the solver options</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setSystemStatus">
<code class="descname">setSystemStatus</code><span class="sig-paren">(</span><em>status=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setSystemStatus" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the system status to <code class="docutils literal notranslate"><span class="pre">status</span></code> if <code class="docutils literal notranslate"><span class="pre">status</span></code> is not present the
current status of the domain is used.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.setValue">
<code class="descname">setValue</code><span class="sig-paren">(</span><em>**coefficients</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets new values to coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coefficients</strong> – new values assigned to coefficients</li>
<li><strong>A</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">A</span></code></li>
<li><strong>A_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">A_reduced</span></code></li>
<li><strong>B</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">B</span></code></li>
<li><strong>B_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">B_reduced</span></code></li>
<li><strong>C</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">C</span></code></li>
<li><strong>C_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">C_reduced</span></code></li>
<li><strong>D</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">D</span></code></li>
<li><strong>D_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">D_reduced</span></code></li>
<li><strong>X</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">X</span></code></li>
<li><strong>X_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">X_reduced</span></code></li>
<li><strong>Y</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Function</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">Y</span></code></li>
<li><strong>Y_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunction</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">Y_reduced</span></code></li>
<li><strong>d</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnBoundary</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">d</span></code></li>
<li><strong>d_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnBoundary</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">d_reduced</span></code></li>
<li><strong>y</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnBoundary</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">y</span></code></li>
<li><strong>d_contact</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactOne</span></code>
or <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactZero</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">d_contact</span></code></li>
<li><strong>d_contact_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactOne</span></code>
or <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactZero</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">d_contact_reduced</span></code></li>
<li><strong>y_contact</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactOne</span></code>
or <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionOnContactZero</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">y_contact</span></code></li>
<li><strong>y_contact_reduced</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactOne</span></code>
or <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedFunctionOnContactZero</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">y_contact_reduced</span></code></li>
<li><strong>d_dirac</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">DiracDeltaFunctions</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">d_dirac</span></code></li>
<li><strong>y_dirac</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on <code class="xref py py-obj docutils literal notranslate"><span class="pre">DiracDeltaFunctions</span></code>) – value for coefficient <code class="docutils literal notranslate"><span class="pre">y_dirac</span></code></li>
<li><strong>r</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Solution</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedSolution</span></code>
depending on whether reduced order is used for the solution) – values prescribed to the solution at the locations of
constraints</li>
<li><strong>q</strong> (any type that can be cast to a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object on
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Solution</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">ReducedSolution</span></code>
depending on whether reduced order is used for the
representation of the equation) – mask for location of constraints</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><a class="reference internal" href="esys.escript.linearPDEs.html#esys.escript.linearPDEs.IllegalCoefficient" title="esys.escript.linearPDEs.IllegalCoefficient"><strong>IllegalCoefficient</strong></a> – if an unknown coefficient keyword is used</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.shouldPreservePreconditioner">
<code class="descname">shouldPreservePreconditioner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.shouldPreservePreconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the preconditioner / factorisation should be kept even
when resetting the operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>text</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the text message if debug mode is switched on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>text</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – message to be printed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.validOperator">
<code class="descname">validOperator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.validOperator" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks the operator as valid.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.validRightHandSide">
<code class="descname">validRightHandSide</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.validRightHandSide" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks the right hand side as valid.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.LinearPDE.validSolution">
<code class="descname">validSolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.LinearPDE.validSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Marks the solution as valid.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.Locator">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">Locator</code><span class="sig-paren">(</span><em>where</em>, <em>x=array([0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Locator provides access to the values of data objects at a given spatial
coordinate x.</p>
<p>In fact, a Locator object finds the sample in the set of samples of a
given function space or domain which is closest to the given point x.</p>
<dl class="method">
<dt id="esys.downunder.Locator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>where</em>, <em>x=array([0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a Locator to access values in Data objects on the Doamin
or FunctionSpace for the sample point which is closest to the given
point x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>where</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.FunctionSpace</span></code>) – function space</li>
<li><strong>x</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – location(s) of the Locator</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Locator.getFunctionSpace">
<code class="descname">getFunctionSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator.getFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the function space of the Locator.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Locator.getId">
<code class="descname">getId</code><span class="sig-paren">(</span><em>item=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator.getId" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identifier of the location.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Locator.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of <code class="docutils literal notranslate"><span class="pre">data</span></code> at the Locator if <code class="docutils literal notranslate"><span class="pre">data</span></code> is a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object otherwise the object is returned.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Locator.getX">
<code class="descname">getX</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator.getX" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the exact coordinates of the Locator.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Locator.setValue">
<code class="descname">setValue</code><span class="sig-paren">(</span><em>data</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Locator.setValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of the <code class="docutils literal notranslate"><span class="pre">data</span></code> at the Locator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MT2DModelTEMode">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MT2DModelTEMode</code><span class="sig-paren">(</span><em>domain</em>, <em>omega</em>, <em>x</em>, <em>Z_XY</em>, <em>eta=None</em>, <em>w0=1.0</em>, <em>mu=1.2566370614359173e-06</em>, <em>sigma0=0.01</em>, <em>airLayerLevel=None</em>, <em>coordinates=None</em>, <em>Ex_top=1</em>, <em>fixAtTop=False</em>, <em>tol=1e-08</em>, <em>saveMemory=False</em>, <em>directSolver=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.magnetotelluric2d.html#esys.downunder.forwardmodels.magnetotelluric2d.MT2DBase" title="esys.downunder.forwardmodels.magnetotelluric2d.MT2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.magnetotelluric2d.MT2DBase</span></code></a></p>
<p>Forward Model for two dimensional MT model in the TE mode for a given
frequency omega.
It defines a cost function:</p>
<blockquote>
<div><ul class="simple">
<li>defect = 1/2 integrate( sum_s w^s * ( E_x/H_y - Z_XY^s ) ) ** 2  *</li>
</ul>
</div></blockquote>
<p>where E_x is the horizontal electric field perpendicular to the YZ-domain,
horizontal magnetic field H_y=1/(i*omega*mu) * E_{x,z} with complex unit
i and permeability mu. The weighting factor w^s is set to</p>
<blockquote>
<div><ul class="simple">
<li>w^s(X) = w_0^s  *</li>
</ul>
</div></blockquote>
<p>if length(X-X^s) &lt;= eta and zero otherwise. X^s is the location of 
impedance measurement Z_XY^s, w_0^s is the level
of confidence (eg. 1/measurement error) and eta is level of spatial
confidence.</p>
<p>E_x is given as solution of the PDE</p>
<blockquote>
<div><ul class="simple">
<li>-E_{x,ii} - i omega * mu * sigma * E_x = 0</li>
</ul>
</div></blockquote>
<p>where E_x at top and bottom is set to solution for background field. Homogeneous Neuman
conditions are assumed elsewhere.</p>
<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>omega</em>, <em>x</em>, <em>Z_XY</em>, <em>eta=None</em>, <em>w0=1.0</em>, <em>mu=1.2566370614359173e-06</em>, <em>sigma0=0.01</em>, <em>airLayerLevel=None</em>, <em>coordinates=None</em>, <em>Ex_top=1</em>, <em>fixAtTop=False</em>, <em>tol=1e-08</em>, <em>saveMemory=False</em>, <em>directSolver=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a new forward model. See base class for a description of
the arguments.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.MT2DModelTEMode.getDefect" title="esys.downunder.MT2DModelTEMode.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.MT2DModelTEMode.getGradient" title="esys.downunder.MT2DModelTEMode.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – conductivity</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">E_x, E_z</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>sigma</em>, <em>Ex</em>, <em>dExdz</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the defect value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape ()) – a suggestion for conductivity</li>
<li><strong>Ex</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – electric field</li>
<li><strong>dExdz</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – vertical derivative of electric field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>sigma</em>, <em>Ex</em>, <em>dExdz</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to density.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sigma</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape ()) – a suggestion for conductivity</li>
<li><strong>Ex</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – electric field</li>
<li><strong>dExdz</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – vertical derivative of electric field</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.getWeightingFactor">
<code class="descname">getWeightingFactor</code><span class="sig-paren">(</span><em>x</em>, <em>wx0</em>, <em>x0</em>, <em>eta</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.getWeightingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the weighting factor</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTEMode.setUpPDE">
<code class="descname">setUpPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTEMode.setUpPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MT2DModelTMMode">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MT2DModelTMMode</code><span class="sig-paren">(</span><em>domain</em>, <em>omega</em>, <em>x</em>, <em>Z_YX</em>, <em>eta=None</em>, <em>w0=1.0</em>, <em>mu=1.2566370614359173e-06</em>, <em>sigma0=0.01</em>, <em>airLayerLevel=None</em>, <em>coordinates=None</em>, <em>tol=1e-08</em>, <em>saveMemory=False</em>, <em>directSolver=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.magnetotelluric2d.html#esys.downunder.forwardmodels.magnetotelluric2d.MT2DBase" title="esys.downunder.forwardmodels.magnetotelluric2d.MT2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.magnetotelluric2d.MT2DBase</span></code></a></p>
<p>Forward Model for two-dimensional MT model in the TM mode for a given
frequency omega.
It defines a cost function:</p>
<blockquote>
<div><ul class="simple">
<li>defect = 1/2 integrate( sum_s w^s * ( rho*H_x/Hy - Z_YX^s ) ) ** 2  *</li>
</ul>
</div></blockquote>
<p>where H_x is the horizontal magnetic field perpendicular to the YZ-domain,
horizontal magnetic field H_y=1/(i*omega*mu) * E_{x,z} with complex unit
i and permeability mu. The weighting factor w^s is set to</p>
<blockquote>
<div><ul class="simple">
<li>w^s(X) = w_0^s  *</li>
</ul>
</div></blockquote>
<p>if length(X-X^s) &lt;= eta and zero otherwise. X^s is the location of 
impedance measurement Z_XY^s, w_0^s is the level
of confidence (eg. 1/measurement error) and eta is level of spatial
confidence.</p>
<p>H_x is given as solution of the PDE</p>
<blockquote>
<div><ul class="simple">
<li>-(rho*H_{x,i})_{,i} + i omega * mu * H_x = 0</li>
</ul>
</div></blockquote>
<p>where H_x at top and bottom is set to solution for background field. 
Homogeneous Neuman conditions are assumed elsewhere.</p>
<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>omega</em>, <em>x</em>, <em>Z_YX</em>, <em>eta=None</em>, <em>w0=1.0</em>, <em>mu=1.2566370614359173e-06</em>, <em>sigma0=0.01</em>, <em>airLayerLevel=None</em>, <em>coordinates=None</em>, <em>tol=1e-08</em>, <em>saveMemory=False</em>, <em>directSolver=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes a new forward model. See base class for a description of
the arguments.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.MT2DModelTMMode.getDefect" title="esys.downunder.MT2DModelTMMode.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.MT2DModelTMMode.getGradient" title="esys.downunder.MT2DModelTMMode.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – resistivity</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Hx, grad(Hx)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>rho</em>, <em>Hx</em>, <em>g_Hx</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the defect value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape ()) – a suggestion for resistivity</li>
<li><strong>Hx</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – magnetic field</li>
<li><strong>g_Hx</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,2)) – gradient of magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>rho</em>, <em>Hx</em>, <em>g_Hx</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to resistivity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rho</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape ()) – a suggestion for resistivity</li>
<li><strong>Hx</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,)) – magnetic field</li>
<li><strong>g_Hx</strong> (<code class="docutils literal notranslate"><span class="pre">Data</span></code> of shape (2,2)) – gradient of magnetic field</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.getWeightingFactor">
<code class="descname">getWeightingFactor</code><span class="sig-paren">(</span><em>x</em>, <em>wx0</em>, <em>x0</em>, <em>eta</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.getWeightingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the weighting factor</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MT2DModelTMMode.setUpPDE">
<code class="descname">setUpPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MT2DModelTMMode.setUpPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MTMapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MTMapping</code><span class="sig-paren">(</span><em>sigma_prior</em>, <em>a=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MTMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.mappings.Mapping</span></code></p>
<p>mt mapping</p>
<p>sigma=sigma0*exp(a*m)</p>
<dl class="method">
<dt id="esys.downunder.MTMapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>sigma_prior</em>, <em>a=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MTMapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initializes the mapping</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sigma_prior</strong> – a a-priori conductivity</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MTMapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MTMapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MTMapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MTMapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for s</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MTMapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MTMapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MTMapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MTMapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MagneticIntensityModel">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MagneticIntensityModel</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>b</em>, <em>background_magnetic_flux_density</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModelWithPotential" title="esys.downunder.forwardmodels.base.ForwardModelWithPotential"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModelWithPotential</span></code></a></p>
<p>Forward Model for magnetic intensity inversion as described in the inversion
cookbook.</p>
<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>b</em>, <em>background_magnetic_flux_density</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new magnetic intensity model on the given domain with one or more
surveys (w, b).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – data weighting factors</li>
<li><strong>b</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – magnetic intensity field data</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
<li><strong>background_magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – background magnetic flux
density (in Tesla) with components (B_east, B_north, B_vertical)</li>
<li><strong>coordinates</strong> (<em>None</em>) – defines coordinate system to be used</li>
<li><strong>fixPotentialAtBottom</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true potential is fixed to zero at the
bottom of the domain in addition to the top</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.MagneticIntensityModel.getDefect" title="esys.downunder.MagneticIntensityModel.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.MagneticIntensityModel.getGradient" title="esys.downunder.MagneticIntensityModel.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">scalar magnetic potential and corresponding magnetic field</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Vector</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getData">
<code class="descname">getData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getDataFunctionSpace">
<code class="descname">getDataFunctionSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getDataFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code> of the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>k</em>, <em>phi</em>, <em>magnetic_flux_density</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the defect.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getDefectGradient">
<code class="descname">getDefectGradient</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getDefectGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>k</em>, <em>phi</em>, <em>magnetic_flux_density</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getMisfitWeights">
<code class="descname">getMisfitWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getMisfitWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weights of the misfit function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnetic potential for a given susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">magnetic potential</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.getSurvey">
<code class="descname">getSurvey</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.getSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair (data_index, weight_index), where data_i is the data
of survey i, weight_i is the weighting factor for survey i.
If index is None, all surveys will be returned in a pair of lists.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticIntensityModel.rescaleWeights">
<code class="descname">rescaleWeights</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>k_scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticIntensityModel.rescaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>rescales the weights such that</p>
<p><em>sum_s integrate( ( w_i[s] *B_i[s]) (w_j[s]*1/L_j) * L**2 * (background_magnetic_flux_density_j[s]*1/L_j) * k_scale )=scale</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – scale of data weighting factors</li>
<li><strong>k_scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – scale of susceptibility.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MagneticInversion">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MagneticInversion</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.inversions.InversionDriver</span></code></p>
<p>Driver class to perform an inversion of magnetic anomaly data. The class
uses the standard <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a> class for a single level set function,
<a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a> mapping and the linear magnetic forward model
<a class="reference internal" href="#esys.downunder.MagneticModel" title="esys.downunder.MagneticModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MagneticModel</span></code></a>.</p>
<dl class="method">
<dt id="esys.downunder.MagneticInversion.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an instance of an inversion driver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>solverclass</strong> (<em>'AbstractMinimizer'.</em>) – class of the solver to be used.</li>
<li><strong>self_demagnetization</strong> – if True self-demagnitization is applied.</li>
<li><strong>magnetic_intensity_data</strong> – if True magnetic intensity is used in the cost function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.fixGravityPotentialAtBottom">
<code class="descname">fixGravityPotentialAtBottom</code><span class="sig-paren">(</span><em>status=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.fixGravityPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the gravity potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True gravity potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.fixMagneticPotentialAtBottom">
<code class="descname">fixMagneticPotentialAtBottom</code><span class="sig-paren">(</span><em>status=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.fixMagneticPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the magnetic potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True magnetic potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the cost function of the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘InversionCostFunction’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the inversion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.getLevelSetFunction">
<code class="descname">getLevelSetFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.getLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the level set function as solution of the optimization problem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.getSolver">
<code class="descname">getSolver</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.getSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver to be used in the inversion process. See the minimizers
module for available solvers. By default, the L-BFGS minimizer is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘AbstractMinimizer’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.isSetUp">
<code class="descname">isSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.isSetUp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns True if the inversion is set up and is ready to run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">physical parameters as result of the inversion</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of physical parameters or a physical parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>costfunction</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the cost function of the inversion. This function needs to be
called before the inversion iteration can be started.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>costfunction</strong> (<em>'InversionCostFunction'</em>) – domain of the inversion</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.setInitialGuess">
<code class="descname">setInitialGuess</code><span class="sig-paren">(</span><em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.setInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>set the initial guess <em>k</em> for susceptibility for the inversion iteration. If no <em>k</em> present
then an appropriate initial guess is chosen.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – initial value for the susceptibility anomaly.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.setSolverCallback">
<code class="descname">setSolverCallback</code><span class="sig-paren">(</span><em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.setSolverCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the callback function which is called after every solver
iteration.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.setSolverMaxIterations">
<code class="descname">setSolverMaxIterations</code><span class="sig-paren">(</span><em>maxiter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.setSolverMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of solver iterations to run.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">maxiter</span></code> is reached the iteration is terminated and
<a class="reference internal" href="#esys.downunder.MinimizerMaxIterReached" title="esys.downunder.MinimizerMaxIterReached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerMaxIterReached</span></code></a> is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxiter</strong> (positive <code class="docutils literal notranslate"><span class="pre">int</span></code>) – maximum number of iteration steps.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.setSolverTolerance">
<code class="descname">setSolverTolerance</code><span class="sig-paren">(</span><em>m_tol=None</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.setSolverTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the error tolerance for the solver. An acceptable solution is
considered to be found once the tolerance is reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to level set function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>
changes to the level set function are not checked for
convergence during iteration.</li>
<li><strong>J_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to cost function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> changes
to the cost function are not checked for convergence
during iteration.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if both arguments are <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> the default setting m_tol=1e-4,
J_tol=None is used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>domainbuilder</em>, <em>k0=None</em>, <em>dk=None</em>, <em>z0=None</em>, <em>beta=None</em>, <em>w0=None</em>, <em>w1=None</em>, <em>k_at_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the inversion from a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.
If magnetic data are given as scalar it is assumed that values are
collected in direction of the background magnetic field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domainbuilder</strong> (<a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>) – Domain builder object with gravity source(s)</li>
<li><strong>k0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference susceptibility, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>dk</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility scale, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, 1. is used.</li>
<li><strong>z0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference depth for depth weighting, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – exponent for  depth weighting, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>w0</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for level set term regularization. If not set zero is assumed.</li>
<li><strong>w1</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for the gradient term in the regularization. If not set zero is assumed</li>
<li><strong>k_at_depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – value for susceptibility at depth, see <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticInversion.siloWriterCallback">
<code class="descname">siloWriterCallback</code><span class="sig-paren">(</span><em>k</em>, <em>x</em>, <em>Jx</em>, <em>g_Jx</em>, <em>norm_dJ=None</em>, <em>norm_dx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticInversion.siloWriterCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function that can be used to track the solution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> – iteration count</li>
<li><strong>x</strong> – current approximation</li>
<li><strong>Jx</strong> – value of cost function</li>
<li><strong>g_Jx</strong> – gradient of f at x</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MagneticModel">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MagneticModel</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>B</em>, <em>background_magnetic_flux_density</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModelWithPotential" title="esys.downunder.forwardmodels.base.ForwardModelWithPotential"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModelWithPotential</span></code></a></p>
<p>Forward Model for magnetic inversion as described in the inversion
cookbook.</p>
<dl class="method">
<dt id="esys.downunder.MagneticModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>B</em>, <em>background_magnetic_flux_density</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new magnetic model on the given domain with one or more
surveys (w, B).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – data weighting factors</li>
<li><strong>B</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field data</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
<li><strong>background_magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – background magnetic flux
density (in Tesla) with components (B_east, B_north, B_vertical)</li>
<li><strong>coordinates</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a> or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>fixPotentialAtBottom</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true potential is fixed to zero at the
bottom of the domain in addition to the top</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.MagneticModel.getDefect" title="esys.downunder.MagneticModel.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.MagneticModel.getGradient" title="esys.downunder.MagneticModel.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">scalar magnetic potential and corresponding magnetic field</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Vector</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getData">
<code class="descname">getData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getDataFunctionSpace">
<code class="descname">getDataFunctionSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getDataFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code> of the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>k</em>, <em>phi</em>, <em>magnetic_flux_density</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the defect.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getDefectGradient">
<code class="descname">getDefectGradient</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getDefectGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>k</em>, <em>phi</em>, <em>magnetic_flux_density</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getMisfitWeights">
<code class="descname">getMisfitWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getMisfitWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weights of the misfit function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnetic potential for a given susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">magnetic potential</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.getSurvey">
<code class="descname">getSurvey</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.getSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair (data_index, weight_index), where data_i is the data
of survey i, weight_i is the weighting factor for survey i.
If index is None, all surveys will be returned in a pair of lists.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MagneticModel.rescaleWeights">
<code class="descname">rescaleWeights</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>k_scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MagneticModel.rescaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>rescales the weights such that</p>
<p><em>sum_s integrate( ( w_i[s] *B_i[s]) (w_j[s]*1/L_j) * L**2 * (background_magnetic_flux_density_j[s]*1/L_j) * k_scale )=scale</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – scale of data weighting factors</li>
<li><strong>k_scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – scale of susceptibility.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.Mapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract mapping class to map level set functions <em>m</em> to physical
parameters <em>p</em>.</p>
<dl class="method">
<dt id="esys.downunder.Mapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Mapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Mapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Mapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Mapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Mapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for physical parameter p</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Mapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Mapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Mapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Mapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MeteredCostFunction">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MeteredCostFunction</code><a class="headerlink" href="#esys.downunder.MeteredCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.CostFunction</span></code></p>
<p>This an intrumented version of the <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a> class. The function
calls update statistical information.
The actual work is done by the methods with corresponding name and a
leading underscore. These functions need to be overwritten for a particular
cost function implementation.</p>
<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>the base constructor initializes the counters so subclasses should
ensure the super class constructor is called.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>returns precalculated values that are shared in the calculation of
<em>f(x)</em> and <em>grad f(x)</em> and the Hessian operator</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tuple returned by this call will be passed back to this <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a> in other
calls(eg: <code class="docutils literal notranslate"><span class="pre">getGradient</span></code>). Its contents are not specified at this level because no code, other than the <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>
which created it, will be interacting with it.
That is, the implementor can put whatever information they find useful in it.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – location of derivative</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>x</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.MeteredCostFunction.getArguments" title="esys.downunder.MeteredCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculate in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated.</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.MeteredCostFunction.getArguments" title="esys.downunder.MeteredCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">x-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value <em>f(x)</em> using the precalculated values for <em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – a solution approximation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.MeteredCostFunction.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = False</em><a class="headerlink" href="#esys.downunder.MeteredCostFunction.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.resetCounters">
<code class="descname">resetCounters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.resetCounters" title="Permalink to this definition">¶</a></dt>
<dd><p>resets all statistical counters</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MeteredCostFunction.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MeteredCostFunction.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class that the Hessian operator needs to be updated.
This method is called by the solver class.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MinimizerException">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MinimizerException</code><a class="headerlink" href="#esys.downunder.MinimizerException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>This is a generic exception thrown by a minimizer.</p>
<dl class="method">
<dt id="esys.downunder.MinimizerException.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerException.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.MinimizerException.args">
<code class="descname">args</code><a class="headerlink" href="#esys.downunder.MinimizerException.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerException.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerException.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MinimizerIterationIncurableBreakDown">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MinimizerIterationIncurableBreakDown</code><a class="headerlink" href="#esys.downunder.MinimizerIterationIncurableBreakDown" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.minimizers.MinimizerException</span></code></p>
<p>Exception thrown if the iteration scheme encountered an incurable
breakdown.</p>
<dl class="method">
<dt id="esys.downunder.MinimizerIterationIncurableBreakDown.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerIterationIncurableBreakDown.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.MinimizerIterationIncurableBreakDown.args">
<code class="descname">args</code><a class="headerlink" href="#esys.downunder.MinimizerIterationIncurableBreakDown.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerIterationIncurableBreakDown.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerIterationIncurableBreakDown.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MinimizerLBFGS">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MinimizerLBFGS</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.minimizers.AbstractMinimizer</span></code></p>
<p>Minimizer that uses the limited-memory Broyden-Fletcher-Goldfarb-Shanno
method.
See Chapter 6 of ‘Numerical Optimization’ by J. Nocedal for an explanation.</p>
<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a new minimizer for a given cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</li>
<li><strong>m_tol</strong> (<em>float</em>) – terminate interations when relative change of the level set 
function is less than or equal m_tol</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>return the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.getOptions">
<code class="descname">getOptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.getOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary of LBFGS options 
rtype: dictionary with keys ‘truncation’, ‘initialHessian’, ‘restart’, ‘max_linesearch_steps’, ‘max_zoom_steps’
‘interpolationOrder’, ‘tol_df’, ‘tol_sm’</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.getResult">
<code class="descname">getResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.getResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of the minimization.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.logSummary">
<code class="descname">logSummary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.logSummary" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a summary of the completed minimization process to the logger.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>The callback function is called with the following arguments:</dt>
<dd>k       - iteration number
x       - current estimate
Jx      - value of cost function at x
g_Jx    - gradient of cost function at x
norm_dJ - ||Jx_k - Jx_{k-1}|| (only if J_tol is set)
norm_dx - ||x_k - x_{k-1}|| (only if m_tol is set)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – Level set function representing our initial guess</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Level set function representing the solution</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.setCallback">
<code class="descname">setCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.setCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a callback function to be called after every iteration.
It is up to the specific implementation what arguments are passed
to the callback. Subclasses should at least pass the current
iteration number k, the current estimate x, and possibly f(x),
grad f(x), and the current error.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>J</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>set the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.setMaxIterations">
<code class="descname">setMaxIterations</code><span class="sig-paren">(</span><em>imax</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.setMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of iterations before the minimizer terminates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.setOptions">
<code class="descname">setOptions</code><span class="sig-paren">(</span><em>**opts</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.setOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>setOptions for LBFGS.  use       solver.setOptions( key = value)
:key truncation: sets the number of previous LBFGS iterations to keep
:type truncation : int
:default truncation: 30
:key initialHessian: 1 if initial Hessian is given
:type initialHessian: 1 or 0    
:default initialHessian: 1       
:key restart: restart after this many iteration steps
:type restart: int
:default restart: 60
:key max_linesearch_steps: maximum number of line search iterations
:type max_linesearch_steps: int
:default max_linesearch_steps: 25  
:key max_zoom_steps: maximum number of zoom iterations
:type max_zoom_steps: int
:default max_zoom_steps: 60
:key interpolationOrder: order of the interpolation used for line search 
:type interpolationOrder: 1,2,3 or 4
:default interpolationOrder: 1      
:key tol_df: interpolated value of alpha, alpha_i, must differ</p>
<blockquote>
<div>: from the previous value by at least this much 
: abs(alpha_i-alpha_{i-1}) &lt; tol_df  (line search)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default tol_df:</th><td class="field-body"><p class="first">1e-6</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Key tol_sm:</th><td class="field-body"><p class="first">interpolated value of alpha must not be less than tol_sm
: abs(alpha_i) &lt; tol_sm*abs(alpha_{i-1})</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Default tol_sm:</th><td class="field-body"><p class="first">1e-5</p>
<dl class="last docutils">
<dt>Example of usage::</dt>
<dd><p class="first last">cf=DerivedCostFunction()
solver=MinimizerLBFGS(J=cf, m_tol = 1e-5, J_tol = 1e-5, imax=300)
solver.setOptions(truncation=20, tol_df =1e-7)
solver.run(initial_m)
result=solver.getResult()</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerLBFGS.setTolerance">
<code class="descname">setTolerance</code><span class="sig-paren">(</span><em>m_tol=0.0001</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerLBFGS.setTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the tolerance for the stopping criterion. The minimizer stops
when an appropriate norm is less than <code class="xref py py-obj docutils literal notranslate"><span class="pre">m_tol</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MinimizerMaxIterReached">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MinimizerMaxIterReached</code><a class="headerlink" href="#esys.downunder.MinimizerMaxIterReached" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.minimizers.MinimizerException</span></code></p>
<p>Exception thrown if the maximum number of iteration steps is reached.</p>
<dl class="method">
<dt id="esys.downunder.MinimizerMaxIterReached.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerMaxIterReached.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.MinimizerMaxIterReached.args">
<code class="descname">args</code><a class="headerlink" href="#esys.downunder.MinimizerMaxIterReached.args" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerMaxIterReached.with_traceback">
<code class="descname">with_traceback</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerMaxIterReached.with_traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.MinimizerNLCG">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">MinimizerNLCG</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.minimizers.AbstractMinimizer</span></code></p>
<p>Minimizer that uses the nonlinear conjugate gradient method
(Fletcher-Reeves variant).</p>
<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a new minimizer for a given cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</li>
<li><strong>m_tol</strong> (<em>float</em>) – terminate interations when relative change of the level set 
function is less than or equal m_tol</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>return the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.getOptions">
<code class="descname">getOptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.getOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of minimizer-specific options.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.getResult">
<code class="descname">getResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.getResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of the minimization.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.logSummary">
<code class="descname">logSummary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.logSummary" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a summary of the completed minimization process to the logger.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>The callback function is called with the following arguments:</dt>
<dd>k     - iteration number
x     - current estimate
Jx    - value of cost function at x
g_Jx  - gradient of cost function at x
gnorm - norm of g_Jx (stopping criterion)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.setCallback">
<code class="descname">setCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.setCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a callback function to be called after every iteration.
It is up to the specific implementation what arguments are passed
to the callback. Subclasses should at least pass the current
iteration number k, the current estimate x, and possibly f(x),
grad f(x), and the current error.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>J</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>set the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.setMaxIterations">
<code class="descname">setMaxIterations</code><span class="sig-paren">(</span><em>imax</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.setMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of iterations before the minimizer terminates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.setOptions">
<code class="descname">setOptions</code><span class="sig-paren">(</span><em>**opts</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.setOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets minimizer-specific options. For a list of possible options see
<a class="reference internal" href="#esys.downunder.MinimizerNLCG.getOptions" title="esys.downunder.MinimizerNLCG.getOptions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getOptions()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.MinimizerNLCG.setTolerance">
<code class="descname">setTolerance</code><span class="sig-paren">(</span><em>m_tol=0.0001</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.MinimizerNLCG.setTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the tolerance for the stopping criterion. The minimizer stops
when an appropriate norm is less than <code class="xref py py-obj docutils literal notranslate"><span class="pre">m_tol</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.NetCdfData">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">NetCdfData</code><span class="sig-paren">(</span><em>data_type</em>, <em>filename</em>, <em>altitude=0.0</em>, <em>data_variable=None</em>, <em>error=None</em>, <em>scale_factor=None</em>, <em>null_value=None</em>, <em>reference_system=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.DataSource</span></code></p>
<p>Data Source for gridded netCDF data that use CF/COARDS conventions.</p>
<dl class="method">
<dt id="esys.downunder.NetCdfData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data_type</em>, <em>filename</em>, <em>altitude=0.0</em>, <em>data_variable=None</em>, <em>error=None</em>, <em>scale_factor=None</em>, <em>null_value=None</em>, <em>reference_system=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – file name for survey data in netCDF format</li>
<li><strong>data_type</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – type of data, must be <a class="reference internal" href="#esys.downunder.NetCdfData.GRAVITY" title="esys.downunder.NetCdfData.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GRAVITY</span></code></a> or <a class="reference internal" href="#esys.downunder.NetCdfData.MAGNETIC" title="esys.downunder.NetCdfData.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAGNETIC</span></code></a></li>
<li><strong>altitude</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – altitude of measurements in meters</li>
<li><strong>data_variable</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the netCDF variable that holds the data.
If not provided an attempt is made to determine
the variable and an exception thrown on failure.</li>
<li><strong>error</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>) – either the name of the netCDF variable that holds the
uncertainties of the measurements or a constant value
to use for the uncertainties. If a constant value is
supplied, it is scaled by the same factor as the
measurements. If not provided the error is assumed to
be 2 units for all measurements (i.e. 0.2 mGal and 2 nT
for gravity and magnetic, respectively)</li>
<li><strong>scale_factor</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – the measurements and error values are scaled by
this factor. By default, gravity data is assumed
to be given in 1e-6 m/s^2 (0.1 mGal), while
magnetic data is assumed to be in 1e-9 T (1 nT).</li>
<li><strong>null_value</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – value that is used in the file to mark undefined
areas. This information is usually included in the
file.</li>
<li><strong>reference_system</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – reference coordinate system to be used.
For a Cartesian reference (default) the
appropriate UTM transformation is applied.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">it is the responsibility of the caller to ensure all data
sources and the domain builder use the same reference system.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NetCdfData.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.NetCdfData.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NetCdfData.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.NetCdfData.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NetCdfData.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.NetCdfData.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NetCdfData.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.NetCdfData.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns ( (x0, y0), (nx, ny), (dx, dy) )</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of survey data managed by this source.
Subclasses must return <a class="reference internal" href="#esys.downunder.NetCdfData.GRAVITY" title="esys.downunder.NetCdfData.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GRAVITY</span></code></a> or <a class="reference internal" href="#esys.downunder.NetCdfData.MAGNETIC" title="esys.downunder.NetCdfData.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAGNETIC</span></code></a> or <a class="reference internal" href="#esys.downunder.NetCdfData.ACOUSTIC" title="esys.downunder.NetCdfData.ACOUSTIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ACOUSTIC</span></code></a> as appropriate.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getScaleFactor">
<code class="descname">getScaleFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getScaleFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the data scale factor for adjusting measurement to SI</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.NetCdfData.setSubsamplingFactor" title="esys.downunder.NetCdfData.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>NE</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called by the <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a> to retrieve the survey
data as <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects on the given domain.</p>
<p>Subclasses should return one or more <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects with survey data
interpolated on the given <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript</span></code> domain. The exact return type
depends on the type of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<a class="reference internal" href="esys.escript.html#esys.escript.Domain" title="esys.escript.Domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Domain</span></code></a>) – the escript domain to use</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the origin coordinates of the domain</li>
<li><strong>NE</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the number of domain elements in each dimension</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the cell sizes (node spacing) in the domain</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>All data source coordinates are converted to UTM (Universal Transverse
Mercator) in order to have useful domain extents. Subclasses should
implement this method and return the UTM zone number of the projected
coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NetCdfData.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NetCdfData.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.NumpyData">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">NumpyData</code><span class="sig-paren">(</span><em>data_type</em>, <em>data</em>, <em>error=1.0</em>, <em>length=1000.0</em>, <em>null_value=-1.0</em>, <em>tags=[]</em>, <em>origin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.DataSource</span></code></p>
<dl class="method">
<dt id="esys.downunder.NumpyData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data_type</em>, <em>data</em>, <em>error=1.0</em>, <em>length=1000.0</em>, <em>null_value=-1.0</em>, <em>tags=[]</em>, <em>origin=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A data source that uses survey data from a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> object or list
instead of a file.
The dimensionality is inferred from the shape of <code class="docutils literal notranslate"><span class="pre">data</span></code> (1- and
2-dimensional data is supported). The data origin is assumed to be
at the coordinate origin.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_type</strong> (<a class="reference internal" href="#esys.downunder.DataSource.GRAVITY" title="esys.downunder.DataSource.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.GRAVITY</span></code></a>, <a class="reference internal" href="#esys.downunder.DataSource.MAGNETIC" title="esys.downunder.DataSource.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.MAGNETIC</span></code></a>) – data type indicator</li>
<li><strong>data</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.array</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the survey data array. Note that for a cartesian coordinate
system the shape of the data is considered to be
(nz,ny,nx).</li>
<li><strong>error</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>) – constant value to use for the data uncertainties or a
numpy object with uncertainties for every data point.</li>
<li><strong>length</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>) – side length(s) of the data slice/volume. This can be
a scalar to indicate constant length in all dimensions
or an array/list of values in each coordinate dimension.</li>
<li><strong>null_value</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – value that is used in the undefined regions of the
survey data object.</li>
<li><strong>tags</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of almost any type (typically <code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>)) – a list of tags associated with the data set.</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – offset of origin of offset</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NumpyData.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.NumpyData.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NumpyData.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.NumpyData.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NumpyData.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.NumpyData.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.NumpyData.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.NumpyData.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a tuple of tuples <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">(x0,</span> <span class="pre">y0),</span> <span class="pre">(nx,</span> <span class="pre">ny),</span> <span class="pre">(dx,</span> <span class="pre">dy)</span> <span class="pre">)</span></code>, where</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">x0</span></code>, <code class="docutils literal notranslate"><span class="pre">y0</span></code> = coordinates of data origin</li>
<li><code class="docutils literal notranslate"><span class="pre">nx</span></code>, <code class="docutils literal notranslate"><span class="pre">ny</span></code> = number of data points in x and y</li>
<li><code class="docutils literal notranslate"><span class="pre">dx</span></code>, <code class="docutils literal notranslate"><span class="pre">dy</span></code> = spacing of data points in x and y</li>
</ul>
<p>This method must be implemented in subclasses.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of survey data managed by this source.
Subclasses must return <a class="reference internal" href="#esys.downunder.NumpyData.GRAVITY" title="esys.downunder.NumpyData.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GRAVITY</span></code></a> or <a class="reference internal" href="#esys.downunder.NumpyData.MAGNETIC" title="esys.downunder.NumpyData.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MAGNETIC</span></code></a> or <a class="reference internal" href="#esys.downunder.NumpyData.ACOUSTIC" title="esys.downunder.NumpyData.ACOUSTIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ACOUSTIC</span></code></a> as appropriate.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.NumpyData.setSubsamplingFactor" title="esys.downunder.NumpyData.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>NE</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called by the <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a> to retrieve the survey
data as <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects on the given domain.</p>
<p>Subclasses should return one or more <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects with survey data
interpolated on the given <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript</span></code> domain. The exact return type
depends on the type of data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<a class="reference internal" href="esys.escript.html#esys.escript.Domain" title="esys.escript.Domain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Domain</span></code></a>) – the escript domain to use</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the origin coordinates of the domain</li>
<li><strong>NE</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the number of domain elements in each dimension</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code>) – the cell sizes (node spacing) in the domain</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dummy UTM zone since this class does not use real coordinate
values.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.NumpyData.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.NumpyData.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.PoleDipoleSurvey">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">PoleDipoleSurvey</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>n</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#esys.downunder.dcresistivityforwardmodeling.DcResistivityForward" title="esys.downunder.dcresistivityforwardmodeling.DcResistivityForward"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.dcresistivityforwardmodeling.DcResistivityForward</span></code></a></p>
<p>Forward model class for a poledipole setup</p>
<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>n</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>primaryConductivity</strong> (<em>data</em>) – preset primary conductivity data object</li>
<li><strong>secondaryConductivity</strong> (<em>data</em>) – preset secondary conductivity data object</li>
<li><strong>current</strong> (<em>float</em><em> or </em><em>int</em>) – amount of current to be injected at the current electrode</li>
<li><strong>a</strong> (<em>list</em>) – the spacing between current and potential electrodes</li>
<li><strong>n</strong> (<em>float</em><em> or </em><em>int</em>) – multiple of spacing between electrodes. typicaly interger</li>
<li><strong>midPoint</strong> – midPoint of the survey, as a list containing x,y coords</li>
<li><strong>directionVector</strong> – two element list specifying the direction the
survey should extend from the midpoint</li>
<li><strong>numElectrodes</strong> (<em>int</em>) – the number of electrodes to be used in the survey
must be a multiple of 2 for polepole survey:</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.checkBounds">
<code class="descname">checkBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.checkBounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.getApparentResistivity">
<code class="descname">getApparentResistivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.getApparentResistivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.getApparentResistivityPrimary">
<code class="descname">getApparentResistivityPrimary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.getApparentResistivityPrimary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.getApparentResistivitySecondary">
<code class="descname">getApparentResistivitySecondary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.getApparentResistivitySecondary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.getApparentResistivityTotal">
<code class="descname">getApparentResistivityTotal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.getApparentResistivityTotal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.getElectrodes">
<code class="descname">getElectrodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.getElectrodes" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the list of electrodes with locations</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.PoleDipoleSurvey.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PoleDipoleSurvey.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3 list each made up of a number of list containing primary, secondary and total
potentials diferences. Each of the lists contain a list for each value of n.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.PolePoleSurvey">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">PolePoleSurvey</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#esys.downunder.dcresistivityforwardmodeling.DcResistivityForward" title="esys.downunder.dcresistivityforwardmodeling.DcResistivityForward"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.dcresistivityforwardmodeling.DcResistivityForward</span></code></a></p>
<p>Forward model class for a polepole setup</p>
<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>primaryConductivity</strong> (<em>data</em>) – preset primary conductivity data object</li>
<li><strong>secondaryConductivity</strong> (<em>data</em>) – preset secondary conductivity data object</li>
<li><strong>current</strong> (<em>float</em><em> or </em><em>int</em>) – amount of current to be injected at the current electrode</li>
<li><strong>a</strong> (<em>list</em>) – the spacing between current and potential electrodes</li>
<li><strong>midPoint</strong> – midPoint of the survey, as a list containing x,y coords</li>
<li><strong>directionVector</strong> – two element list specifying the direction the
survey should extend from the midpoint</li>
<li><strong>numElectrodes</strong> (<em>int</em>) – the number of electrodes to be used in the survey
must be a multiple of 2 for polepole survey:</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.checkBounds">
<code class="descname">checkBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.checkBounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.getApparentResistivity">
<code class="descname">getApparentResistivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.getApparentResistivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.getApparentResistivityPrimary">
<code class="descname">getApparentResistivityPrimary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.getApparentResistivityPrimary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.getApparentResistivitySecondary">
<code class="descname">getApparentResistivitySecondary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.getApparentResistivitySecondary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.getApparentResistivityTotal">
<code class="descname">getApparentResistivityTotal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.getApparentResistivityTotal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.getElectrodes">
<code class="descname">getElectrodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.getElectrodes" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the list of electrodes with locations</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.PolePoleSurvey.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.PolePoleSurvey.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list containing 3 lists one for each the primary, secondary
and total potential.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.ReferenceSystem">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">ReferenceSystem</code><span class="sig-paren">(</span><em>name='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Generic identifier for coordinate systems.</p>
<dl class="method">
<dt id="esys.downunder.ReferenceSystem.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name='none'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ReferenceSystem.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialization of reference system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the reference system</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ReferenceSystem.createTransformation">
<code class="descname">createTransformation</code><span class="sig-paren">(</span><em>domain</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ReferenceSystem.createTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an appropriate coordinate transformation on a given domain</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">needs to be overwritten by a particular reference system</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code>) – domain of transformation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ReferenceSystem.getName">
<code class="descname">getName</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ReferenceSystem.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the name of the reference system</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ReferenceSystem.isCartesian">
<code class="descname">isCartesian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ReferenceSystem.isCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>returns if the reference system is Cartesian</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">needs to be overwritten by a particular reference system</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.ReferenceSystem.isTheSame">
<code class="descname">isTheSame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.ReferenceSystem.isTheSame" title="Permalink to this definition">¶</a></dt>
<dd><p>test if argument <code class="docutils literal notranslate"><span class="pre">other</span></code> defines the same reference system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – a second reference system</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if other defines the same reference system</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">needs to be overwritten by a particular reference system</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.Regularization">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">Regularization</code><span class="sig-paren">(</span><em>domain</em>, <em>numLevelSets=1</em>, <em>w0=None</em>, <em>w1=None</em>, <em>wc=None</em>, <em>location_of_set_m=&lt;esys.escriptcore.escriptcpp.Data object&gt;</em>, <em>useDiagonalHessianApproximation=False</em>, <em>tol=1e-08</em>, <em>coordinates=None</em>, <em>scale=None</em>, <em>scale_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.CostFunction</span></code></p>
<p>The regularization term for the level set function <code class="docutils literal notranslate"><span class="pre">m</span></code> within the cost
function J for an inversion:</p>
<p><em>J(m)=1/2 * sum_k integrate( mu[k] * ( w0[k] * m_k**2 * w1[k,i] * m_{k,i}**2) + sum_l&lt;k mu_c[l,k] wc[l,k] * | curl(m_k) x curl(m_l) |^2</em></p>
<p>where w0[k], w1[k,i] and  wc[k,l] are non-negative weighting factors and
mu[k] and mu_c[l,k] are trade-off factors which may be altered
during the inversion. The weighting factors are normalized such that their
integrals over the domain are constant:</p>
<p><em>integrate(w0[k] + inner(w1[k,:],1/L[:]**2))=scale[k]</em> volume(domain)*
<em>integrate(wc[l,k]*1/L**4)=scale_c[k]</em> volume(domain) *</p>
<dl class="method">
<dt id="esys.downunder.Regularization.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>numLevelSets=1</em>, <em>w0=None</em>, <em>w1=None</em>, <em>wc=None</em>, <em>location_of_set_m=&lt;esys.escriptcore.escriptcpp.Data object&gt;</em>, <em>useDiagonalHessianApproximation=False</em>, <em>tol=1e-08</em>, <em>coordinates=None</em>, <em>scale=None</em>, <em>scale_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain</li>
<li><strong>numLevelSets</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of level sets</li>
<li><strong>w0</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape
(<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> ,) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – weighting factor for the m**2 term. If not set zero is assumed.</li>
<li><strong>w1</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape
(<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> , DIM) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – weighting factor for the grad(m_i) terms. If not set zero is assumed</li>
<li><strong>wc</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> , <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code>)) – weighting factor for the cross gradient terms. If not set
zero is assumed. Used for the case if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1
only. Only values <code class="docutils literal notranslate"><span class="pre">wc[l,k]</span></code> in the lower triangle (l&lt;k)
are used.</li>
<li><strong>location_of_set_m</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object of shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> ,) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – marks location of zero values of the level
set function <code class="docutils literal notranslate"><span class="pre">m</span></code> by a positive entry.</li>
<li><strong>useDiagonalHessianApproximation</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True cross gradient terms
between level set components are ignored when calculating
approximations of the inverse of the Hessian Operator.
This can speed-up the calculation of the inverse but may
lead to an increase of the number of iteration steps in the
inversion.</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance when solving the PDE for the inverse of the
Hessian Operator</li>
<li><strong>coordinates</strong> (ReferenceSystem` or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of
shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> ,) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – weighting factor for level set function variation terms.
If not set one is used.</li>
<li><strong>scale_c</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code>,``numLevelSets``)) – scale for the cross gradient terms. If not set
one is assumed. Used for the case if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1
only. Only values <code class="docutils literal notranslate"><span class="pre">scale_c[l,k]</span></code> in the lower triangle
(l&lt;k) are used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getArguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the regularization term</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>m</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of a gradient represented by X=r[1] and Y=r[0]
with a level set function m:</p>
<blockquote>
<div><em>Y_i*m_i + X_ij*m_{i,j}</em></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>m</em>, <em>grad_m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of the cost function J with respect to m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This implementation returns Y_k=dPsi/dm_k and X_kj=dPsi/dm_kj</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>m</em>, <em>r</em>, <em>grad_m</em>, <em>solve=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – level set function</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getNumLevelSets">
<code class="descname">getNumLevelSets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getNumLevelSets" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of level set functions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getNumTradeOffFactors">
<code class="descname">getNumTradeOffFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getNumTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of trade-off factors being used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the linear PDE to be solved for the Hessian Operator inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em>, <em>grad_m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the cost function J with respect to m.
This equation is specified in the inversion cookbook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.Regularization.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = False</em><a class="headerlink" href="#esys.downunder.Regularization.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.setTradeOffFactors">
<code class="descname">setTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.setTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the level-set variation and the
cross-gradient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">`numpy.array`</span></code>) – new values for the trade-off factors where values
mu[:numLevelSets] are the trade-off factors for the
level-set variation and the remaining values for
the cross-gradient part with
mu_c[l,k]=mu[numLevelSets+l+((k-1)*k)/2] (l&lt;k).
If no values for mu are given ones are used.
Values must be positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.setTradeOffFactorsForCrossGradient">
<code class="descname">setTradeOffFactorsForCrossGradient</code><span class="sig-paren">(</span><em>mu_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.setTradeOffFactorsForCrossGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the cross-gradient terms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu_c</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code>) – new values for the trade-off factors for the cross-gradient
terms. Values must be positive. If no value is given ones
are used. Only value mu_c[l,k] for l&lt;k are used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.setTradeOffFactorsForVariation">
<code class="descname">setTradeOffFactorsForVariation</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.setTradeOffFactorsForVariation" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the level-set variation part.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">`numpy.array`</span></code>) – new values for the trade-off factors. Values must be positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Regularization.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Regularization.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class to recalculate the Hessian operator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.Ricker">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">Ricker</code><span class="sig-paren">(</span><em>f_dom=40</em>, <em>t_dom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.seismic.html#esys.downunder.seismic.Wavelet" title="esys.downunder.seismic.Wavelet"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.seismic.Wavelet</span></code></a></p>
<p>The Ricker Wavelet w=f(t)</p>
<dl class="method">
<dt id="esys.downunder.Ricker.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>f_dom=40</em>, <em>t_dom=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up a Ricker wavelet wih dominant frequence <code class="xref py py-obj docutils literal notranslate"><span class="pre">f_dom</span></code> and
center at time <code class="xref py py-obj docutils literal notranslate"><span class="pre">t_dom</span></code>. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">t_dom</span></code> is not given an estimate
for suitable <code class="xref py py-obj docutils literal notranslate"><span class="pre">t_dom</span></code> is calculated so f(0)~0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">maximum frequence is about 2 x the dominant frequence.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Ricker.getAcceleration">
<code class="descname">getAcceleration</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker.getAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>get the acceleration f’‘(t) at time <code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Ricker.getCenter">
<code class="descname">getCenter</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker.getCenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return value of wavelet center</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Ricker.getTimeScale">
<code class="descname">getTimeScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker.getTimeScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time scale which is the inverse of the largest
frequence with a significant spectral component.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Ricker.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>get value of wavelet at time <code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Ricker.getVelocity">
<code class="descname">getVelocity</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Ricker.getVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>get the velocity f’(t) at time <code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SchlumbergerSurvey">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SchlumbergerSurvey</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>n</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#esys.downunder.dcresistivityforwardmodeling.DcResistivityForward" title="esys.downunder.dcresistivityforwardmodeling.DcResistivityForward"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.dcresistivityforwardmodeling.DcResistivityForward</span></code></a></p>
<p>Schlumberger survey forward calculation</p>
<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>n</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a skeleton class for all the other forward modeling classes.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.checkBounds">
<code class="descname">checkBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.checkBounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getApparentResistivity">
<code class="descname">getApparentResistivity</code><span class="sig-paren">(</span><em>delPhiList</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getApparentResistivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getElectrodeDict">
<code class="descname">getElectrodeDict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getElectrodeDict" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the electrode dictionary</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getElectrodes">
<code class="descname">getElectrodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getElectrodes" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the list of electrodes with locations</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getPotential" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getPotentialAnalytic">
<code class="descname">getPotentialAnalytic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getPotentialAnalytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3 list each made up of a number of list containing primary, secondary and total
potentials diferences. Each of the lists contain a list for each value of n.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getPotentialNumeric">
<code class="descname">getPotentialNumeric</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getPotentialNumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3 list each made up of a number of list containing primary, secondary and total
potentials diferences. Each of the lists contain a list for each value of n.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SchlumbergerSurvey.getSourcesSamples">
<code class="descname">getSourcesSamples</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SchlumbergerSurvey.getSourcesSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>return a list of tuples of sample locations followed by a list of tuples
of source locations.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SeismicSource">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SeismicSource</code><span class="sig-paren">(</span><em>x</em>, <em>y=0.0</em>, <em>omega=0.0</em>, <em>elevation=0.0</em>, <em>power=None</em>, <em>orientation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>describes a seimic source by location (x,y), frequency omega, power (if known) and orientation (if known).
this class is used to tag seismic data sources.</p>
<dl class="method">
<dt id="esys.downunder.SeismicSource.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>x</em>, <em>y=0.0</em>, <em>omega=0.0</em>, <em>elevation=0.0</em>, <em>power=None</em>, <em>orientation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initiale the source</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – lateral x location</li>
<li><strong>y</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – lateral y location</li>
<li><strong>omega</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – frequency of source</li>
<li><strong>elevation</strong> – elevation of source above reference level</li>
<li><strong>power</strong> (<code class="docutils literal notranslate"><span class="pre">complex</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – power of source at frequence</li>
<li><strong>orientation</strong> (vector of appropriate length or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – oriententation of source in 3D or 2D (or None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SeismicSource.getElevation">
<code class="descname">getElevation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource.getElevation" title="Permalink to this definition">¶</a></dt>
<dd><p>return elevation of source
:rtype: <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SeismicSource.getFrequency">
<code class="descname">getFrequency</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource.getFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>return frequency of source
:rtype: <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SeismicSource.getLocation">
<code class="descname">getLocation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource.getLocation" title="Permalink to this definition">¶</a></dt>
<dd><p>return location of source
:rtype: <code class="docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SeismicSource.getOrientation">
<code class="descname">getOrientation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource.getOrientation" title="Permalink to this definition">¶</a></dt>
<dd><p>return power of source orientation at frequency
:rtype: vector type object or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SeismicSource.getPower">
<code class="descname">getPower</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SeismicSource.getPower" title="Permalink to this definition">¶</a></dt>
<dd><p>return power of source at frequency
:rtype: <code class="docutils literal notranslate"><span class="pre">complex</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SelfDemagnetizationModel">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SelfDemagnetizationModel</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>B</em>, <em>background_magnetic_flux_density</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModelWithPotential" title="esys.downunder.forwardmodels.base.ForwardModelWithPotential"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModelWithPotential</span></code></a></p>
<p>Forward Model for magnetic inversion with self-demagnetization as
described in the inversion cookbook.</p>
<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>B</em>, <em>background_magnetic_flux_density</em>, <em>coordinates=None</em>, <em>fixPotentialAtBottom=False</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new magnetic model on the given domain with one or more
surveys (w, B).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – data weighting factors</li>
<li><strong>B</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field data</li>
<li><strong>background_magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> or list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – background magnetic flux
density (in Tesla) with components (B_east, B_north, B_vertical)</li>
<li><strong>coordinates</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a> or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>fixPotentialAtBottom</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if true potential is fixed to zero at the
bottom of the domain in addition to the top</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.SelfDemagnetizationModel.getDefect" title="esys.downunder.SelfDemagnetizationModel.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.SelfDemagnetizationModel.getGradient" title="esys.downunder.SelfDemagnetizationModel.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">scalar magnetic potential and corresponding magnetic field</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code>, <code class="docutils literal notranslate"><span class="pre">Vector</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getData">
<code class="descname">getData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getData" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getDataFunctionSpace">
<code class="descname">getDataFunctionSpace</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getDataFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code> of the data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>k</em>, <em>phi</em>, <em>grad_phi</em>, <em>magnetic_flux_density</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the defect.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getDefectGradient">
<code class="descname">getDefectGradient</code><span class="sig-paren">(</span><em>result</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getDefectGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the domain of the forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>k</em>, <em>phi</em>, <em>grad_phi</em>, <em>magnetic_flux_density</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</li>
<li><strong>phi</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – corresponding potential</li>
<li><strong>magnetic_flux_density</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – magnetic field</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getMisfitWeights">
<code class="descname">getMisfitWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getMisfitWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weights of the misfit function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the underlying PDE.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.LinearPDE" title="esys.downunder.LinearPDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LinearPDE</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the magnetic potential for a given susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>k</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">magnetic potential</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.getSurvey">
<code class="descname">getSurvey</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.getSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pair (data_index, weight_index), where data_i is the data
of survey i, weight_i is the weighting factor for survey i.
If index is None, all surveys will be returned in a pair of lists.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SelfDemagnetizationModel.rescaleWeights">
<code class="descname">rescaleWeights</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>k_scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SelfDemagnetizationModel.rescaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>rescales the weights such that</p>
<p><em>sum_s integrate( ( w_i[s] *B_i[s]) (w_j[s]*1/L_j) * L**2 * (background_magnetic_flux_density_j[s]*1/L_j) * k_scale )=scale</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – scale of data weighting factors</li>
<li><strong>k_scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – scale of susceptibility.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SimpleSEGYWriter">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SimpleSEGYWriter</code><span class="sig-paren">(</span><em>receiver_group=None</em>, <em>source=0.0</em>, <em>sampling_interval=0.004</em>, <em>text='some seimic data'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A simple writer for 2D and 3D seismic lines, in particular for synthetic data</p>
<p>Typical usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">esys.escript</span> <span class="k">import</span> <span class="n">unitsSI</span> <span class="k">as</span> <span class="n">U</span>
<span class="n">sw</span><span class="o">=</span><span class="n">SimpleSEGYWriter</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span><span class="mi">100</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">m</span><span class="p">,</span><span class="mi">200</span><span class="o">*</span><span class="n">U</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mf">300.</span><span class="p">],</span> <span class="n">source</span><span class="o">=</span><span class="mi">200</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">U</span><span class="o">.</span><span class="n">msec</span><span class="p">)</span>
<span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
    <span class="n">sw</span><span class="o">.</span><span class="n">addRecord</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="mf">2.</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mf">0.67</span><span class="p">,</span> <span class="n">i</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="o">*</span><span class="mi">7</span><span class="p">])</span>
<span class="n">sw</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;example.segy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">the writer uses <code class="xref py py-obj docutils literal notranslate"><span class="pre">obspy</span></code></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.SimpleSEGYWriter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>receiver_group=None</em>, <em>source=0.0</em>, <em>sampling_interval=0.004</em>, <em>text='some seimic data'</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initalize writer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>receiver_group</strong> – list of receiver coordinates (in meters). For the 2D case a list of floats is given, for the 3D case a list of coordinate tuples
are given</li>
<li><strong>source</strong> – coordinates of the source (in meters).  For the 2D case a single floats is given, for the 3D case a coordinate tuples</li>
<li><strong>sampling_interval</strong> – sample rate in seconds</li>
<li><strong>text</strong> – a text for the header file (e.g a description)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SimpleSEGYWriter.COORDINATE_SCALE">
<code class="descname">COORDINATE_SCALE</code><em class="property"> = 1000.0</em><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter.COORDINATE_SCALE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SimpleSEGYWriter.addRecord">
<code class="descname">addRecord</code><span class="sig-paren">(</span><em>record</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter.addRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a record to the traces. A time difference of sample_interval between two records is assumed.
The record mast be a list of as many values as given receivers or a float if a single receiver is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>record</strong> – list of tracks to be added to the record.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SimpleSEGYWriter.getSamplingInterval">
<code class="descname">getSamplingInterval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter.getSamplingInterval" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the sampling interval in seconds.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SimpleSEGYWriter.obspy_available">
<code class="descname">obspy_available</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter.obspy_available" title="Permalink to this definition">¶</a></dt>
<dd><p>for checking if the obspy module is available</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SimpleSEGYWriter.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SimpleSEGYWriter.write" title="Permalink to this definition">¶</a></dt>
<dd><p>writes to segy file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> – file name</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">the function uses the <code class="xref py py-obj docutils literal notranslate"><span class="pre">obspy</span></code> module.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SmoothAnomaly">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SmoothAnomaly</code><span class="sig-paren">(</span><em>lx</em>, <em>ly</em>, <em>lz</em>, <em>x</em>, <em>y</em>, <em>depth</em>, <em>v_inner=None</em>, <em>v_outer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SmoothAnomaly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.SourceFeature</span></code></p>
<p>A source feature in the form of a blob (roughly gaussian).</p>
<dl class="method">
<dt id="esys.downunder.SmoothAnomaly.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>lx</em>, <em>ly</em>, <em>lz</em>, <em>x</em>, <em>y</em>, <em>depth</em>, <em>v_inner=None</em>, <em>v_outer=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SmoothAnomaly.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Intializes the smooth anomaly data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lx</strong> – size of blob in x-dimension</li>
<li><strong>ly</strong> – size of blob in y-dimension</li>
<li><strong>lz</strong> – size of blob in z-dimension</li>
<li><strong>x</strong> – location of blob in x-dimension</li>
<li><strong>y</strong> – location of blob in y-dimension</li>
<li><strong>depth</strong> – depth of blob</li>
<li><strong>v_inner</strong> – value in the centre of the blob</li>
<li><strong>v_outer</strong> – value in the periphery of the blob</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SmoothAnomaly.getMask">
<code class="descname">getMask</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SmoothAnomaly.getMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mask of the area of interest for this feature. That is,
mask is non-zero where the value returned by <a class="reference internal" href="#esys.downunder.SmoothAnomaly.getValue" title="esys.downunder.SmoothAnomaly.getValue"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getValue()</span></code></a> should be
applied, zero elsewhere.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SmoothAnomaly.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SmoothAnomaly.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value for the area covered by mask. It can be constant
or a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object with spatial dependency.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SonicHTIWave">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SonicHTIWave</code><span class="sig-paren">(</span><em>domain, v_p, wavelet, source_tag, source_vector=[1.0, 0.0], eps=0.0, delta=0.0, azimuth=0.0, dt=None, p0=None, v0=None, absorption_zone=300.0, absorption_cut=0.01, lumping=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicHTIWave" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.seismic.html#esys.downunder.seismic.WaveBase" title="esys.downunder.seismic.WaveBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.seismic.WaveBase</span></code></a></p>
<p>Solving the HTI wave equation (along the x_0 axis) with azimuth (rotation around verticle axis)
under the assumption of zero shear wave velocities
The unknowns are the transversal (along x_0) and vertial stress (Q, P)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">In case of a two dimensional domain the second spatial dimenion is depth.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.SonicHTIWave.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain, v_p, wavelet, source_tag, source_vector=[1.0, 0.0], eps=0.0, delta=0.0, azimuth=0.0, dt=None, p0=None, v0=None, absorption_zone=300.0, absorption_cut=0.01, lumping=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicHTIWave.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the HTI wave solver</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Doamin</span></code>) – domain of the problem</li>
<li><strong>v_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical p-velocity field</li>
<li><strong>v_s</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical s-velocity field</li>
<li><strong>wavelet</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Wavelet</span></code>) – wavelet to describe the time evolution of source term</li>
<li><strong>source_tag</strong> (<em>'str'</em><em> or </em><em>'int'</em>) – tag of the source location</li>
<li><strong>source_vector</strong> – source orientation vector</li>
<li><strong>eps</strong> – first Thompsen parameter</li>
<li><strong>azimuth</strong> – azimuth (rotation around verticle axis)</li>
<li><strong>gamma</strong> – third Thompsen parameter</li>
<li><strong>rho</strong> – density</li>
<li><strong>dt</strong> – time step size. If not present a suitable time step size is calculated.</li>
<li><strong>p0</strong> – initial solution (Q(t=0), P(t=0)). If not present zero is used.</li>
<li><strong>v0</strong> – initial solution change rate. If not present zero is used.</li>
<li><strong>absorption_zone</strong> – thickness of absorption zone</li>
<li><strong>absorption_cut</strong> – boundary value of absorption decay factor</li>
<li><strong>lumping</strong> – if True mass matrix lumping is being used. This is accelerates the computing but introduces some diffusion.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SonicHTIWave.getTimeStepSize">
<code class="descname">getTimeStepSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicHTIWave.getTimeStepSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SonicHTIWave.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicHTIWave.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the solution for the next time marker t which needs to greater than the time marker from the
previous call.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SonicWave">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SonicWave</code><span class="sig-paren">(</span><em>domain</em>, <em>v_p</em>, <em>wavelet</em>, <em>source_tag</em>, <em>dt=None</em>, <em>p0=None</em>, <em>p0_t=None</em>, <em>absorption_zone=300.0</em>, <em>absorption_cut=0.01</em>, <em>lumping=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicWave" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.seismic.html#esys.downunder.seismic.WaveBase" title="esys.downunder.seismic.WaveBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.seismic.WaveBase</span></code></a></p>
<p>Solving the sonic wave equation</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">p_tt</span> <span class="pre">=</span> <span class="pre">(v_p**2</span> <span class="pre">*</span> <span class="pre">p_i)_i</span>&#160; <span class="pre">+</span> <span class="pre">f(t)</span> <span class="pre">*</span> <span class="pre">delta_s</span></code>   where (p-) velocity v_p.</p>
<p>f(t) is wavelet acting at a point source term at positon s</p>
<dl class="method">
<dt id="esys.downunder.SonicWave.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>v_p</em>, <em>wavelet</em>, <em>source_tag</em>, <em>dt=None</em>, <em>p0=None</em>, <em>p0_t=None</em>, <em>absorption_zone=300.0</em>, <em>absorption_cut=0.01</em>, <em>lumping=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicWave.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the sonic wave solver</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the problem</li>
<li><strong>v_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – p-velocity field</li>
<li><strong>wavelet</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Wavelet</span></code>) – wavelet to describe the time evolution of source term</li>
<li><strong>source_tag</strong> (<em>'str'</em><em> or </em><em>'int'</em>) – tag of the source location</li>
<li><strong>dt</strong> – time step size. If not present a suitable time step size is calculated.</li>
<li><strong>p0</strong> – initial solution. If not present zero is used.</li>
<li><strong>p0_t</strong> – initial solution change rate. If not present zero is used.</li>
<li><strong>absorption_zone</strong> – thickness of absorption zone</li>
<li><strong>absorption_cut</strong> – boundary value of absorption decay factor</li>
<li><strong>lumping</strong> – if True mass matrix lumping is being used. This is accelerates the computing but introduces some diffusion.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SonicWave.getTimeStepSize">
<code class="descname">getTimeStepSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicWave.getTimeStepSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SonicWave.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SonicWave.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the solution for the next time marker t which needs to greater than the time marker from the
previous call.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SpatialCoordinateTransformation">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SpatialCoordinateTransformation</code><span class="sig-paren">(</span><em>domain</em>, <em>reference=&lt;esys.downunder.coordinates.CartesianReferenceSystem object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Defines an orthogonal coordinate transformation from a domain into the
Cartesian domain using a coordinate transformation.</p>
<p>The default implementation is the identity transformation (i.e.
no changes are applied to the domain). Overwrite the appropriate
methods to define other coordinate systems.</p>
<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>reference=&lt;esys.downunder.coordinates.CartesianReferenceSystem object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the orthogonal coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code>) – domain in the domain of the coordinate transformation</li>
<li><strong>reference</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a>) – the reference system</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of a scalar function in direction of the
coordinate axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Vector" title="esys.escript.Vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Vector</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference system used to to define the coordinate transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.getScalingFactors">
<code class="descname">getScalingFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.getScalingFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the scaling factors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Vector" title="esys.escript.Vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Vector</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.getVolumeFactor">
<code class="descname">getVolumeFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.getVolumeFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the volume factor for the coordinate transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="esys.escript.html#esys.escript.Scalar" title="esys.escript.Scalar"><code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.Scalar</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.isCartesian">
<code class="descname">isCartesian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.isCartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the scaling factors (and the volume factor) are equal to 1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SpatialCoordinateTransformation.isTheSame">
<code class="descname">isTheSame</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SpatialCoordinateTransformation.isTheSame" title="Permalink to this definition">¶</a></dt>
<dd><p>test if argument <code class="docutils literal notranslate"><span class="pre">other</span></code> defines the same coordinate transformation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other</strong> (<a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – a second coordinate transformation</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if other defines then same coordinate transformation</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SplitInversionCostFunction">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SplitInversionCostFunction</code><span class="sig-paren">(</span><em>numLevelSets=None</em>, <em>numModels=None</em>, <em>numMappings=None</em>, <em>splitworld=None</em>, <em>worldsinit_fn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.MeteredCostFunction</span></code></p>
<p>Class to define cost function <em>J(m)</em> for inversion with one or more
forward models based on a multi-valued level set function <em>m</em>:</p>
<p><em>J(m) = J_reg(m) + sum_f mu_f * J_f(p)</em></p>
<p>where <em>J_reg(m)</em> is the regularization and cross gradient component of the
cost function applied to a level set function <em>m</em>, <em>J_f(p)</em> are the data
defect cost functions involving a physical forward model using the
physical parameter(s) <em>p</em> and <em>mu_f</em> is the trade-off factor for model f.</p>
<p>A forward model depends on a set of physical parameters <em>p</em> which are
constructed from components of the level set function <em>m</em> via mappings.</p>
<dl class="docutils">
<dt>Example 1 (single forward model):</dt>
<dd>m=Mapping()
f=ForwardModel()
J=InversionCostFunction(Regularization(), m, f)</dd>
<dt>Example 2 (two forward models on a single valued level set)</dt>
<dd><p class="first">m0=Mapping()
m1=Mapping()
f0=ForwardModel()
f1=ForwardModel()</p>
<p class="last">J=InversionCostFunction(Regularization(), mappings=[m0, m1], forward_models=[(f0, 0), (f1,1)])</p>
</dd>
<dt>Example 3 (two forward models on 2-valued level set)</dt>
<dd><p class="first">m0=Mapping()
m1=Mapping()
f0=ForwardModel()
f1=ForwardModel()</p>
<p class="last">J=InversionCostFunction(Regularization(self.numLevelSets=2), mappings=[(m0,0), (m1,0)], forward_models=[(f0, 0), (f1,1)])</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">If provides_inverse_Hessian_approximation is true, then the class
provides an approximative inverse of the Hessian operator.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>numLevelSets=None</em>, <em>numModels=None</em>, <em>numMappings=None</em>, <em>splitworld=None</em>, <em>worldsinit_fn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>fill this in.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.calculateGradient">
<code class="descname">calculateGradient</code><span class="sig-paren">(</span><em>vnames1</em>, <em>vnames2</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.calculateGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient operation produces two components (designated (Y^,X) in the non-split version).
vnames1 gives the variable name(s) where the first component should be stored.
vnames2 gives the variable name(s) where the second component should be stored.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.calculatePropertiesHelper">
<em class="property">static </em><code class="descname">calculatePropertiesHelper</code><span class="sig-paren">(</span><em>self</em>, <em>m</em>, <em>mappings</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.calculatePropertiesHelper" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the physical properties from a given level set
function <em>m</em> using the mappings of the cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – level set function</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.calculateValue">
<code class="descname">calculateValue</code><span class="sig-paren">(</span><em>vname</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.calculateValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.createLevelSetFunction">
<code class="descname">createLevelSetFunction</code><span class="sig-paren">(</span><em>*props</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.createLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an instance of an object used to represent a level set function
initialized with zeros. Components can be overwritten by physical
properties <code class="xref py py-obj docutils literal notranslate"><span class="pre">props</span></code>. If present entries must correspond to the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> arguments in the constructor. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for properties
for which no value is given.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.createLevelSetFunctionHelper">
<em class="property">static </em><code class="descname">createLevelSetFunctionHelper</code><span class="sig-paren">(</span><em>self</em>, <em>regularization</em>, <em>mappings</em>, <em>*props</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.createLevelSetFunctionHelper" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object (init-ed) with 0s.
Components can be overwritten by physical
properties <code class="xref py py-obj docutils literal notranslate"><span class="pre">props</span></code>. If present entries must correspond to the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> arguments in the constructor. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for properties
for which no value is given.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.formatMappings">
<em class="property">static </em><code class="descname">formatMappings</code><span class="sig-paren">(</span><em>mappings</em>, <em>numLevelSets</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.formatMappings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.formatModels">
<em class="property">static </em><code class="descname">formatModels</code><span class="sig-paren">(</span><em>forward_models</em>, <em>numMappings</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.formatModels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>returns precalculated values that are shared in the calculation of
<em>f(x)</em> and <em>grad f(x)</em> and the Hessian operator</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tuple returned by this call will be passed back to this <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a> in other
calls(eg: <code class="docutils literal notranslate"><span class="pre">getGradient</span></code>). Its contents are not specified at this level because no code, other than the <a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>
which created it, will be interacting with it.
That is, the implementor can put whatever information they find useful in it.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – location of derivative</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getComponentValues">
<code class="descname">getComponentValues</code><span class="sig-paren">(</span><em>m</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getComponentValues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the cost function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>x</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getForwardModel">
<code class="descname">getForwardModel</code><span class="sig-paren">(</span><em>idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getForwardModel" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <em>idx</em>-th forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idx</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – model index. If cost function contains one model only <code class="xref py py-obj docutils literal notranslate"><span class="pre">idx</span></code>
can be omitted.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.SplitInversionCostFunction.getArguments" title="esys.downunder.SplitInversionCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculate in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated.</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.SplitInversionCostFunction.getArguments" title="esys.downunder.SplitInversionCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">x-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.getModelArgs">
<em class="property">static </em><code class="descname">getModelArgs</code><span class="sig-paren">(</span><em>self</em>, <em>fwdmodels</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getModelArgs" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to import the arguments for forward models, if they are not available, 
Computes and exports them</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getNumTradeOffFactors">
<code class="descname">getNumTradeOffFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getNumTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of trade-off factors being used including the
trade-off factors used in the regularization component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getProperties">
<code class="descname">getProperties</code><span class="sig-paren">(</span><em>m</em>, <em>return_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the physical properties from a given level set
function <em>m</em> using the mappings of the cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – level set function</li>
<li><strong>return_list</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> a list is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getRegularization">
<code class="descname">getRegularization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the regularization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getTradeOffFactors">
<code class="descname">getTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the trade-off factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getTradeOffFactorsModels">
<code class="descname">getTradeOffFactorsModels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getTradeOffFactorsModels" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the trade-off factors for the forward models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value <em>f(x)</em> using the precalculated values for <em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – a solution approximation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SplitInversionCostFunction.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = True</em><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.resetCounters">
<code class="descname">resetCounters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.resetCounters" title="Permalink to this definition">¶</a></dt>
<dd><p>resets all statistical counters</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.setPoint">
<code class="descname">setPoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.setPoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.setTradeOffFactors">
<code class="descname">setTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.setTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the forward model and regularization
terms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – list of trade-off factors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.setTradeOffFactorsModels">
<code class="descname">setTradeOffFactorsModels</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.setTradeOffFactorsModels" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the forward model components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> in case of a single model or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of
<code class="docutils literal notranslate"><span class="pre">float</span></code> with the length of the number of models.) – list of the trade-off factors. If not present ones are used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.setTradeOffFactorsRegularization">
<code class="descname">setTradeOffFactorsRegularization</code><span class="sig-paren">(</span><em>mu=None</em>, <em>mu_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.setTradeOffFactorsRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the regularization component of the
cost function, see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mu</strong> – trade-off factors for the level-set variation part</li>
<li><strong>mu_c</strong> – trade-off factors for the cross gradient variation part</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.subworld_setMu_model">
<em class="property">static </em><code class="descname">subworld_setMu_model</code><span class="sig-paren">(</span><em>self</em>, <em>**args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.subworld_setMu_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitInversionCostFunction.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class that the Hessian operator needs to be updated.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitInversionCostFunction.update_point_helper">
<em class="property">static </em><code class="descname">update_point_helper</code><span class="sig-paren">(</span><em>self</em>, <em>newpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitInversionCostFunction.update_point_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>Call within a subworld to set ‘current_point’ to newpoint
and update all the cached args info</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SplitMinimizerLBFGS">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SplitMinimizerLBFGS</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.minimizers.AbstractMinimizer</span></code></p>
<p>Minimizer that uses the limited-memory Broyden-Fletcher-Goldfarb-Shanno
method.</p>
<p>version modified to fit with split world.</p>
<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>J=None</em>, <em>m_tol=0.0001</em>, <em>J_tol=None</em>, <em>imax=300</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes a new minimizer for a given cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</li>
<li><strong>m_tol</strong> (<em>float</em>) – terminate interations when relative change of the level set 
function is less than or equal m_tol</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>return the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.getOptions">
<code class="descname">getOptions</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.getOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of minimizer-specific options.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.getResult">
<code class="descname">getResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.getResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of the minimization.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.logSummary">
<code class="descname">logSummary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.logSummary" title="Permalink to this definition">¶</a></dt>
<dd><p>Outputs a summary of the completed minimization process to the logger.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.SplitMinimizerLBFGS.move_point_from_base">
<em class="property">static </em><code class="descname">move_point_from_base</code><span class="sig-paren">(</span><em>self</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.move_point_from_base" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This version relies on the costfunction already having an initial guess loaded.
It also does not return the result, meaning a job needs to be submitted to
get the result out.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.setCallback">
<code class="descname">setCallback</code><span class="sig-paren">(</span><em>callback</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.setCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a callback function to be called after every iteration.
It is up to the specific implementation what arguments are passed
to the callback. Subclasses should at least pass the current
iteration number k, the current estimate x, and possibly f(x),
grad f(x), and the current error.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>J</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>set the cost function to be minimized</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>J</strong> (<a class="reference internal" href="#esys.downunder.CostFunction" title="esys.downunder.CostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code></a>) – the cost function to be minimized</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.setMaxIterations">
<code class="descname">setMaxIterations</code><span class="sig-paren">(</span><em>imax</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.setMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of iterations before the minimizer terminates.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.setOptions">
<code class="descname">setOptions</code><span class="sig-paren">(</span><em>**opts</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.setOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets minimizer-specific options. For a list of possible options see
<a class="reference internal" href="#esys.downunder.SplitMinimizerLBFGS.getOptions" title="esys.downunder.SplitMinimizerLBFGS.getOptions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getOptions()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitMinimizerLBFGS.setTolerance">
<code class="descname">setTolerance</code><span class="sig-paren">(</span><em>m_tol=0.0001</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitMinimizerLBFGS.setTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the tolerance for the stopping criterion. The minimizer stops
when an appropriate norm is less than <code class="xref py py-obj docutils literal notranslate"><span class="pre">m_tol</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SplitRegularization">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SplitRegularization</code><span class="sig-paren">(</span><em>domain</em>, <em>numLevelSets=1</em>, <em>w0=None</em>, <em>w1=None</em>, <em>wc=None</em>, <em>location_of_set_m=&lt;esys.escriptcore.escriptcpp.Data object&gt;</em>, <em>useDiagonalHessianApproximation=False</em>, <em>tol=1e-08</em>, <em>coordinates=None</em>, <em>scale=None</em>, <em>scale_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.CostFunction</span></code></p>
<p>The regularization term for the level set function <code class="docutils literal notranslate"><span class="pre">m</span></code> within the cost
function J for an inversion:</p>
<p><em>J(m)=1/2 * sum_k integrate( mu[k] * ( w0[k] * m_k**2 * w1[k,i] * m_{k,i}**2) + sum_l&lt;k mu_c[l,k] wc[l,k] * | curl(m_k) x curl(m_l) |^2</em></p>
<p>where w0[k], w1[k,i] and  wc[k,l] are non-negative weighting factors and
mu[k] and mu_c[l,k] are trade-off factors which may be altered
during the inversion. The weighting factors are normalized such that their
integrals over the domain are constant:</p>
<p><em>integrate(w0[k] + inner(w1[k,:],1/L[:]**2))=scale[k]</em> volume(domain)*
<em>integrate(wc[l,k]*1/L**4)=scale_c[k]</em> volume(domain) *</p>
<dl class="method">
<dt id="esys.downunder.SplitRegularization.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>numLevelSets=1</em>, <em>w0=None</em>, <em>w1=None</em>, <em>wc=None</em>, <em>location_of_set_m=&lt;esys.escriptcore.escriptcpp.Data object&gt;</em>, <em>useDiagonalHessianApproximation=False</em>, <em>tol=1e-08</em>, <em>coordinates=None</em>, <em>scale=None</em>, <em>scale_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain</li>
<li><strong>numLevelSets</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of level sets</li>
<li><strong>w0</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape
(<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> ,) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – weighting factor for the m**2 term. If not set zero is assumed.</li>
<li><strong>w1</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape
(<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> , DIM) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – weighting factor for the grad(m_i) terms. If not set zero is assumed</li>
<li><strong>wc</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> , <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code>)) – weighting factor for the cross gradient terms. If not set
zero is assumed. Used for the case if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1
only. Only values <code class="docutils literal notranslate"><span class="pre">wc[l,k]</span></code> in the lower triangle (l&lt;k)
are used.</li>
<li><strong>location_of_set_m</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>
object of shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> ,) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – marks location of zero values of the level
set function <code class="docutils literal notranslate"><span class="pre">m</span></code> by a positive entry.</li>
<li><strong>useDiagonalHessianApproximation</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True cross gradient terms
between level set components are ignored when calculating
approximations of the inverse of the Hessian Operator.
This can speed-up the calculation of the inverse but may
lead to an increase of the number of iteration steps in the
inversion.</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance when solving the PDE for the inverse of the
Hessian Operator</li>
<li><strong>coordinates</strong> (ReferenceSystem` or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used</li>
<li><strong>scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> == 1 or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of
shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> ,) if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1) – weighting factor for level set function variation terms.
If not set one is used.</li>
<li><strong>scale_c</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object of shape (<code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code>,``numLevelSets``)) – scale for the cross gradient terms. If not set
one is assumed. Used for the case if <code class="docutils literal notranslate"><span class="pre">numLevelSets</span></code> &gt; 1
only. Only values <code class="docutils literal notranslate"><span class="pre">scale_c[l,k]</span></code> in the lower triangle
(l&lt;k) are used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getArguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the coordinate transformation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CoordinateTransformation</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the regularization term</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>m</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of a gradient represented by X=r[1] and Y=r[0]
with a level set function m:</p>
<blockquote>
<div><em>Y_i*m_i + X_ij*m_{i,j}</em></div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.SplitRegularization.getArguments" title="esys.downunder.SplitRegularization.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getGradientAtPoint">
<code class="descname">getGradientAtPoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getGradientAtPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of the cost function J with respect to m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This implementation returns Y_k=dPsi/dm_k and X_kj=dPsi/dm_kj</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.SplitRegularization.getArguments" title="esys.downunder.SplitRegularization.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">x-type</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body"><p class="first">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculated in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">Subclasses that implement this method should set the class
variable <a class="reference internal" href="#esys.downunder.SplitRegularization.provides_inverse_Hessian_approximation" title="esys.downunder.SplitRegularization.provides_inverse_Hessian_approximation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">provides_inverse_Hessian_approximation</span></code></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code> to
enable the solver to call this method.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getInverseHessianApproximationAtPoint">
<code class="descname">getInverseHessianApproximationAtPoint</code><span class="sig-paren">(</span><em>r</em>, <em>solve=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getInverseHessianApproximationAtPoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">m</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – level set function</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getNumLevelSets">
<code class="descname">getNumLevelSets</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getNumLevelSets" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of level set functions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getNumTradeOffFactors">
<code class="descname">getNumTradeOffFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getNumTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of trade-off factors being used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getPDE">
<code class="descname">getPDE</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getPDE" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the linear PDE to be solved for the Hessian Operator inverse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearPDEs.LinearPDE</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em>, <em>grad_m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the cost function J with respect to m.
This equation is specified in the inversion cookbook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.getValueAtPoint">
<code class="descname">getValueAtPoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.getValueAtPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the cost function J with respect to m.
This equation is specified in the inversion cookbook.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SplitRegularization.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = False</em><a class="headerlink" href="#esys.downunder.SplitRegularization.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.setPoint">
<code class="descname">setPoint</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.setPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the point which this function will work with</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code>) – level set function</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.setTradeOffFactors">
<code class="descname">setTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.setTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the level-set variation and the
cross-gradient.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">`numpy.array`</span></code>) – new values for the trade-off factors where values
mu[:numLevelSets] are the trade-off factors for the
level-set variation and the remaining values for
the cross-gradient part with
mu_c[l,k]=mu[numLevelSets+l+((k-1)*k)/2] (l&lt;k).
If no values for mu are given ones are used.
Values must be positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.setTradeOffFactorsForCrossGradient">
<code class="descname">setTradeOffFactorsForCrossGradient</code><span class="sig-paren">(</span><em>mu_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.setTradeOffFactorsForCrossGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the cross-gradient terms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu_c</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code>) – new values for the trade-off factors for the cross-gradient
terms. Values must be positive. If no value is given ones
are used. Only value mu_c[l,k] for l&lt;k are used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.setTradeOffFactorsForVariation">
<code class="descname">setTradeOffFactorsForVariation</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.setTradeOffFactorsForVariation" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the level-set variation part.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">`numpy.array`</span></code>) – new values for the trade-off factors. Values must be positive.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SplitRegularization.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SplitRegularization.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class to recalculate the Hessian operator.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.StrongJointGravityMagneticInversion">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">StrongJointGravityMagneticInversion</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.inversions.InversionDriver</span></code></p>
<p>Driver class to perform a joint inversion of Gravity (Bouguer) and magnetic
anomaly data with the assumption that there is a functional relationship
between density and susceptibility.</p>
<p>The class uses the standard <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a> class for a single level set
function, <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a> and <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a> mappings, the
gravity forward model <a class="reference internal" href="#esys.downunder.GravityModel" title="esys.downunder.GravityModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GravityModel</span></code></a> and the linear magnetic forward model
<a class="reference internal" href="#esys.downunder.MagneticModel" title="esys.downunder.MagneticModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MagneticModel</span></code></a>.</p>
<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>solverclass=None</em>, <em>debug=False</em>, <em>self_demagnetization=False</em>, <em>magnetic_intensity_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>creates an instance of an inversion driver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>solverclass</strong> (<em>'AbstractMinimizer'.</em>) – class of the solver to be used.</li>
<li><strong>self_demagnetization</strong> – if True self-demagnitization is applied.</li>
<li><strong>magnetic_intensity_data</strong> – if True magnetic intensity is used in the cost function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.DENSITY">
<code class="descname">DENSITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.DENSITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.SUSCEPTIBILITY">
<code class="descname">SUSCEPTIBILITY</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.SUSCEPTIBILITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.fixGravityPotentialAtBottom">
<code class="descname">fixGravityPotentialAtBottom</code><span class="sig-paren">(</span><em>status=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.fixGravityPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the gravity potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True gravity potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.fixMagneticPotentialAtBottom">
<code class="descname">fixMagneticPotentialAtBottom</code><span class="sig-paren">(</span><em>status=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.fixMagneticPotentialAtBottom" title="Permalink to this definition">¶</a></dt>
<dd><p>indicates to fix the magnetic potential at the bottom to zero
(in addition to the top)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>status</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if True magnetic potential at the bottom is set to zero</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.getCostFunction">
<code class="descname">getCostFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.getCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the cost function of the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘InversionCostFunction’</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the inversion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.getLevelSetFunction">
<code class="descname">getLevelSetFunction</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.getLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the level set function as solution of the optimization problem</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.getSolver">
<code class="descname">getSolver</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.getSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>The solver to be used in the inversion process. See the minimizers
module for available solvers. By default, the L-BFGS minimizer is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">‘AbstractMinimizer’.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.isSetUp">
<code class="descname">isSetUp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.isSetUp" title="Permalink to this definition">¶</a></dt>
<dd><p>returns True if the inversion is set up and is ready to run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.run">
<code class="descname">run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the inversion.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">physical parameters as result of the inversion</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of physical parameters or a physical parameter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.setCostFunction">
<code class="descname">setCostFunction</code><span class="sig-paren">(</span><em>costfunction</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.setCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the cost function of the inversion. This function needs to be
called before the inversion iteration can be started.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>costfunction</strong> (<em>'InversionCostFunction'</em>) – domain of the inversion</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.setInitialGuess">
<code class="descname">setInitialGuess</code><span class="sig-paren">(</span><em>rho=None</em>, <em>k=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.setInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>set the initial guess <em>rho</em> for density and <em>k</em> for susceptibility for
the inversion iteration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rho</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – initial value for the density anomaly.</li>
<li><strong>k</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – initial value for the susceptibility anomaly.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.setSolverCallback">
<code class="descname">setSolverCallback</code><span class="sig-paren">(</span><em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.setSolverCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the callback function which is called after every solver
iteration.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.setSolverMaxIterations">
<code class="descname">setSolverMaxIterations</code><span class="sig-paren">(</span><em>maxiter=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.setSolverMaxIterations" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the maximum number of solver iterations to run.
If <code class="xref py py-obj docutils literal notranslate"><span class="pre">maxiter</span></code> is reached the iteration is terminated and
<a class="reference internal" href="#esys.downunder.MinimizerMaxIterReached" title="esys.downunder.MinimizerMaxIterReached"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinimizerMaxIterReached</span></code></a> is thrown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxiter</strong> (positive <code class="docutils literal notranslate"><span class="pre">int</span></code>) – maximum number of iteration steps.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.setSolverTolerance">
<code class="descname">setSolverTolerance</code><span class="sig-paren">(</span><em>m_tol=None</em>, <em>J_tol=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.setSolverTolerance" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the error tolerance for the solver. An acceptable solution is
considered to be found once the tolerance is reached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to level set function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>
changes to the level set function are not checked for
convergence during iteration.</li>
<li><strong>J_tol</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>) – tolerance for changes to cost function. If <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> changes
to the cost function are not checked for convergence
during iteration.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">if both arguments are <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code> the default setting m_tol=1e-4,
J_tol=None is used.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.setup">
<code class="descname">setup</code><span class="sig-paren">(</span><em>domainbuilder</em>, <em>rho0=None</em>, <em>drho=None</em>, <em>rho_z0=None</em>, <em>rho_beta=None</em>, <em>k0=None</em>, <em>dk=None</em>, <em>k_z0=None</em>, <em>k_beta=None</em>, <em>w0=None</em>, <em>w1=None</em>, <em>w_gc=None</em>, <em>rho_at_depth=None</em>, <em>k_at_depth=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the inversion from an instance <code class="docutils literal notranslate"><span class="pre">domainbuilder</span></code> of a
<a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>. Gravity and magnetic data attached to the
<code class="docutils literal notranslate"><span class="pre">domainbuilder</span></code> are considered in the inversion.
If magnetic data are given as scalar it is assumed that values are
collected in direction of the background magnetic field.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domainbuilder</strong> (<a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>) – Domain builder object with gravity source(s)</li>
<li><strong>rho0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference density, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified,
zero is used.</li>
<li><strong>drho</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – density scale, see <a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified,
2750 kg/m^3 is used.</li>
<li><strong>rho_z0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference depth for depth weighting for density, see
<a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>rho_beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – exponent for density depth weighting, see
<a class="reference internal" href="#esys.downunder.DensityMapping" title="esys.downunder.DensityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DensityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>k0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference susceptibility, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>.
If not specified, zero is used.</li>
<li><strong>dk</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – susceptibility scale, see <a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not
specified, 1. is used.</li>
<li><strong>k_z0</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – reference depth for susceptibility depth weighting, see
<a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>k_beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code>) – exponent for susceptibility depth weighting, see
<a class="reference internal" href="#esys.downunder.SusceptibilityMapping" title="esys.downunder.SusceptibilityMapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SusceptibilityMapping</span></code></a>. If not specified, zero is used.</li>
<li><strong>w0</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> or <code class="docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for level set term in the regularization.
If not set zero is assumed.</li>
<li><strong>w1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">es.Data</span></code> or <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> of shape (DIM,)) – weighting factor for the gradient term in the regularization
see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a>.  If not set zero is assumed.</li>
<li><strong>w_gc</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Scalar</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – weighting factor for the cross gradient term in the
regularization, see <a class="reference internal" href="#esys.downunder.Regularization" title="esys.downunder.Regularization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></a>. If not set one is
assumed.</li>
<li><strong>k_at_depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – value for susceptibility at depth, see <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</li>
<li><strong>rho_at_depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – value for density at depth, see <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.StrongJointGravityMagneticInversion.siloWriterCallback">
<code class="descname">siloWriterCallback</code><span class="sig-paren">(</span><em>k</em>, <em>x</em>, <em>Jx</em>, <em>g_Jx</em>, <em>norm_dJ=None</em>, <em>norm_dx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.StrongJointGravityMagneticInversion.siloWriterCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>callback function that can be used to track the solution</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>k</strong> – iteration count</li>
<li><strong>x</strong> – current m approximation</li>
<li><strong>Jx</strong> – value of cost function</li>
<li><strong>g_Jx</strong> – gradient of f at x</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.Subsidence">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">Subsidence</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>d</em>, <em>lam</em>, <em>mu</em>, <em>coordinates=None</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.forwardmodels.base.html#esys.downunder.forwardmodels.base.ForwardModel" title="esys.downunder.forwardmodels.base.ForwardModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.forwardmodels.base.ForwardModel</span></code></a></p>
<p>Forward Model for subsidence inversion minimizing
integrate( (inner(w,u)-d)**2)
where u is the surface displacement due to a pressure change P</p>
<dl class="method">
<dt id="esys.downunder.Subsidence.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>w</em>, <em>d</em>, <em>lam</em>, <em>mu</em>, <em>coordinates=None</em>, <em>tol=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new subsidence on the given domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>w</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code> with <code class="docutils literal notranslate"><span class="pre">FunctionOnBoundary</span></code>) – data weighting factors and direction</li>
<li><strong>d</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> with <code class="docutils literal notranslate"><span class="pre">FunctionOnBoundary</span></code>) – displacement measured at surface</li>
<li><strong>lam</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code> with <code class="docutils literal notranslate"><span class="pre">Function</span></code>) – 1st Lame coefficient</li>
<li><strong>lam</strong> – 2st Lame coefficient/Shear modulus</li>
<li><strong>coordinates</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a> or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – defines coordinate system to be used (not supported yet))</li>
<li><strong>tol</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – tolerance of underlying PDE</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Subsidence.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>P</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns precomputed values shared by <a class="reference internal" href="#esys.downunder.Subsidence.getDefect" title="esys.downunder.Subsidence.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a> and <a class="reference internal" href="#esys.downunder.Subsidence.getGradient" title="esys.downunder.Subsidence.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>P</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – pressure</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">displacement u</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">Vector</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Subsidence.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.Subsidence.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>P</em>, <em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence.getDefect" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the value of the defect.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>P</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – pressure</li>
<li><strong>u</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – corresponding displacement</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">float</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Subsidence.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>P</em>, <em>u</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the gradient of the defect with respect to susceptibility.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>P</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – pressure</li>
<li><strong>u</strong> (<code class="docutils literal notranslate"><span class="pre">Vector</span></code>) – corresponding displacement</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.Subsidence.rescaleWeights">
<code class="descname">rescaleWeights</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>P_scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.Subsidence.rescaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>rescales the weights</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scale</strong> (positive <code class="docutils literal notranslate"><span class="pre">float</span></code>) – scale of data weighting factors</li>
<li><strong>P_scale</strong> (<code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – scale of pressure increment</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SusceptibilityMapping">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SusceptibilityMapping</code><span class="sig-paren">(</span><em>domain</em>, <em>z0=None</em>, <em>k0=None</em>, <em>dk=None</em>, <em>beta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SusceptibilityMapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.mappings.LinearMapping</span></code></p>
<p>Susceptibility mapping with depth weighting</p>
<p><em>k =  k0 + dk  * ( (x_2 - z0)/l_z)^(beta/2) ) * m</em></p>
<dl class="method">
<dt id="esys.downunder.SusceptibilityMapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>z0=None</em>, <em>k0=None</em>, <em>dk=None</em>, <em>beta=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SusceptibilityMapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>set up mapping</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the mapping</li>
<li><strong>z0</strong> (<em>scalar</em>) – depth weighting offset. If not present no depth scaling is applied.</li>
<li><strong>k0</strong> (<em>scalar</em>) – reference density, defaults to 0</li>
<li><strong>dk</strong> (<em>scalar</em>) – susceptibility scale, defaults to 1</li>
<li><strong>beta</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – depth weighting exponent, defaults to 2</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SusceptibilityMapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SusceptibilityMapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SusceptibilityMapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SusceptibilityMapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for s</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SusceptibilityMapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SusceptibilityMapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SusceptibilityMapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SusceptibilityMapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SyntheticData">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SyntheticData</code><span class="sig-paren">(</span><em>data_type</em>, <em>n_length=1</em>, <em>n_depth=1</em>, <em>depth_offset=0.0</em>, <em>depth=None</em>, <em>amplitude=None</em>, <em>DIM=2</em>, <em>number_of_elements=10</em>, <em>length=1000.0</em>, <em>B_b=None</em>, <em>data_offset=0</em>, <em>full_knowledge=False</em>, <em>s=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.SyntheticDataBase</span></code></p>
<p>Defines synthetic gravity/magnetic data based on harmonic property anomaly</p>
<blockquote>
<div>rho = amplitude * sin(n_depth * pi /depth * (z+depth_offset)) * sin(n_length * pi /length * (x - shift) )</div></blockquote>
<p>for all x and z&lt;=0. For z&gt;0 rho = 0.</p>
<dl class="method">
<dt id="esys.downunder.SyntheticData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data_type</em>, <em>n_length=1</em>, <em>n_depth=1</em>, <em>depth_offset=0.0</em>, <em>depth=None</em>, <em>amplitude=None</em>, <em>DIM=2</em>, <em>number_of_elements=10</em>, <em>length=1000.0</em>, <em>B_b=None</em>, <em>data_offset=0</em>, <em>full_knowledge=False</em>, <em>s=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_type</strong> (<a class="reference internal" href="#esys.downunder.DataSource.GRAVITY" title="esys.downunder.DataSource.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.GRAVITY</span></code></a>, <a class="reference internal" href="#esys.downunder.DataSource.MAGNETIC" title="esys.downunder.DataSource.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.MAGNETIC</span></code></a>) – data type indicator</li>
<li><strong>n_length</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of oscillations in the anomaly data within the
observation region</li>
<li><strong>n_depth</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of oscillations in the anomaly data below surface</li>
<li><strong>depth_offset</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – vertical offset of the data</li>
<li><strong>depth</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – vertical extent in the anomaly data. If not present the
depth of the domain is used.</li>
<li><strong>amplitude</strong> – data amplitude. Default value is 200 U.kg/U.m**3 for
gravity and 0.1 for magnetic data.</li>
<li><strong>DIM</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code> (2 or 3)) – spatial dimensionality</li>
<li><strong>number_of_elements</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – lateral number of elements in the region
where data are collected</li>
<li><strong>length</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – lateral extent of the region where data are collected</li>
<li><strong>B_b</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – background magnetic flux density [B_r, B_latiude, B_longitude].
Only used for magnetic data.</li>
<li><strong>data_offset</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – offset of the data collection region from the surface</li>
<li><strong>full_knowledge</strong> (<code class="docutils literal notranslate"><span class="pre">Bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> data are collected from the entire
subsurface region. This is mainly for testing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticData.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.SyntheticData.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticData.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.SyntheticData.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticData.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.SyntheticData.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticData.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.SyntheticData.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the lateral data extend of the data set</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the data type</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getReferenceProperty">
<code class="descname">getReferenceProperty</code><span class="sig-paren">(</span><em>domain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getReferenceProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reference <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object that was used to generate
the gravity/susceptibility anomaly data.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.SyntheticData.setSubsamplingFactor" title="esys.downunder.SyntheticData.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>number_of_elements</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the survey data placed on a given domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> (<code class="docutils literal notranslate"><span class="pre">Domain</span></code>) – domain on which the data are to be placed</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – origin of the domain</li>
<li><strong>number_of_elements</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of elements (or cells) in each
spatial direction used to span the domain</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – cell size in each spatial direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">observed gravity field or magnetic flux density for each cell
in the domain and for each cell an indicator 1/0 if the data
are valid or not.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">pair of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dummy UTM zone since this class does not use real coordinate
values.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticData.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticData.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SyntheticDataBase">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SyntheticDataBase</code><span class="sig-paren">(</span><em>data_type</em>, <em>DIM=2</em>, <em>number_of_elements=10</em>, <em>length=1000.0</em>, <em>B_b=None</em>, <em>data_offset=0</em>, <em>full_knowledge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.DataSource</span></code></p>
<p>Base class to define reference data based on a given property distribution
(density or susceptibility). Data are collected from a square region of
vertical extent <code class="docutils literal notranslate"><span class="pre">length</span></code> on a grid with <code class="docutils literal notranslate"><span class="pre">number_of_elements</span></code> cells in
each direction.</p>
<p>The synthetic data are constructed by solving the appropriate forward
problem. Data can be sampled with an offset from the surface at z=0 or
using the entire subsurface region.</p>
<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data_type</em>, <em>DIM=2</em>, <em>number_of_elements=10</em>, <em>length=1000.0</em>, <em>B_b=None</em>, <em>data_offset=0</em>, <em>full_knowledge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_type</strong> (<a class="reference internal" href="#esys.downunder.DataSource.GRAVITY" title="esys.downunder.DataSource.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.GRAVITY</span></code></a>, <a class="reference internal" href="#esys.downunder.DataSource.MAGNETIC" title="esys.downunder.DataSource.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.MAGNETIC</span></code></a>) – data type indicator</li>
<li><strong>DIM</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code> (2 or 3)) – number of spatial dimensions</li>
<li><strong>number_of_elements</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – lateral number of elements in the region
where data are collected</li>
<li><strong>length</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – lateral extent of the region where data are collected</li>
<li><strong>B_b</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – background magnetic flux density [B_r, B_latiude, B_longitude]. Only used for magnetic data.</li>
<li><strong>data_offset</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – offset of the data collection region from the surface</li>
<li><strong>full_knowledge</strong> (<code class="docutils literal notranslate"><span class="pre">Bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> data are collected from the entire
subsurface region. This is mainly for testing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticDataBase.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.SyntheticDataBase.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticDataBase.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.SyntheticDataBase.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticDataBase.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.SyntheticDataBase.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticDataBase.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.SyntheticDataBase.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the lateral data extend of the data set</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the data type</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getReferenceProperty">
<code class="descname">getReferenceProperty</code><span class="sig-paren">(</span><em>domain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getReferenceProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reference <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object that was used to generate
the gravity/susceptibility anomaly data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the density or susceptibility anomaly used to create the
survey data</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">it can be assumed that in the first call the <code class="docutils literal notranslate"><span class="pre">domain</span></code>
argument is present so the actual anomaly data can be created.
In subsequent calls this may not be true.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">method needs to be overwritten</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.SyntheticDataBase.setSubsamplingFactor" title="esys.downunder.SyntheticDataBase.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>number_of_elements</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the survey data placed on a given domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> (<code class="docutils literal notranslate"><span class="pre">Domain</span></code>) – domain on which the data are to be placed</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – origin of the domain</li>
<li><strong>number_of_elements</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of elements (or cells) in each
spatial direction used to span the domain</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – cell size in each spatial direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">observed gravity field or magnetic flux density for each cell
in the domain and for each cell an indicator 1/0 if the data
are valid or not.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">pair of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dummy UTM zone since this class does not use real coordinate
values.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticDataBase.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticDataBase.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.SyntheticFeatureData">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">SyntheticFeatureData</code><span class="sig-paren">(</span><em>data_type</em>, <em>features</em>, <em>DIM=2</em>, <em>number_of_elements=10</em>, <em>length=1000.0</em>, <em>B_b=None</em>, <em>data_offset=0</em>, <em>full_knowledge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.datasources.SyntheticDataBase</span></code></p>
<p>Uses a list of <code class="xref py py-obj docutils literal notranslate"><span class="pre">SourceFeature</span></code> objects to define synthetic anomaly data.</p>
<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>data_type</em>, <em>features</em>, <em>DIM=2</em>, <em>number_of_elements=10</em>, <em>length=1000.0</em>, <em>B_b=None</em>, <em>data_offset=0</em>, <em>full_knowledge=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data_type</strong> (<a class="reference internal" href="#esys.downunder.DataSource.GRAVITY" title="esys.downunder.DataSource.GRAVITY"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.GRAVITY</span></code></a>, <a class="reference internal" href="#esys.downunder.DataSource.MAGNETIC" title="esys.downunder.DataSource.MAGNETIC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataSource.MAGNETIC</span></code></a>) – data type indicator</li>
<li><strong>features</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">SourceFeature</span></code>) – list of features. It is recommended that the features
are located entirely below the surface.</li>
<li><strong>DIM</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code> (2 or 3)) – spatial dimensionality</li>
<li><strong>number_of_elements</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – lateral number of elements in the region
where data are collected</li>
<li><strong>length</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – lateral extent of the region where data are collected</li>
<li><strong>B_b</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code>) – background magnetic flux density [B_r, B_latiude, B_longitude]. Only used for magnetic data.</li>
<li><strong>data_offset</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – offset of the data collection region from the surface</li>
<li><strong>full_knowledge</strong> (<code class="docutils literal notranslate"><span class="pre">Bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> data are collected from the entire subsurface region. This is mainly for testing.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticFeatureData.ACOUSTIC">
<code class="descname">ACOUSTIC</code><em class="property"> = 2</em><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.ACOUSTIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticFeatureData.GRAVITY">
<code class="descname">GRAVITY</code><em class="property"> = 0</em><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.GRAVITY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticFeatureData.MAGNETIC">
<code class="descname">MAGNETIC</code><em class="property"> = 1</em><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.MAGNETIC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="esys.downunder.SyntheticFeatureData.MT">
<code class="descname">MT</code><em class="property"> = 3</em><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.MT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getDataExtents">
<code class="descname">getDataExtents</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getDataExtents" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the lateral data extend of the data set</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getDataType">
<code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getDataType" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the data type</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getHeightScale">
<code class="descname">getHeightScale</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getHeightScale" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the height scale factor to convert from meters to the
appropriate units of the reference system used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getReferenceProperty">
<code class="descname">getReferenceProperty</code><span class="sig-paren">(</span><em>domain=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getReferenceProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reference <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> object that was used to generate
the gravity/susceptibility anomaly data.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getReferenceSystem">
<code class="descname">getReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the reference coordinate system</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getSubsamplingFactor">
<code class="descname">getSubsamplingFactor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the subsampling factor that was set via <a class="reference internal" href="#esys.downunder.SyntheticFeatureData.setSubsamplingFactor" title="esys.downunder.SyntheticFeatureData.setSubsamplingFactor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setSubsamplingFactor</span></code></a>
(see there).</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getSurveyData">
<code class="descname">getSurveyData</code><span class="sig-paren">(</span><em>domain</em>, <em>origin</em>, <em>number_of_elements</em>, <em>spacing</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getSurveyData" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the survey data placed on a given domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> (<code class="docutils literal notranslate"><span class="pre">Domain</span></code>) – domain on which the data are to be placed</li>
<li><strong>origin</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – origin of the domain</li>
<li><strong>number_of_elements</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">int</span></code>) – number of elements (or cells) in each
spatial direction used to span the domain</li>
<li><strong>spacing</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – cell size in each spatial direction</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">observed gravity field or magnetic flux density for each cell
in the domain and for each cell an indicator 1/0 if the data
are valid or not.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">pair of <code class="docutils literal notranslate"><span class="pre">Scalar</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getTags">
<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getTags" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the list of tags</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.getUtmZone">
<code class="descname">getUtmZone</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.getUtmZone" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dummy UTM zone since this class does not use real coordinate
values.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.hasTag">
<code class="descname">hasTag</code><span class="sig-paren">(</span><em>tag</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.hasTag" title="Permalink to this definition">¶</a></dt>
<dd><p>returns true if the data set has tag <code class="docutils literal notranslate"><span class="pre">tag</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.SyntheticFeatureData.setSubsamplingFactor">
<code class="descname">setSubsamplingFactor</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SyntheticFeatureData.setSubsamplingFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the data subsampling factor (default=1).</p>
<p>The factor is applied in all dimensions. For example a 2D dataset
with 300 x 150 data points will be reduced to 150 x 75 when a
subsampling factor of 2 is used.
This becomes important when adding data of varying resolution to
a <a class="reference internal" href="#esys.downunder.DomainBuilder" title="esys.downunder.DomainBuilder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DomainBuilder</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.TTIWave">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">TTIWave</code><span class="sig-paren">(</span><em>domain, v_p, v_s, wavelet, source_tag, source_vector=[0.0, 1.0], eps=0.0, delta=0.0, theta=0.0, rho=1.0, dt=None, u0=None, v0=None, absorption_zone=300.0, absorption_cut=0.01, lumping=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.TTIWave" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.seismic.html#esys.downunder.seismic.WaveBase" title="esys.downunder.seismic.WaveBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.seismic.WaveBase</span></code></a></p>
<p>Solving the 2D TTI wave equation with</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma_xx=</span> <span class="pre">c11*e_xx</span> <span class="pre">+</span> <span class="pre">c13*e_zz</span> <span class="pre">+</span> <span class="pre">c15*e_xz</span></code>
<code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma_zz=</span> <span class="pre">c13*e_xx</span> <span class="pre">+</span> <span class="pre">c33*e_zz</span> <span class="pre">+</span> <span class="pre">c35*e_xz</span></code>
<code class="xref py py-obj docutils literal notranslate"><span class="pre">sigma_xz=</span> <span class="pre">c15*e_xx</span> <span class="pre">+</span> <span class="pre">c35*e_zz</span> <span class="pre">+</span> <span class="pre">c55*e_xz</span></code></p>
<p>the coefficients <code class="xref py py-obj docutils literal notranslate"><span class="pre">c11</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">c13</span></code>, etc are calculated from the tompsen parameters <code class="xref py py-obj docutils literal notranslate"><span class="pre">eps</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">delta</span></code> and the tilt <code class="xref py py-obj docutils literal notranslate"><span class="pre">theta</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">currently only the 2D case is supported.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.TTIWave.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain, v_p, v_s, wavelet, source_tag, source_vector=[0.0, 1.0], eps=0.0, delta=0.0, theta=0.0, rho=1.0, dt=None, u0=None, v0=None, absorption_zone=300.0, absorption_cut=0.01, lumping=True</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.TTIWave.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the TTI wave solver</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the problem</li>
<li><strong>v_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical p-velocity field</li>
<li><strong>v_s</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical s-velocity field</li>
<li><strong>wavelet</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Wavelet</span></code>) – wavelet to describe the time evolution of source term</li>
<li><strong>source_tag</strong> (<em>'str'</em><em> or </em><em>'int'</em>) – tag of the source location</li>
<li><strong>source_vector</strong> – source orientation vector</li>
<li><strong>eps</strong> – first Thompsen parameter</li>
<li><strong>delta</strong> – second Thompsen parameter</li>
<li><strong>theta</strong> – tilting (in Rad)</li>
<li><strong>rho</strong> – density</li>
<li><strong>dt</strong> – time step size. If not present a suitable time step size is calculated.</li>
<li><strong>u0</strong> – initial solution. If not present zero is used.</li>
<li><strong>v0</strong> – initial solution change rate. If not present zero is used.</li>
<li><strong>absorption_zone</strong> – thickness of absorption zone</li>
<li><strong>absorption_cut</strong> – boundary value of absorption decay factor</li>
<li><strong>lumping</strong> – if True mass matrix lumping is being used. This is accelerates the computing but introduces some diffusion.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.TTIWave.getTimeStepSize">
<code class="descname">getTimeStepSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.TTIWave.getTimeStepSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.TTIWave.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.TTIWave.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the solution for the next time marker t which needs to greater than the time marker from the
previous call.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.VTIWave">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">VTIWave</code><span class="sig-paren">(</span><em>domain, v_p, v_s, wavelet, source_tag, source_vector=[0.0, 0.0, 1.0], eps=0.0, gamma=0.0, delta=0.0, rho=1.0, dt=None, u0=None, v0=None, absorption_zone=None, absorption_cut=0.01, lumping=True, disable_fast_assemblers=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.VTIWave" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.seismic.html#esys.downunder.seismic.WaveBase" title="esys.downunder.seismic.WaveBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.seismic.WaveBase</span></code></a></p>
<p>Solving the VTI wave equation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">In case of a two dimensional domain the second spatial dimenion is depth.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.VTIWave.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain, v_p, v_s, wavelet, source_tag, source_vector=[0.0, 0.0, 1.0], eps=0.0, gamma=0.0, delta=0.0, rho=1.0, dt=None, u0=None, v0=None, absorption_zone=None, absorption_cut=0.01, lumping=True, disable_fast_assemblers=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.VTIWave.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize the VTI wave solver</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the problem</li>
<li><strong>v_p</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical p-velocity field</li>
<li><strong>v_s</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Scalar</span></code>) – vertical s-velocity field</li>
<li><strong>wavelet</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Wavelet</span></code>) – wavelet to describe the time evolution of source term</li>
<li><strong>source_tag</strong> (<em>'str'</em><em> or </em><em>'int'</em>) – tag of the source location</li>
<li><strong>source_vector</strong> – source orientation vector</li>
<li><strong>eps</strong> – first Thompsen parameter</li>
<li><strong>delta</strong> – second Thompsen parameter</li>
<li><strong>gamma</strong> – third Thompsen parameter</li>
<li><strong>rho</strong> – density</li>
<li><strong>dt</strong> – time step size. If not present a suitable time step size is calculated.</li>
<li><strong>u0</strong> – initial solution. If not present zero is used.</li>
<li><strong>v0</strong> – initial solution change rate. If not present zero is used.</li>
<li><strong>absorption_zone</strong> – thickness of absorption zone</li>
<li><strong>absorption_cut</strong> – boundary value of absorption decay factor</li>
<li><strong>lumping</strong> – if True mass matrix lumping is being used. This is accelerates the computing but introduces some diffusion.</li>
<li><strong>disable_fast_assemblers</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>) – if True, forces use of slower and more general PDE assemblers</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.VTIWave.getTimeStepSize">
<code class="descname">getTimeStepSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.VTIWave.getTimeStepSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.VTIWave.setQ">
<code class="descname">setQ</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.VTIWave.setQ" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the PDE q value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>q</strong> – the value to set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.VTIWave.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.VTIWave.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the solution for the next time marker t which needs to greater than the time marker from the
previous call.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.WaveBase">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">WaveBase</code><span class="sig-paren">(</span><em>dt</em>, <em>u0</em>, <em>v0</em>, <em>t0=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WaveBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Base for wave propagation using the Verlet scheme.</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">u_tt</span> <span class="pre">=</span> <span class="pre">A(t,u),</span> <span class="pre">u(t=t0)=u0,</span> <span class="pre">u_t(t=t0)=v0</span></code></div></blockquote>
<p>with a given acceleration force as function of time.</p>
<p>a_n=A(t_{n-1})
v_n=v_{n-1} +  dt *  a_n
u_n=u_{n-1} +  dt *  v_n</p>
<dl class="method">
<dt id="esys.downunder.WaveBase.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dt</em>, <em>u0</em>, <em>v0</em>, <em>t0=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WaveBase.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>set up the wave base</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dt</strong> – time step size (need to be sufficiently small)</li>
<li><strong>u0</strong> – initial value</li>
<li><strong>v0</strong> – initial velocity</li>
<li><strong>t0</strong> – initial time</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.WaveBase.getTimeStepSize">
<code class="descname">getTimeStepSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WaveBase.getTimeStepSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.WaveBase.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WaveBase.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the solution for the next time marker t which needs to greater than the time marker from the
previous call.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.WennerSurvey">
<em class="property">class </em><code class="descclassname">esys.downunder.</code><code class="descname">WennerSurvey</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#esys.downunder.dcresistivityforwardmodeling.DcResistivityForward" title="esys.downunder.dcresistivityforwardmodeling.DcResistivityForward"><code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.dcresistivityforwardmodeling.DcResistivityForward</span></code></a></p>
<p>WennerSurvey forward calculation</p>
<dl class="method">
<dt id="esys.downunder.WennerSurvey.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>domain</em>, <em>primaryConductivity</em>, <em>secondaryConductivity</em>, <em>current</em>, <em>a</em>, <em>midPoint</em>, <em>directionVector</em>, <em>numElectrodes</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code>) – domain of the model</li>
<li><strong>primaryConductivity</strong> (<code class="docutils literal notranslate"><span class="pre">data</span></code>) – preset primary conductivity data object</li>
<li><strong>secondaryConductivity</strong> (<code class="docutils literal notranslate"><span class="pre">data</span></code>) – preset secondary conductivity data object</li>
<li><strong>current</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code>) – amount of current to be injected at the current electrode</li>
<li><strong>a</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code>) – the spacing between current and potential electrodes</li>
<li><strong>midPoint</strong> – midPoint of the survey, as a list containing x,y coords</li>
<li><strong>directionVector</strong> – two element list specifying the direction the
survey should extend from the midpoint</li>
<li><strong>numElectrodes</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – the number of electrodes to be used in the survey
must be a multiple of 2 for polepole survey</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.checkBounds">
<code class="descname">checkBounds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.checkBounds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.getApparentResistivity">
<code class="descname">getApparentResistivity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.getApparentResistivity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.getApparentResistivityPrimary">
<code class="descname">getApparentResistivityPrimary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.getApparentResistivityPrimary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.getApparentResistivitySecondary">
<code class="descname">getApparentResistivitySecondary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.getApparentResistivitySecondary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.getApparentResistivityTotal">
<code class="descname">getApparentResistivityTotal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.getApparentResistivityTotal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.getElectrodes">
<code class="descname">getElectrodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.getElectrodes" title="Permalink to this definition">¶</a></dt>
<dd><p>retuns the list of electrodes with locations</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.WennerSurvey.getPotential">
<code class="descname">getPotential</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WennerSurvey.getPotential" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list containing 3 lists one for each the primary, secondary
and total potential.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.xrange">
<code class="descclassname">esys.downunder.</code><code class="descname">xrange</code><a class="headerlink" href="#esys.downunder.xrange" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.range</span></code></p>
</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="esys.downunder.CartesianCoordinateTransformation">
<code class="descclassname">esys.downunder.</code><code class="descname">CartesianCoordinateTransformation</code><span class="sig-paren">(</span><em>domain</em>, <em>reference=&lt;esys.downunder.coordinates.CartesianReferenceSystem object&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.CartesianCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="esys.downunder.GRS80ReferenceSystem">
<code class="descclassname">esys.downunder.</code><code class="descname">GRS80ReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.GRS80ReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <a class="reference internal" href="#esys.downunder.GeodeticReferenceSystem" title="esys.downunder.GeodeticReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeodeticReferenceSystem</span></code></a> for the GRS80 Ellipsoid eg. used by Geocentric Datum of Australia GDA94</p>
</dd></dl>

<dl class="function">
<dt id="esys.downunder.SphericalReferenceSystem">
<code class="descclassname">esys.downunder.</code><code class="descname">SphericalReferenceSystem</code><span class="sig-paren">(</span><em>R=6378137.0</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.SphericalReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <a class="reference internal" href="#esys.downunder.GeodeticReferenceSystem" title="esys.downunder.GeodeticReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeodeticReferenceSystem</span></code></a> of a sphere
:param R: sphere radius
:type R: positive <code class="docutils literal notranslate"><span class="pre">double</span></code></p>
</dd></dl>

<dl class="function">
<dt id="esys.downunder.WGS84ReferenceSystem">
<code class="descclassname">esys.downunder.</code><code class="descname">WGS84ReferenceSystem</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.WGS84ReferenceSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <a class="reference internal" href="#esys.downunder.GeodeticReferenceSystem" title="esys.downunder.GeodeticReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeodeticReferenceSystem</span></code></a> for the WGS84 Ellipsoid</p>
</dd></dl>

<dl class="function">
<dt id="esys.downunder.createAbsorptionLayerFunction">
<code class="descclassname">esys.downunder.</code><code class="descname">createAbsorptionLayerFunction</code><span class="sig-paren">(</span><em>x</em>, <em>absorption_zone=300.0</em>, <em>absorption_cut=0.01</em>, <em>top_absorption=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.createAbsorptionLayerFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a distribution which is one in the interior of the domain of <code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code>
and is falling down to the value ‘absorption_cut’ over a margin of thickness ‘absorption_zone’
toward each boundary except the top of the domain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Data</span></code>) – location of points in the domain</li>
<li><strong>absorption_zone</strong> – thickness of the absorption zone</li>
<li><strong>absorption_cut</strong> – value of decay function on domain boundary</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">function on ‘x’ which is one in the iterior and decays to almost zero over a margin
toward the boundary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="esys.downunder.makeTransformation">
<code class="descclassname">esys.downunder.</code><code class="descname">makeTransformation</code><span class="sig-paren">(</span><em>domain</em>, <em>coordinates=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.makeTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a> for the given domain</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">esys.escript.AbstractDomain</span></code>) – domain in the domain of the coordinate transformation</li>
<li><strong>coordinates</strong> (<a class="reference internal" href="#esys.downunder.ReferenceSystem" title="esys.downunder.ReferenceSystem"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReferenceSystem</span></code></a> or <a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a>) – the reference system or spatial coordinate system.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the spatial coordinate system for the given domain of the specified 
reference system <code class="docutils literal notranslate"><span class="pre">coordinates</span></code>. If <code class="docutils literal notranslate"><span class="pre">coordinates</span></code> is already spatial coordinate system based on the 
riven domain <code class="docutils literal notranslate"><span class="pre">coordinates</span></code> is returned. Otherwise an appropriate spatial coordinate system 
is created.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#esys.downunder.SpatialCoordinateTransformation" title="esys.downunder.SpatialCoordinateTransformation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SpatialCoordinateTransformation</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="esys.downunder.saveSilo">
<code class="descclassname">esys.downunder.</code><code class="descname">saveSilo</code><span class="sig-paren">(</span><em>filename</em>, <em>domain=None</em>, <em>write_meshdata=False</em>, <em>time=0.0</em>, <em>cycle=0</em>, <em>**data</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.saveSilo" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects and their mesh to a file using the SILO file format.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">temp</span><span class="o">=</span><span class="n">Scalar</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="n">v</span><span class="o">=</span><span class="n">Vector</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="n">saveSilo</span><span class="p">(</span><span class="s2">&quot;solution.silo&quot;</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="n">temp</span><span class="p">,</span> <span class="n">velocity</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">temp</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> are written to “solution.silo” where <code class="docutils literal notranslate"><span class="pre">temp</span></code> is named
“temperature” and <code class="docutils literal notranslate"><span class="pre">v</span></code> is named “velocity”.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<code class="docutils literal notranslate"><span class="pre">str</span></code>) – name of the output file (‘.silo’ is added if required)</li>
<li><strong>domain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Domain</span></code>) – domain of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects. If not specified, the domain
of the given <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> objects is used.</li>
<li><strong>write_meshdata</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – whether to save mesh-related data such as element
identifiers, ownership etc. This is mainly useful
for debugging.</li>
<li><strong>time</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code>) – the timestamp to save within the file</li>
<li><strong>cycle</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – the cycle (or timestep) of the data</li>
<li><strong>&lt;name&gt;</strong> – writes the assigned value to the Silo file using &lt;name&gt; as
identifier</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body"><p class="first last">All data objects have to be defined on the same domain but they may
be defined on separate <code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code> s.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="others">
<h2>Others<a class="headerlink" href="#others" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>pi</li>
</ul>
</div>
<div class="section" id="packages">
<h2>Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html">esys.downunder.dcresistivityforwardmodeling Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="esys.downunder.domainbuilder.html">esys.downunder.domainbuilder Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.domainbuilder.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.domainbuilder.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.domainbuilder.html#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.domainbuilder.html#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="esys.downunder.seismic.html">esys.downunder.seismic Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.seismic.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.seismic.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.seismic.html#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.seismic.html#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="esys.downunder.splitinversioncostfunctions.html">esys.downunder.splitinversioncostfunctions Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitinversioncostfunctions.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitinversioncostfunctions.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitinversioncostfunctions.html#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitinversioncostfunctions.html#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="esys.downunder.splitminimizers.html">esys.downunder.splitminimizers Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitminimizers.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitminimizers.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitminimizers.html#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitminimizers.html#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="esys.downunder.splitregularizations.html">esys.downunder.splitregularizations Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitregularizations.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitregularizations.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitregularizations.html#others">Others</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.splitregularizations.html#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">esys.downunder Package</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#others">Others</a></li>
<li><a class="reference internal" href="#packages">Packages</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Documentation for esys.escript</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="esys.downunder.dcresistivityforwardmodeling.html"
                        title="next chapter">esys.downunder.dcresistivityforwardmodeling Package</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="esys.downunder.dcresistivityforwardmodeling.html" title="esys.downunder.dcresistivityforwardmodeling Package"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Documentation for esys.escript"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">esys.escript 5.5 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2014, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>