
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Copyright (c) 2003-2010 by University of Queensland
% Earth Systems Science Computational Center (ESSCC)
% http://www.uq.edu.au/esscc
%
% Primary Business: Queensland, Australia
% Licensed under the Open Software License version 3.0
% http://www.opensource.org/licenses/osl-3.0.php
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Seismic Wave Propagation in Two Dimensions}
\editor{This chapter aims to expand the readers understanding of escript by
modelling the wave equations.
Challenges will include a second order differential (multiple initial
conditions). A new PDE to fit to the general form. Movement to a 3D problem
(maybe)??? }

\sslist{example08a.py}

We will now expand upon the previous chapter by introducing a vector form of
the wave equation. This means that the waves will have both a scalar magnitude,
but also a direction. This type of scenario is apparent in wave forms that
exhibit compressional and transverse particle motion. A common type of wave
that obeys this principle are seismic waves.

Wave propagation in the earth can be described by the elastic wave equation:
\begin{equation} \label{eqn:wav} \index{wave equation}
\rho \frac{\partial^{2}u\hackscore{i}}{\partial t^2} - \frac{\partial
\sigma\hackscore{ij}}{\partial x\hackscore{j}} = 0
\end{equation}
where $\sigma$ is the stress given by:
\begin{equation} \label{eqn:sigw}
 \sigma \hackscore{ij} = \lambda u\hackscore{k,k} \delta\hackscore{ij} + \mu (
u\hackscore{i,j} + u\hackscore{j,i})
\end{equation}
where $\lambda$ and $\mu$ are the Lame Coefficients. Specifically $\mu$ is the
bulk modulus. The \refEq{eqn:wav} can be written with the Einstein summation
convention as:
\begin{equation}
\rho u\hackscore{i,tt} = \sigma\hackscore{ij,j}
\end{equation}

In a similar process to the previous chapter, we will use the acceleration
solution to solve this PDE. By substituting $a$ directly for
$\frac{\partial^{2}u\hackscore{i}}{\partial t^2}$ we can derive the
displacement solution. Using $a$ \refEq{eqn:wav} becomes;
\begin{equation} \label{eqn:wava} 
\rho a\hackscore{i} - \frac{\partial
\sigma\hackscore{ij}}{\partial x\hackscore{j}} = 0
\end{equation}

\section{Vector source on the boundary}
For this particular example, we will introduce the source by applying a
displacment to the boundary during the initial time steps. The source will again
be
a radially propagating wave but due to the vector nature of the PDE used, a
direction will need to be applied to the source.

The first step is to choose an amplitude and create the source as in the
previous chapter. 
\begin{python}
 src_length = 20; print "src_length = ",src_length
# set initial values for first two time steps with source terms
y=U0*(cos(length(x-xc)*3.1415/src_length)+1)*whereNegative(length(x-xc)-src_leng
th)
\end{python}
where \verb xc  is the source point on the boundary of the model. The source
direction is then defined as an $(x,y)$ array and multiplied by the source
function. The directional array must have a magnitude of $1$ otherwise the
amplitude of the source will become modified. For this example, the source is
directed in the $-y$ direction.
\begin{python}
src_dir=numpy.array([0.,-1.]) # defines direction of point source as down
y=y*src_dir
\end{python}
The function can then be applied as a boundary condition by setting it equal to
$y$ in the general form.
\begin{python}
mypde.setValue(y=y) #set the source as a function on the boundary
\end{python}
Because we are no longer using the source to define our initial condition to
the model, we must set the model state to zero for the first two time steps.
\begin{python}
# initial value of displacement at point source is constant (U0=0.01)
# for first two time steps
u=[0.0,0.0]*whereNegative(x)
u_m1=u
\end{python}

If the source will introduce energy to the system over a period longer than one
or two time steps (ie the initial conditions), $y$ can be updated during the
iteration stage. 

\section{Time variant source}

\sslist{example08b.py}

Until this point, all of the wave propagation examples in this cookbook have
used impulsive sources which are smooth in space but not time. It is however,
advantageous to have a time smoothed source as it can reduce the temporal
frequency range and thus mitigate aliasing in the solution. 


It is quite 
simple to implement a source which is smooth in time. In addition to the
original source function the only extra requirement is a time function. For
this example it will be a decaying sinusoidal curve defined by;
\begin{python}
U0=0.1 # amplitude of point source
ls=100   # length of the source
source=np.zeros(ls,'float') # source array
g=np.log(0.01)/ls
for t in range(0,ls):
    source[t]=np.exp(g*t)*U0*np.sin(2.*np.pi*t/(0.75*ls))
\end{python}

We then build the source and the first two time steps via;
\begin{python}
# set initial values for first two time steps with source terms
y=source[0]
*(cos(length(x-xc)*3.1415/src_length)+1)*whereNegative(length(x-xc)-src_length)
src_dir=numpy.array([0.,-1.]) # defines direction of point source as down
y=y*src_dir
mypde.setValue(y=y) #set the source as a function on the boundary
# initial value of displacement at point source is constant (U0=0.01)
# for first two time steps
u=[0.0,0.0]*whereNegative(x)
u_m1=u
\end{python}

Finally, for the length of the source, we are required to update each new
solution in the itterative section of the solver. This is done via;
\begin{python}
# increment loop values
t=t+h; n=n+1
if (n < ls):
	y=source[n]**(cos(length(x-xc)*3.1415/src_length)+1)*\
                   whereNegative(length(x-xc)-src_length)
        y=y*src_dir; mypde.setValue(y=y) #set the source as a function on the
boundary
\end{python}

\section{Absorbing Boundary Conditions}
To mitigate the effect of the boundary on the model, absorbing boundary
conditions can be introduced. These conditions effectively dampen the wave
energy as they approach the bounday and thus prevent that energy from being
reflected. This type of approach is used typically when a model only represents
a small portion of the entire model, which in reality may have infinite bounds.
It is inpractical to calculate the solution for an infinite model and thus ABCs
allow us the create an approximate solution with small to zero boundary effects
on a model with a solvable size. 

To dampen the waves, the method of Cerjan(1985)
\footnote{\textit{A nonreflecting boundary condition for discrete acoustic and
elastic wave equations}, 1985, Cerjan C, Geophysics 50, doi:10.1190/1.1441945}
where the solution and the stress are multiplied by a damping function defined
on $n$ nodes of the domain adjacent to the boundary, given by;
\begin{equation}
 y=
\end{equation}
This is applied to the bounding 20-50 pts of the model using the location
specifiers of \esc;
\begin{python}
# Define where the boundary decay will be applied.
bn=30.
bleft=xstep*bn; bright=mx-(xstep*bn); bbot=my-(ystep*bn)
# btop=ystep*bn # don't apply to force boundary!!!

# locate these points in the domain
left=x[0]-bleft; right=x[0]-bright; bottom=x[1]-bbot

tgamma=0.98   # decay value for exponential function
def calc_gamma(G,npts):
    func=np.sqrt(abs(-1.*np.log(G)/(npts**2.)))
    return func

gleft  = calc_gamma(tgamma,bleft)
gright = calc_gamma(tgamma,bleft)
gbottom= calc_gamma(tgamma,ystep*bn)

print 'gamma', gleft,gright,gbottom

# calculate decay functions
def abc_bfunc(gamma,loc,x,G):
    func=exp(-1.*(gamma*abs(loc-x))**2.)
    return func

fleft=abc_bfunc(gleft,bleft,x[0],tgamma)
fright=abc_bfunc(gright,bright,x[0],tgamma)
fbottom=abc_bfunc(gbottom,bbot,x[1],tgamma)
# apply these functions only where relevant
abcleft=fleft*whereNegative(left)
abcright=fright*wherePositive(right)
abcbottom=fbottom*wherePositive(bottom)
# make sure the inside of the abc is value 1
abcleft=abcleft+whereZero(abcleft)
abcright=abcright+whereZero(abcright)
abcbottom=abcbottom+whereZero(abcbottom)
# multiply the conditions together to get a smooth result
abc=abcleft*abcright*abcbottom
\end{python}
Note that the boundary conditions are not applied to the surface, as this is
effectively a free surface where normal reflections would be experienced. The
resulting boundary damping function can be viewed in \ref{fig:abconds}

%\begin{figure}{ht}
 %\centering
 %\includegraphics[width=5in]{figures/abconds.png}
%\end{figure}


