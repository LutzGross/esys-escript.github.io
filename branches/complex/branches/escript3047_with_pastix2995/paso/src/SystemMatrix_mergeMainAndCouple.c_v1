
/*******************************************************
*
* Copyright (c) 2003-2010 by University of Queensland
* Earth Systems Science Computational Center (ESSCC)
* http://www.uq.edu.au/esscc
*
* Primary Business: Queensland, Australia
* Licensed under the Open Software License version 3.0
* http://www.opensource.org/licenses/osl-3.0.php
*
*******************************************************/


/**************************************************************/

/* Paso: SystemMatrix                                       */

/*  Merge the MainBlock and CoupleBlock in the matrix         */


/**************************************************************/

/* Copyrights by ACcESS Australia 2003 */
/* Author: Lin Gao, l.gao@uq.edu.au */

/**************************************************************/

#include "Paso.h"
#include "SystemMatrix.h"

void Paso_SystemMatrix_mergeMainAndCouple(Paso_SystemMatrix* A, index_t** p_ptr, index_t** p_idx, double** p_val){
  if (A->type & MATRIX_FORMAT_CSC) {
      if (A->type & (MATRIX_FORMAT_OFFSET1 + MATRIX_FORMAT_BLK1)) {
          Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1(A, p_ptr, p_idx, p_val);
      } else {
          Paso_setError(SYSTEM_ERROR,"Paso_SystemMatrix_mergeMainAndCouple: CSC with index 0 or block size larger than 1 is not supported. ");
      }
  } else if (A->type & MATRIX_FORMAT_TRILINOS_CRS) {
      Paso_setError(SYSTEM_ERROR,"Paso_SystemMatrix_mergeMainAndCouple: TRILINOS is not supported. ");
  } else {
      Paso_setError(SYSTEM_ERROR,"Paso_SystemMatrix_mergeMainAndCouple: CRS is not supported. ");
  }
  return;
}

void Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1(Paso_SystemMatrix* A, index_t** p_ptr, index_t** p_idx, double** p_val) {

  index_t i, j, k, i_ub, j_ub, k_ub, col, num_vals, main_num_vals;
  index_t couple_num_vals, idx, rank, tmp_idx, len;
  index_t main_offset, couple_offset_l, couple_offset_r;
  index_t main_num_cols=A->mainBlock->pattern->numOutput;
  index_t couple_num_cols=A->col_coupleBlock->pattern->numOutput;
  index_t *main_ptr=A->mainBlock->pattern->ptr;
  index_t *main_idx=A->mainBlock->pattern->index;
  double  *main_val=A->mainBlock->val;
  index_t *couple_ptr=A->col_coupleBlock->pattern->ptr;
  index_t *couple_idx=A->col_coupleBlock->pattern->index;
  double  *couple_val=A->col_coupleBlock->val;
  Paso_SharedComponents*  coupler=A->col_coupler->connector->recv;

  if (A->mainBlock->col_block_size!=1 || 
      A->mainBlock->row_block_size!=1 ||
      A->col_coupleBlock->col_block_size!=1 ||
      A->col_coupleBlock->row_block_size!=1) {
      Paso_setError(TYPE_ERROR,"Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1: requires format with block size 1.");
      return;
  }
  
  if (main_num_cols != couple_num_cols) {
      Paso_setError(TYPE_ERROR,"Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1: number of collums do not match.");
      return;
  }

  /* allocate arrays "ptr", "index" and "val" */
  main_num_vals = main_ptr[main_num_cols]-1;
  couple_num_vals = couple_ptr[couple_num_cols]-1;
  num_vals = main_num_vals + couple_num_vals;
  *p_ptr = MEMALLOC(main_num_cols+1, index_t);
  *p_idx = MEMALLOC(num_vals, index_t);
  *p_val = MEMALLOC(num_vals, double);

  /* initialize before merge */
  (*p_ptr)[0] = 1;
  rank = A->mpi_info->rank;
  main_offset = A->col_distribution->first_component[rank];
  k_ub=coupler->numNeighbors;
  len = 0;
  for (k=0; k<=k_ub; k++){
      if (coupler->neighbor[k] < rank) 
          len += (coupler->offsetInShared[k+1] - coupler->offsetInShared[k]);
  }
  couple_offset_l = main_offset - len;
  couple_offset_r = A->col_distribution->first_component[rank+1] - len;
  i=0;
  j=0;

  /* merge mainBlock and col_coupleBlock */
  for (col=1; col<=main_num_cols; col++) {
      i_ub = main_ptr[col]-1;
      j_ub = couple_ptr[col]-1;
      while (i < i_ub || j < j_ub) {
          if (j < j_ub) {
              /* switch from coupleBlock index to global row index of matrix */
              tmp_idx = coupler->shared[couple_idx[j]-1]+1-couple_num_cols;
              for (k=1; k<=k_ub; k++)
                   if (couple_idx[j]<=coupler->offsetInShared[k]) break; 
              if (coupler->neighbor[k-1] < rank)
                  idx = couple_offset_l + tmp_idx;
              else 
                  idx = couple_offset_r + tmp_idx;
          }
          if (j == j_ub || (i < i_ub && (main_idx[i] + main_offset) < idx)){
              (*p_idx)[i+j] = main_idx[i] + main_offset;
              (*p_val)[i+j] = main_val[i];
              i++;
          } else {
              (*p_idx)[i+j] = idx;
              (*p_val)[i+j] = couple_val[j];
              j++;
          }
      }
      (*p_ptr)[col] = i+j+1;
  }

  return;
}

void Paso_SystemMatrix_copyMain_CSC_OFFSET1(Paso_SystemMatrix* A, index_t** p_ptr, index_t** p_idx, double** p_val) {

  index_t i, i_ub, col, num_vals, idx;
  index_t main_num_cols=A->mainBlock->pattern->numOutput;
  index_t *main_ptr=A->mainBlock->pattern->ptr;
  index_t *main_idx=A->mainBlock->pattern->index;
  double  *main_val=A->mainBlock->val;

  if (A->mainBlock->col_block_size!=1 || A->mainBlock->row_block_size!=1) {
      Paso_setError(TYPE_ERROR,"Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1: requires format with block size 1.");
      return;
  }

  /* allocate arrays "ptr", "index" and "val" */
  num_vals = main_ptr[main_num_cols]-1;
  *p_ptr = MEMALLOC(main_num_cols+1, index_t);
  *p_idx = MEMALLOC(num_vals, index_t);
  *p_val = MEMALLOC(num_vals, double);

  /* copy from mainBlock */
  (*p_ptr)[0] = 1;
  i=0;
  for (col=1; col<=main_num_cols; col++) {
      i_ub = main_ptr[col]-1;
      while (i < i_ub) {
          (*p_idx)[i] = main_idx[i];
          (*p_val)[i] = main_val[i];
          i++;
      }
      (*p_ptr)[col] = i+1;
  }
  return;
}

