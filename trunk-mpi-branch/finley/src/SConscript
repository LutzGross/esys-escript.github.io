#          Copyright 2006 by ACcESS MNRF
#
#              http://www.access.edu.au
#       Primary Business: Queensland, Australia
#  Licensed under the Open Software License version 3.0
#     http://www.opensource.org/licenses/osl-3.0.php
#
import os
Import('*')

local_env=env.Copy()
py_wrapper_local_env=env.Copy()
# Remove the sharedlibrary prefix on all platform - we don't want 'lib' mucking with our python modules
del py_wrapper_local_env['SHLIBPREFIX']

lib_name = 'finley'
py_wrapper_name = lib_name+'cpp'
py_wrapper_source = 'CPPAdapter/'+py_wrapper_name+'.cpp' # FIXME: In need of a source tree refactor
py_wrapper_lib_name = py_wrapper_name

src_dir = local_env.Dir('.').srcnode().abspath
filenames = [ x for x in os.listdir(src_dir) if os.path.splitext(x)[1] in [".h", ".c", ".cpp"] ]

sources = [x for x in filenames if os.path.splitext(x)[1] in ['.cpp', '.c']]
headers = [x for x in filenames if os.path.splitext(x)[1] in ['.h']]


# finleycpp has additional source in the CPPAdapter sub-directory. Append these to the list
cppadapter_filenames = [ 'CPPAdapter/'+x for x in os.listdir(src_dir+'/CPPAdapter')  if os.path.splitext(x)[1] in [".h", ".c", ".cpp"] ]
sources += [ x for x in cppadapter_filenames if os.path.splitext(x)[1] in ['.cpp', '.c']]
cppadapter_headers = [x for x in cppadapter_filenames if os.path.splitext(x)[1] in ['.h']]

sources.remove(py_wrapper_source) # FIXME: should probably refactor the source tree so the python wrapper isn't colocated with c++ sources
local_env.Append(LIBS = [boost_lib, python_lib] + sys_libs + ['escript', 'esysUtils', 'paso'] + mpi_libs )
py_wrapper_local_env.Append(LIBS = [boost_lib, python_lib] + sys_libs + [ lib_name, 'escript', 'esysUtils', 'paso'] + mpi_libs )

local_env.Append(CCFLAGS=pedantic_flag)
if mkl_libs:
   local_env.Append(CPPDEFINES=['MKL',])
   local_env.Append(LIBS = mkl_libs)
if scsl_libs:
   local_env.Append(CPPDEFINES=['SCSL',])
   local_env.Append(LIBS = scsl_libs)
if umf_libs:
   local_env.Append(CPPDEFINES=['UMFPACK',])
   local_env.Append(LIBS = umf_libs)

if blas_libs:
   local_env.Append(LIBS = blas_libs)

if papi_instrument_solver:
   local_env.Append(CPPDEFINES=['PAPI',])
if papi_libs:
   local_env.Append(LIBS = papi_libs)
   local_env.Append(CPPDEFINES=['BLOCKPAPI',])

if trilinos_libs:
   local_env.Append(CPPDEFINES=['TRILINOS',])
   local_env.Append(LIBS = trilinos_libs)

local_env.Append(CPPDEFINES = 'FINLEY_EXPORTS')

lib = local_env.SharedLibrary(lib_name, sources)
py_wrapper_lib = py_wrapper_local_env.SharedLibrary( py_wrapper_lib_name, py_wrapper_source)

include_path = Dir(lib_name, incinstall)
cppadapter_include_path = Dir('CppAdapter', include_path)

local_env.Install(include_path, headers )
local_env.Install(cppadapter_include_path, cppadapter_headers )
local_env.Install(libinstall, lib)
py_wrapper_local_env.Install(pyinstall+'/finley', py_wrapper_lib)

# export the lib target since tests will depend on it
# the lib target is a list of file nodes (why? win32 produces more than one output file: .lib, .dll, .pdb)
# FIXME: This list handling produces the desired result but can this be done directly with scons File nodes?
dep_lib = [libinstall+'/'+str(x) for x in lib]
Export('dep_lib')

# add source files to release
release_srcfiles = [ env.File(x) for x in filenames + cppadapter_filenames ] + [env.File("SConscript"), ]
env.Zip(src_zipfile, release_srcfiles)
env.Tar(src_tarfile, release_srcfiles)

# Call the python sconscript
env.SConscript(dirs = ['#/finley/py_src'], build_dir='py', duplicate=0)

# Call the unit tests SConscript
local_env.SConscript(dirs = ['#/finley/test'], build_dir='#/build/$PLATFORM/finley/test', duplicate=0)

