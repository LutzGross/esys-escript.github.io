
/*******************************************************
*
* Copyright (c) 2003-2010 by University of Queensland
* Earth Systems Science Computational Center (ESSCC)
* http://www.uq.edu.au/esscc
*
* Primary Business: Queensland, Australia
* Licensed under the Open Software License version 3.0
* http://www.opensource.org/licenses/osl-3.0.php
*
*******************************************************/


/**************************************************************/

/* Paso: SystemMatrix                                       */

/*  Merge the MainBlock and CoupleBlock in the matrix         */


/**************************************************************/

/* Copyrights by ACcESS Australia 2003 */
/* Author: Lin Gao, l.gao@uq.edu.au */

/**************************************************************/

#include "Paso.h"
#include "SystemMatrix.h"

void Paso_SystemMatrix_mergeMainAndCouple(Paso_SystemMatrix* A, index_t** p_ptr, index_t** p_idx, double** p_val){
  if (A->type & MATRIX_FORMAT_CSC) {
      if (A->type & (MATRIX_FORMAT_OFFSET1 + MATRIX_FORMAT_BLK1)) {
          Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1(A, p_ptr, p_idx, p_val);
      } else {
          Paso_setError(SYSTEM_ERROR,"Paso_SystemMatrix_mergeMainAndCouple: CSC with index 0 or block size larger than 1 is not supported. ");
      }
  } else if (A->type & MATRIX_FORMAT_TRILINOS_CRS) {
      Paso_setError(SYSTEM_ERROR,"Paso_SystemMatrix_mergeMainAndCouple: TRILINOS is not supported. ");
  } else {
      Paso_setError(SYSTEM_ERROR,"Paso_SystemMatrix_mergeMainAndCouple: CRS is not supported. ");
  }
  return;
}

void Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1(Paso_SystemMatrix* A, index_t** p_ptr, index_t** p_idx, double** p_val) {

  index_t i, j, k, i_ub, j_ub, k_ub, col, num_vals, main_num_vals;
  index_t couple_num_vals, idx, rank, tmp_idx, len;
  index_t main_offset, couple_offset_l, couple_offset_r;
  index_t main_num_cols=A->mainBlock->pattern->numOutput;
  index_t couple_num_cols=A->col_coupleBlock->pattern->numOutput;
  index_t *main_ptr=A->mainBlock->pattern->ptr;
  index_t *main_idx=A->mainBlock->pattern->index;
  double  *main_val=A->mainBlock->val;
  index_t *couple_ptr=A->col_coupleBlock->pattern->ptr;
  index_t *couple_idx=A->col_coupleBlock->pattern->index;
  double  *couple_val=A->col_coupleBlock->val;
  Paso_SharedComponents*  coupler=A->col_coupler->connector->recv;

  if (A->mainBlock->col_block_size!=1 || 
      A->mainBlock->row_block_size!=1 ||
      A->col_coupleBlock->col_block_size!=1 ||
      A->col_coupleBlock->row_block_size!=1) {
      Paso_setError(TYPE_ERROR,"Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1: requires format with block size 1.");
      return;
  }
  
  if (main_num_cols != couple_num_cols) {
      Paso_setError(TYPE_ERROR,"Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1: number of collums do not match.");
      return;
  }

  /* allocate arrays "ptr", "index" and "val" */
  main_num_vals = main_ptr[main_num_cols]-1;
  couple_num_vals = couple_ptr[couple_num_cols]-1;
  num_vals = main_num_vals + couple_num_vals;
  *p_ptr = MEMALLOC(main_num_cols+1, index_t);
  *p_idx = MEMALLOC(num_vals, index_t);
  *p_val = MEMALLOC(num_vals, double);

  /* initialize before merge */
  (*p_ptr)[0] = 1;
  rank = A->mpi_info->rank;
  main_offset = A->col_distribution->first_component[rank];
  k_ub=coupler->numNeighbors;
  len = 0;
  for (k=0; k<=k_ub; k++){
      if (coupler->neighbor[k] < rank) 
          len += (coupler->offsetInShared[k+1] - coupler->offsetInShared[k]);
  }
  couple_offset_l = main_offset - len;
  couple_offset_r = A->col_distribution->first_component[rank+1] - len;
  i=0;
  j=0;

/*{
  for (col=0;col<couple_num_cols;col++){
    for (i_ub=couple_ptr[col];i_ub<couple_ptr[col+1];i_ub++)
      printf("%d %d %e\n", col+1, couple_idx[i_ub-1], couple_val[i_ub-1]);
  }
}*/

//fprintf(stderr, "rank %d: cols %d, vals %d\n", rank, main_num_cols, num_vals);

  /* merge mainBlock and col_coupleBlock */
  for (col=1; col<=main_num_cols; col++) {
      i_ub = main_ptr[col]-1;
      j_ub = couple_ptr[col]-1;
      while (i < i_ub || j < j_ub) {
          if (j < j_ub) {
              /* switch from coupleBlock index to global row index of matrix */
              tmp_idx = coupler->shared[couple_idx[j]-1]+1-couple_num_cols;
              for (k=1; k<=k_ub; k++)
                   if (couple_idx[j]<=coupler->offsetInShared[k]) break; 
              if (coupler->neighbor[k-1] < rank)
                  idx = couple_offset_l + tmp_idx;
              else 
                  idx = couple_offset_r + tmp_idx;
          }
          if (j == j_ub || (i < i_ub && (main_idx[i] + main_offset) < idx)){
              (*p_idx)[i+j] = main_idx[i] + main_offset;
              (*p_val)[i+j] = main_val[i];
              i++;
          } else {
              (*p_idx)[i+j] = idx;
              (*p_val)[i+j] = couple_val[j];
              j++;
          }
      }
      (*p_ptr)[col] = i+j+1;
  }

/*
if (rank == 1){
  fprintf(stderr, "cols: %d, vals %d\n", main_num_cols, num_vals);
  for (col=0; col<main_num_cols; col++){
    fprintf(stderr, "\nrow %d ptr(%d--%d): ", col+1, (*p_ptr)[col], (*p_ptr)[col+1]);
    for (i=(*p_ptr)[col];i<(*p_ptr)[col+1];i++)
      fprintf(stderr, "%d ", (*p_idx)[i-1]);
  }
  fprintf(stderr,"\n");
} 


{
  index_t *ptr, *idx, tmp[A->mpi_info->size];
  double  *val;
  MPI_Reduce(&main_num_cols, &j, 1, MPI_INT, MPI_SUM, 0, A->mpi_info->comm);
  MPI_Gather(&num_vals, 1, MPI_INT, tmp, 1, MPI_INT, 0, A->mpi_info->comm);
  if (rank == 0) {
    for (i=0,k=0; i<A->mpi_info->size;i++) k+=tmp[i];
    ptr = MEMALLOC(j+1, index_t);
    idx = MEMALLOC(k, index_t);
    val = MEMALLOC(k, double);
  }
  MPI_Gather(*p_ptr, main_num_cols, MPI_INT, ptr, main_num_cols, MPI_INT, 0, A->mpi_info->comm);
  MPI_Gather(*p_idx, num_vals, MPI_INT, idx, num_vals, MPI_INT, 0, A->mpi_info->comm);
  if (rank == 0) {
    for (i=tmp[0]; i<tmp[1]+tmp[0];i++){
      if (i==(i/20)*20) printf("\n");
      printf("%d ", idx[i]);
    }
  }
  MPI_Gather(*p_val, num_vals, MPI_DOUBLE, val, num_vals, MPI_DOUBLE, 0, A->mpi_info->comm);
  if (rank == 0) {
    j_ub = 0;
    main_offset = 0;
    for (col=0;col<j;col++){
      if (ptr[col] == 1 && col != 0){
        main_offset += tmp[j_ub];
        j_ub++;
      }
      ptr[col] += main_offset;
    }
    ptr[j]=k+1;
    for (col=0;col<j;col++){
      printf("ptr %d = %d--%d\n", col+1, ptr[col], ptr[col+1]);
      for (i=ptr[col];i<ptr[col+1];i++){
        printf("%d %d\t\t%e\n", col+1, idx[i-1], val[i-1]);
      }
    }
    MEMFREE(ptr);
    MEMFREE(idx);
    MEMFREE(val);
  }
}
*/
  return;
}

void Paso_SystemMatrix_copyMain_CSC_OFFSET1(Paso_SystemMatrix* A, index_t** p_ptr, index_t** p_idx, double** p_val) {

  index_t i, i_ub, col, num_vals, idx;
  index_t main_num_cols=A->mainBlock->pattern->numOutput;
  index_t *main_ptr=A->mainBlock->pattern->ptr;
  index_t *main_idx=A->mainBlock->pattern->index;
  double  *main_val=A->mainBlock->val;

  if (A->mainBlock->col_block_size!=1 || A->mainBlock->row_block_size!=1) {
      Paso_setError(TYPE_ERROR,"Paso_SystemMatrix_mergeMainAndCouple_CSC_OFFSET1: requires format with block size 1.");
      return;
  }

  /* allocate arrays "ptr", "index" and "val" */
  num_vals = main_ptr[main_num_cols]-1;
  *p_ptr = MEMALLOC(main_num_cols+1, index_t);
  *p_idx = MEMALLOC(num_vals, index_t);
  *p_val = MEMALLOC(num_vals, double);

  /* copy from mainBlock */
  (*p_ptr)[0] = 1;
  i=0;
  for (col=1; col<=main_num_cols; col++) {
      i_ub = main_ptr[col]-1;
      while (i < i_ub) {
          (*p_idx)[i] = main_idx[i];
          (*p_val)[i] = main_val[i];
          i++;
      }
      (*p_ptr)[col] = i+1;
  }
  return;
}

