# $Id: run_visualization_interface.py 798 2006-08-04 01:05:36Z gross $

__copyright__="""  Copyright (c) 2006 by ACcESS MNRF
                    http://www.access.edu.au
                Primary Business: Queensland, Australia"""
__license__="""Licensed under the Open Software License version 3.0
             http://www.opensource.org/licenses/osl-3.0.php"""
import sys
import unittest
import math
import numarray
from esys.pycad import *

try:
     PYCAD_TEST_DATA=os.environ['PYCAD_TEST_DATA']
except KeyError:
     PYCAD_TEST_DATA='.'

try:
     PYCAD_WORKDIR=os.environ['PYCAD_WORKDIR']
except KeyError:
     PYCAD_WORKDIR='.'

PYCAD_TEST_MESH_PATH=PYCAD_TEST_DATA+"/data_meshes/"
PYCAD_WORKDIR_PATH=PYCAD_WORKDIR+"/"

def _cross(x, y):
    return numarray.array([x[1] * y[2] - x[2] * y[1], x[2] * y[0] - x[0] * y[2], x[0] * y[1] - x[1] * y[0]])


class Test_PyCAD_Transformations(unittest.TestCase):
   ABS_TOL=1.e-8
   def __distance(self,x,y):
       return math.sqrt(numarray.dot(x-y,x-y))
   def test_Translation_x(self):
        t=Translation([1,0,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([1,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([1,0,1]))<self.ABS_TOL,"s2 is wrong.")
   def test_Translation_y(self):
        t=Translation([0,1,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1,1,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,2,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,1,1]))<self.ABS_TOL,"s2 is wrong.")
   def test_Translation_z(self):
        t=Translation([0,0,1])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1,0,1]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,1]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_0_two(self):
        t=Dilation(2.)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,2,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_0_half(self):
        t=Dilation(0.5)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.5,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,0.5,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,0.5]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_x_two(self):
        t=Dilation(2.,[1.,0.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s0_1=t([0,0,0])
        self.failUnless(isinstance(s0_1,numarray.NumArray),"s0_1 is not a numarray object.")
        self.failUnless(self.__distance(s0_1,numarray.array([-1.,0,0]))<self.ABS_TOL,"s0_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([-1,2,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([-1.,0,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_x_half(self):
        t=Dilation(0.5,[1.,0.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0]))<self.ABS_TOL,"s0 is wrong.")
        s0_1=t([0,0,0])
        self.failUnless(isinstance(s0_1,numarray.NumArray),"s0_1 is not a numarray object.")
        self.failUnless(self.__distance(s0_1,numarray.array([.5,0,0]))<self.ABS_TOL,"s0_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.5,0.5,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.5,0,0.5]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_y_two(self):
        t=Dilation(2.,[0.,1.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2.,-1.,0]))<self.ABS_TOL,"s0 is wrong.")
        s1_1=t([0,0,0])
        self.failUnless(isinstance(s1_1,numarray.NumArray),"s1_1 is not a numarray object.")
        self.failUnless(self.__distance(s1_1,numarray.array([0.,-1.,0]))<self.ABS_TOL,"s1_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1.,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,-1.,2]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_y_half(self):
        t=Dilation(0.5,[0.,1.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.5,0.5,0]))<self.ABS_TOL,"s0 is wrong.")
        s1_1=t([0,0,0])
        self.failUnless(isinstance(s1_1,numarray.NumArray),"s1_1 is not a numarray object.")
        self.failUnless(self.__distance(s1_1,numarray.array([0,0.5,0]))<self.ABS_TOL,"s1_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1.,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0.5,0.5]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_z_two(self):
        t=Dilation(2.,[0.,0.,1.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([2.,0.,-1.]))<self.ABS_TOL,"s0 is wrong.")
        s2_1=t([0,0,0])
        self.failUnless(isinstance(s2_1,numarray.NumArray),"s2_1 is not a numarray object.")
        self.failUnless(self.__distance(s2_1,numarray.array([0.,0.,-1.]))<self.ABS_TOL,"s2_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,2.,-1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0.,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Dilation_z_half(self):
        t=Dilation(0.5,[0.,0.,1.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.5,0.,0.5]))<self.ABS_TOL,"s0 is wrong.")
        s2_1=t([0,0,0])
        self.failUnless(isinstance(s2_1,numarray.NumArray),"s2_1 is not a numarray object.")
        self.failUnless(self.__distance(s2_1,numarray.array([0,0,0.5]))<self.ABS_TOL,"s2_1 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,0.5,0.5]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0.,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Reflection_x_offset0(self):
        t=Reflection([1.,0.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([-1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([-1.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_x_offset2(self):
        t=Reflection([-2.,0.,0.],offset=-4)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([3.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([4,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([4,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([3.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_x_offset2_vector(self):
        t=Reflection([1.,0.,0.],offset=[2,0,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([3.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([4,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([4,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([3.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_y_offset0(self):
        t=Reflection([0.,1.,0.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,-1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,-2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_y_offset2(self):
        t=Reflection([0.,-2.,0.],offset=-4)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,4,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,3,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,4,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_y_offset2_vector(self):
        t=Reflection([0.,1.,0.],offset=[0,2,0])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,4,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,3,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,4,1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_z_offset0(self):
        t=Reflection([0.,0.,1.])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,0]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,-1]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,-3]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_z_offset2(self):
        t=Reflection([0.,0.,-2.],offset=-4)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,4.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,4]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,3]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,1]))<self.ABS_TOL,"s is wrong.")
   def test_Reflection_z_offset2_vector(self):
        t=Reflection([0.,0.,1.],offset=[0,0,2])
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,4.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0,1,4]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0,0,3]))<self.ABS_TOL,"s2 is wrong.")
        s=t([1,2,3])
        self.failUnless(isinstance(s,numarray.NumArray),"s is not a numarray object.")
        self.failUnless(self.__distance(s,numarray.array([1.,2,1]))<self.ABS_TOL,"s is wrong.")
   def test_Rotatation_x_90_0(self):
        t=Rotatation(axis=[1.,0.,0.],point=[1.,0.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,0,1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,-1.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_x_30_0(self):
        t=Rotatation(axis=[1.,0.,0.],point=[1.,0.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([1.,0.,0.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([1.,0.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_x_330_0(self):
        t=Rotatation(axis=[1.,0.,0.],point=[1.,0.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(330*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([1.,0.,0.]))>0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([1.,0.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_x_90(self):
        t=Rotatation(axis=[-1.,0.,0.],point=[2.,0.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,0,-1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,1.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_x_30(self):
        t=Rotatation(axis=[-1.,0.,0.],point=[1.,0.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([-1.,0.,0.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([-1.,0.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_x_330(self):
        t=Rotatation(axis=[-1.,0.,0.],point=[1.,0.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(330*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([-1.,0.,0.]))>0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([-1.,0.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_y_90_0(self):
        t=Rotatation(axis=[0.,1.,0.],point=[0.,1.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,0,-1.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,5,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([1,0.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_y_30_0(self):
        t=Rotatation(axis=[0.,1.,0.],point=[0.,1.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,1.,0.]))<0.,"s0 has wrong orientation.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,5,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,1.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_y_330_0(self):
        t=Rotatation(axis=[0.,1.,0.],point=[0.,1.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,1.,0.]))>0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,1.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_y_90(self):
        t=Rotatation(axis=[0.,-1.,0.],point=[0.,2.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,0,1.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,5,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([-1,0.,0.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_y_30(self):
        t=Rotatation(axis=[0.,-1.,0.],point=[0.,2.,0.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,-1.,0.]))<0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(30*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,-1.,0.]))<0.,"s2 has wrong orientation.")
   def test_Rotatation_y_330(self):
        t=Rotatation(axis=[0.,-1.,0.],point=[0.,2.,0.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,-1.,0.]))>0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-1.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(s2[2]-math.cos(330*DEG))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[0,0,1]),numarray.array([0.,-1.,0.]))>0.,"s2 has wrong orientation.")
   def test_Rotatation_z_90_0(self):
        t=Rotatation(axis=[0.,0.,1.],point=[0.,0.,1.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,1,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([-5.,0,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_30_0(self):
        t=Rotatation(axis=[0.,0.,1.],point=[0.,0.,1.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,1.]))<0.,"s0 has wrong orientation.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-5.**2)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]/5.-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,5,0]),numarray.array([0.,0.,1.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_330_0(self):
        t=Rotatation(axis=[0.,0.,1.],point=[0.,0.,1.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,1.]))>0.,"s0 has wrong orientation.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-5.**2)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]/5.-math.cos(330*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([0.,0.,1.]))>0.,"s1 has wrong orientation.")
   def test_Rotatation_z_90(self):
        t=Rotatation(axis=[0.,0.,-1.],point=[0.,0.,2.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([0.,-1,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,5,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([5.,0,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_30(self):
        t=Rotatation(axis=[0.,0.,-1.],point=[0.,0.,2.],angle=30*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(30*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,-1.]))<0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([0.,0.,-1.]))<0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_330(self):
        t=Rotatation(axis=[0.,0.,-1.],point=[0.,0.,2.],angle=330*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-1.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(s0[0]-math.cos(330*DEG))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,0,0]),numarray.array([0.,0.,-1.]))>0.,"s0 has wrong orientation.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-1.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(s1[1]-math.cos(30*DEG))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,0]),numarray.array([0.,0.,-1.]))>0.,"s1 has wrong orientation.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_x_90_1(self):
        t=Rotatation(point=[0.,0.,1.],axis=[1.,0.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,1,1.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,2.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([0.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_y_90_1(self):
        t=Rotatation(point=[1.,0.,0.],axis=[0.,1.,0.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,0,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([1.,1,1.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([2.,0,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_z_90_1(self):
        t=Rotatation(point=[0.,1.,0.],axis=[0.,0.,1.],angle=90*DEG)
        s0=t([1,0,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(self.__distance(s0,numarray.array([1.,2,0.]))<self.ABS_TOL,"s0 is wrong.")
        s1=t([0,1,0])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(self.__distance(s1,numarray.array([0.,1,0.]))<self.ABS_TOL,"s1 is wrong.")
        s2=t([0,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(self.__distance(s2,numarray.array([1.,1,1.]))<self.ABS_TOL,"s2 is wrong.")
   def test_Rotatation_diag_90_0(self):
        t=Rotatation(axis=[1.,1.,1.],angle=90*DEG)
        s0=t([1,-1,0])
        self.failUnless(isinstance(s0,numarray.NumArray),"s0 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s0,s0)-2.)<self.ABS_TOL,"s0 length is wrong.")
        self.failUnless(abs(numarray.dot(s0,numarray.array([1,-1,0])))<self.ABS_TOL,"s0 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s0,[1,-1,0]),numarray.array([1.,1.,1.]))<0.,"s0 has wrong orientation.")
        s1=t([0,1,-1])
        self.failUnless(isinstance(s1,numarray.NumArray),"s1 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s1,s1)-2.)<self.ABS_TOL,"s1 length is wrong.")
        self.failUnless(abs(numarray.dot(s1,numarray.array([0,1,-1])))<self.ABS_TOL,"s1 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s1,[0,1,-1]),numarray.array([1.,1.,1.]))<0.,"s1 has wrong orientation.")
        s2=t([-1,0,1])
        self.failUnless(isinstance(s2,numarray.NumArray),"s2 is not a numarray object.")
        self.failUnless(abs(numarray.dot(s2,s2)-2.)<self.ABS_TOL,"s2 length is wrong.")
        self.failUnless(abs(numarray.dot(s2,numarray.array([-1,0,1])))<self.ABS_TOL,"s2 angle is wrong.")
        self.failUnless(numarray.dot(_cross(s2,[-1,0,1]),numarray.array([1.,1.,1.]))<0.,"s2 has wrong orientation.")
        s3=t([1,1,1])
        self.failUnless(isinstance(s3,numarray.NumArray),"s3 is not a numarray object.")
        self.failUnless(self.__distance(s3,numarray.array([1.,1,1.]))<self.ABS_TOL,"s3 is wrong.")

class Test_PyCAD_Primitives(unittest.TestCase):
   def setUp(self):
         resetGlobalPrimitiveIdCounter()

   def test_baseclass(self):
         p=Primitive()

         id=p.getID()
         self.failUnless(isinstance(id,int),"id number is not an integer")
         self.failUnless(not id==Primitive().getID(),"id number is not unique")
           
         hs=p.getPrimitives()
         self.failUnless(len(hs)==0,"history should be empty.")

         ps=p.getConstructionPoints()
         self.failUnless(len(ps)==0,"point set should be empty.")

   def test_point(self):
       p=Point(1.,2.,3.,local_scale=9.)
       
       id=p.getID()
       self.failUnless(isinstance(id,int),"id number is not an integer")
       self.failUnless(not id==Primitive().getID(),"id number is not unique")
           
       # check history:
       hs=p.getPrimitives()
       self.failUnless(len(hs)==1,"history must have length 1.")
       self.failUnless(p in hs,"history must contain point p")

       # check incolved points:
       ps=p.getConstructionPoints()
       self.failUnless(len(ps)==1,"point set must have length 1.")
       self.failUnless(p in ps,"point set must contain point p")

       # check coordinates:
       c=p.getCoordinates()
       self.failUnless(isinstance(c,numarray.NumArray),"coordinates are not a numarray object.")
       self.failUnless(c[0]==1.,"x coordinate is not 1.")
       self.failUnless(c[1]==2.,"y coordinate is not 2.")
       self.failUnless(c[2]==3.,"z coordinate is not 3.")
 
       # reset coordinates:
       p.setCoordinates([-1.,-2.,-3.])
       c=p.getCoordinates()
       self.failUnless(isinstance(c,numarray.NumArray),"new coordinates are not a numarray object.")
       self.failUnless(c[0]==-1.,"new x coordinate is not -1.")
       self.failUnless(c[1]==-2.,"new y coordinate is not -2.")
       self.failUnless(c[2]==-3.,"new z coordinate is not -3.")

       # check for a colocated point:
       self.failUnless(p.isColocated(Point(-1.,-2.,-3.)),"colocation not detected.")
       self.failUnless(not p.isColocated(numarray.array([-1.,-2.,-3.])),"colocation with numarray representation not detected.")
       self.failUnless(not p.isColocated(Point(1.,-2.,-3.)),"false colocation detected.")
       self.failUnless(not p.isColocated(Point(0.,0.,0.)),"false colocation with origin detected.")

       # check for local length scale
       l=p.getLocalScale()
       self.failUnless(l==9.,"refinement scale is not 9.")

       # check for new local length scale
       p.setLocalScale(3.)
       l=p.getLocalScale()
       self.failUnless(l==3.,"new refinement scale is not 3.")

       # negative value shouldn't work.
       self.failUnlessRaises(ValueError,p.setLocalScale,-3.)

       # copy:
       an_other_p=p.copy()
       self.failUnless(isinstance(an_other_p ,Point),"copy is not a point")
       self.failUnless(not an_other_p.getID() == p.getID(),"copy has same Id")
       self.failUnless(p.isColocated(an_other_p),"p is not colocated with its copy.")
       self.failUnless(an_other_p.isColocated(p),"the copy is not colocated with p.")
       self.failUnless(an_other_p.getLocalScale()==3.,"copy has wrong local scale.")
      
       # modify by Transformation:
       p.modifyBy(Dilation(-1))
       self.failUnless(p.isColocated(Point(1.,2.,3.)),"in-place transformation failed")
       
       # apply Transformation:
       dil_p=p.apply(Dilation(4))
       self.failUnless(dil_p.isColocated(Point(4.,8.,12.)),"applying transformation failed")
       self.failUnless(not dil_p.getID() == p.getID(),"transformed point has same Id")
       self.failUnless(dil_p.getLocalScale()==3.,"transformed point  has wrong local scale.")
        
       # overloaded add:
       shift_p=p+[1,1,1]
       self.failUnless(shift_p.isColocated(Point(2,3.,4)),"applying shift by list failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by list has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by list has wrong local scale.")

       shift_p=p+numarray.array([1,1,1])
       self.failUnless(shift_p.isColocated(Point(2,3.,4)),"applying shift by numarray failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by numarray has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by numarray has wrong local scale.")
       # overloaded minus
       shift_p=p-[1,1,1]
       self.failUnless(shift_p.isColocated(Point(0,1,2.)),"applying shift by -list failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by -list has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by -list has wrong local scale.")

       shift_p=p-numarray.array([1,1,1])
       self.failUnless(shift_p.isColocated(Point(0,1,2.)),"applying shift by -numarray failed")
       self.failUnless(not shift_p.getID() == p.getID(),"shift by -numarray has same Id")
       self.failUnless(shift_p.getLocalScale()==3.,"shift by -numarray has wrong local scale.")
       # overloaded inplace add:
       p+=[1,1,1]
       self.failUnless(p.isColocated(Point(2,3.,4)),"modification by list shift failed")

       p+=numarray.array([1,1,1])
       self.failUnless(p.isColocated(Point(3,4,5)),"modification by numarray shift failed")

       # overloaded inplace add:
       p-=[1,1,1]
       self.failUnless(p.isColocated(Point(2,3,4)),"modification by -list shift failed")

       p-=numarray.array([1,1,1])
       self.failUnless(p.isColocated(Point(1,2.,3)),"modification by -numarray shift failed")

       #overloaded multiplication:
       mult_p=2*p
       self.failUnless(mult_p.isColocated(Point(2,4,6)),"applying int factor failed")
       self.failUnless(not mult_p.getID() == p.getID(),"shift by int factor has same Id")
       self.failUnless(mult_p.getLocalScale()==3.,"shift by int factor has wrong local scale.")

       mult_p=2.*p
       self.failUnless(mult_p.isColocated(Point(2,4,6)),"applying float factor failed")
       self.failUnless(not mult_p.getID() == p.getID(),"shift by float factor has same Id")
       self.failUnless(mult_p.getLocalScale()==3.,"shift by float factor has wrong local scale.")

       mult_p=Dilation(2)*p
       self.failUnless(mult_p.isColocated(Point(2,4,6)),"applying Dilation factor failed")
       self.failUnless(not mult_p.getID() == p.getID(),"shift by Dilation factor has same Id")
       self.failUnless(mult_p.getLocalScale()==3.,"shift by Dilation factor has wrong local scale.")

       #overloaded inplace multiplication:
       p*=2
       self.failUnless(p.isColocated(Point(2,4,6)),"applying in-place int factor failed")

       p*=2.
       self.failUnless(p.isColocated(Point(4,8,12)),"applying in-place float factor failed")

       p*=Dilation(2)
       self.failUnless(p.isColocated(Point(8,16,24)),"applying in-place Dilation factor failed")

       # get gmsh code
       code=p.getGmshCommand(2.)
       self.failUnless("Point(1) = {8.0 , 16.0, 24.0 , 6.0 };"== code, "wrong gmsh code")
 
   def test_spline(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,Spline,p0)
        c=Spline(p0,p1,p2,p3)

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p3, "wrong end point of spline curve")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")
        self.failUnless(co[2]==p2, "3rd control point is wrong.")
        self.failUnless(co[3]==p3, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Spline(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        cpcp=cp.getControlPoints()
        self.failUnless(p0.isColocated(cpcp[0]),"1st point of copy and source are not collocated.")
        self.failUnless(p1.isColocated(cpcp[1]),"2nd point of copy and source are not collocated.")
        self.failUnless(p2.isColocated(cpcp[2]),"3rd point of copy and source are not collocated.")
        self.failUnless(p3.isColocated(cpcp[3]),"4th point of copy and source are not collocated.")
        self.failUnless(c.isColocated(cp),"spline curve is not collocated with its copy.")
        self.failUnless(not c.isColocated(p0),"spline curve is collocated with point.")
        self.failUnless(not c.isColocated(Spline(p0,p1)),"spline curve is collocated with shorter spline curve.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")
        self.failUnless(not c.isColocated(Spline(p0,p1,p4,p3)),"spline curve is collocated with defomed spline curve.")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(Spline(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p0.isColocated(Point(0,0,0)),"1st point has not been modified through Dilation.")
        self.failUnless(p1.isColocated(Point(-1,-1,-1)),"2nd point has not been modified through Dilation.")
        self.failUnless(p2.isColocated(Point(-2,-2,-2)),"3rd point has not been modified through Dilation.")
        self.failUnless(p3.isColocated(Point(-3,-3,-3)),"4th point has not been modified through Dilation.")
        cp=c.getControlPoints()
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p2 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p3 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(Spline(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        dccp=dc.getControlPoints()
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")
   

   def test_BezierCurve(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,BezierCurve,p0)
        c=BezierCurve(p0,p1,p2,p3)

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p3, "wrong end point of spline curve")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")
        self.failUnless(co[2]==p2, "3rd control point is wrong.")
        self.failUnless(co[3]==p3, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Bezier(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        cpcp=cp.getControlPoints()
        self.failUnless(p0.isColocated(cpcp[0]),"1st point of copy and source are not collocated.")
        self.failUnless(p1.isColocated(cpcp[1]),"2nd point of copy and source are not collocated.")
        self.failUnless(p2.isColocated(cpcp[2]),"3rd point of copy and source are not collocated.")
        self.failUnless(p3.isColocated(cpcp[3]),"4th point of copy and source are not collocated.")
        self.failUnless(c.isColocated(cp),"spline curve is not collocated with its copy.")
        self.failUnless(not c.isColocated(p0),"spline curve is collocated with point.")
        self.failUnless(not c.isColocated(BezierCurve(p0,p1)),"spline curve is collocated with shorter spline curve.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")
        self.failUnless(not c.isColocated(BezierCurve(p0,p1,p4,p3)),"spline curve is collocated with defomed spline curve.")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(BezierCurve(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p0.isColocated(Point(0,0,0)),"1st point has not been modified through Dilation.")
        self.failUnless(p1.isColocated(Point(-1,-1,-1)),"2nd point has not been modified through Dilation.")
        self.failUnless(p2.isColocated(Point(-2,-2,-2)),"3rd point has not been modified through Dilation.")
        self.failUnless(p3.isColocated(Point(-3,-3,-3)),"4th point has not been modified through Dilation.")
        cp=c.getControlPoints()
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p2 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p3 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(BezierCurve(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        dccp=dc.getControlPoints()
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")

   def test_BSpline(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p2=Point(2,2,2,0.3)
        p3=Point(3,3,3,0.4)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,BSpline,p0)
        c=BSpline(p0,p1,p2,p3)

        self.failUnless(len(c) == 4, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p3, "wrong end point of spline curve")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")
        self.failUnless(co[2]==p2, "3rd control point is wrong.")
        self.failUnless(co[3]==p3, "4th control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")
        self.failUnless(co[2].getLocalScale() == 3., "new local scale of 3rd control point is wrong.")
        self.failUnless(co[3].getLocalScale() == 3., "new local scale of 4th control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "BSpline(6) = {1, 2, 3, 4};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 5, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(p2 in h, "missing p2 in history.")
        self.failUnless(p3 in h, "missing p3 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        cpcp=cp.getControlPoints()
        self.failUnless(p0.isColocated(cpcp[0]),"1st point of copy and source are not collocated.")
        self.failUnless(p1.isColocated(cpcp[1]),"2nd point of copy and source are not collocated.")
        self.failUnless(p2.isColocated(cpcp[2]),"3rd point of copy and source are not collocated.")
        self.failUnless(p3.isColocated(cpcp[3]),"4th point of copy and source are not collocated.")
        self.failUnless(c.isColocated(cp),"spline curve is not collocated with its copy.")
        self.failUnless(not c.isColocated(p0),"spline curve is collocated with point.")
        self.failUnless(not c.isColocated(BSpline(p0,p1)),"spline curve is collocated with shorter spline curve.")
        self.failUnless(not c.isColocated(Curve(p0,p1,p2,p3)),"spline curve is identified with curve.")
        self.failUnless(not c.isColocated(BSpline(p0,p1,p4,p3)),"spline curve is collocated with defomed spline curve.")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(BSpline(Point(0,0,0),Point(-1,-1,-1),Point(-2,-2,-2),Point(-3,-3,-3))),"inplace dilation is wrong.")
        self.failUnless(p0.isColocated(Point(0,0,0)),"1st point has not been modified through Dilation.")
        self.failUnless(p1.isColocated(Point(-1,-1,-1)),"2nd point has not been modified through Dilation.")
        self.failUnless(p2.isColocated(Point(-2,-2,-2)),"3rd point has not been modified through Dilation.")
        self.failUnless(p3.isColocated(Point(-3,-3,-3)),"4th point has not been modified through Dilation.")
        cp=c.getControlPoints()
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")
        self.failUnless(p2 == cp[2],"3rd new point after Dilation.")
        self.failUnless(p3 == cp[3],"4th new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(BSpline(Point(0,0,0),Point(1,1,1),Point(2,2,2),Point(3,3,3))),"dilation is wrong.")
        dccp=dc.getControlPoints()
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")
        self.failUnless(not p2 == dccp[2],"3rd point of Dilation is identical to source.")
        self.failUnless(not p3 == dccp[3],"4th point of Dilation is identical to source.")

   def test_LineSegment(self):
        p0=Point(0,0,0,0.1)
        p1=Point(1,1,1,0.2)
        p4=Point(1,2,3)
 
        self.failUnlessRaises(TypeError,Line,p0)
        self.failUnlessRaises(TypeError,Line,p0,p1,p4)

        c=Line(p0,p1)

        self.failUnless(len(c) == 2, "wrong spline curve length")
        self.failUnless(c.getStartPoint()==p0, "wrong start point of spline curve")
        self.failUnless(c.getEndPoint()==p1, "wrong end point of spline curve")

        co=c.getControlPoints()
        self.failUnless(co[0]==p0, "1st control point is wrong.")
        self.failUnless(co[1]==p1, "2nd control point is wrong.")

        c.setLocalScale(3.)
        co=c.getControlPoints()
        self.failUnless(co[0].getLocalScale() == 3., "new local scale of 1st control point is wrong.")
        self.failUnless(co[1].getLocalScale() == 3., "new local scale of 2nd control point is wrong.")

        code=c.getGmshCommand()
        self.failUnless(code == "Line(4) = {1, 2};", "gmsh command wrong.")

        h=c.getPrimitives()
        self.failUnless(len(h) == 3, "number of primitives in history is wrong.")
        self.failUnless(p0 in h, "missing p0 in history.")
        self.failUnless(p1 in h, "missing p1 in history.")
        self.failUnless(c in h, "missing spline curve in history.")

        cp=c.copy()
        self.failUnless(not cp == c, "copy returns same spline curve.")
        cpcp=cp.getControlPoints()
        self.failUnless(p0.isColocated(cpcp[0]),"1st point of copy and source are not collocated.")
        self.failUnless(p1.isColocated(cpcp[1]),"2nd point of copy and source are not collocated.")
        self.failUnless(c.isColocated(cp),"spline curve is not collocated with its copy.")
        self.failUnless(not c.isColocated(p0),"spline curve is collocated with point.")
        self.failUnless(not c.isColocated(Curve(p0,p1)),"spline curve is identified with curve.")
        self.failUnless(not c.isColocated(Line(p0,p4)),"spline curve is collocated with defomed spline curve.")

        c.modifyBy(Dilation(-1.))
        self.failUnless(c.isColocated(Line(Point(0,0,0),Point(-1,-1,-1))),"inplace dilation is wrong.")
        self.failUnless(p0.isColocated(Point(0,0,0)),"1st point has not been modified through Dilation.")
        self.failUnless(p1.isColocated(Point(-1,-1,-1)),"2nd point has not been modified through Dilation.")
        cp=c.getControlPoints()
        self.failUnless(p0 == cp[0],"1st new point after Dilation.")
        self.failUnless(p1 == cp[1],"2nd new point after Dilation.")

        dc=c.apply(Dilation(-1.))
        self.failUnless(dc.isColocated(Line(Point(0,0,0),Point(1,1,1))),"dilation is wrong.")
        dccp=dc.getControlPoints()
        self.failUnless(not p0 == dccp[0],"1st point of Dilation is identical to source.")
        self.failUnless(not p1 == dccp[1],"2nd point of Dilation is identical to source.")


if __name__ == '__main__':
   suite = unittest.TestSuite()
   suite.addTest(unittest.makeSuite(Test_PyCAD_Transformations))
   suite.addTest(unittest.makeSuite(Test_PyCAD_Primitives))
   s=unittest.TextTestRunner(verbosity=2).run(suite)
   if s.wasSuccessful():
     sys.exit(0)
   else:
     sys.exit(1)
