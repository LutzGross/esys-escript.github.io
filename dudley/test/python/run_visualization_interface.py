
########################################################
#
# Copyright (c) 2003-2010 by University of Queensland
# Earth Systems Science Computational Center (ESSCC)
# http://www.uq.edu.au/esscc
#
# Primary Business: Queensland, Australia
# Licensed under the Open Software License version 3.0
# http://www.opensource.org/licenses/osl-3.0.php
#
########################################################

__copyright__="""Copyright (c) 2003-2010 by University of Queensland
Earth Systems Science Computational Center (ESSCC)
http://www.uq.edu.au/esscc
Primary Business: Queensland, Australia"""
__license__="""Licensed under the Open Software License version 3.0
http://www.opensource.org/licenses/osl-3.0.php"""
__url__="https://launchpad.net/escript-finley"

import sys, math, re
import unittest
from esys.escript import *
from esys.dudley import ReadMesh
from xml.dom import minidom

try:
     DUDLEY_TEST_DATA=os.environ['DUDLEY_TEST_DATA']
except KeyError:
     DUDLEY_TEST_DATA='.'

try:
     DUDLEY_WORKDIR=os.environ['DUDLEY_WORKDIR']
except KeyError:
     DUDLEY_WORKDIR='.'

DUDLEY_TEST_MESH_PATH=os.path.join(DUDLEY_TEST_DATA,"data_meshes")
# if os.name == "nt":
#    DUDLEY_TEST_MESH_PATH = os.path.join(DUDLEY_TEST_MESH_PATH,"win32")
DUDLEY_WORKDIR_PATH=DUDLEY_WORKDIR

class Test_VisualizationInterface(unittest.TestCase):
   def check_vtk_old(self,f,reference_f):
      # if reference_f.startswith("tet_"): os.link(os.path.join(DUDLEY_WORKDIR_PATH,f),os.path.join(DUDLEY_TEST_MESH_PATH,reference_f))
      out_string=open(os.path.join(DUDLEY_WORKDIR_PATH,f)).read().splitlines()
      ref_string=open(os.path.join(DUDLEY_TEST_MESH_PATH,reference_f)).read().splitlines()
      c=0
      for l in range(0,len(ref_string)):
         if not ref_string[l].strip()[:2]=="<!":
           line=out_string[c].strip()
	   if os.name == "nt":
	       line=line.replace("e+00","e+0").replace("e-00","e-0")
	   # line=line.replace("e-00","e+00").replace("-0.000000e+00","0.000000e+00")
	   line=line.replace(".000000e-00",".000000e+00").replace("-0.000000e+00","0.000000e+00")
           self.failUnlessEqual(line,ref_string[l].strip(),"line %d (%s) in vtk files does not match reference (%s)"%(c,line,ref_string[l].strip()))
           c+=1

   # Compare two lists of numbers (stored as space-separated strings) using the L2 norm
   def numericCompareL2(self, vector1, vector2):
     if vector2 == None: return False
     TOL = 1.0e-6
     if len(vector1) != len(vector2): return False
     diff = 0.0
     for i in range(0, len(vector1)):
       tmp = vector1[i] - vector2[i]
       diff += tmp * tmp
     if math.sqrt(diff) > TOL: return False
     return True

   # Compare two elements (stored as space-separated strings of integers) after mapping node labels
   def elementCompareWithMap(self, e1, e2, value_map):
     if e2 == None: return False
     vector1 = e1.split()
     vector2 = e2.split()
     if len(vector1) != len(vector2): return False
     for i in range(0, len(vector1)):
       if int(vector1[i]) < 0: return False
       if int(vector1[i]) >= len(value_map): return False
       if value_map[int(vector1[i])] != int(vector2[i]): return False
     return True

   def compareDataSetWithMap(self, d1, d2, value_map):
     if len(d1) != len(d2): return False
     for i in range(0, len(d1)):
       if value_map.has_key(i):
          if not min( [ self.numericCompareL2(d1[i], d2[k] ) for k in value_map[i] ] ): return False
       else:
          return False
     return True

   # Compare two VTK files which were generated by Dudley method saveVTK
   def saveVtkCompare(self, file1, file2):
     lineList1 = open(file1).read().splitlines()
     lineList2 = open(file2).read().splitlines()

     # lineList1: Trim spaces and delete comments and empty lines
     for i in range(len(lineList1)-1, -1, -1):
       lineList1[i] = lineList1[i].strip()
       if   lineList1[i][:2] == "<!": del(lineList1[i])
       elif lineList1[i] == "":       del(lineList1[i])

     # lineList2: Trim spaces and delete comments and empty lines
     for i in range(len(lineList2)-1, -1, -1):
       lineList2[i] = lineList2[i].strip()
       if   lineList2[i][:2] == "<!": del(lineList2[i])
       elif lineList2[i] == "":       del(lineList2[i])

     if len(lineList1) != len(lineList2):
       return False, "Error: The two files have a different number of lines"

     # Now corresponding XML tags are guaranteed to be on the same line numbers

     # Do a simple string comparison except for data which might be permuted during optimization
     doStringComparison = 1
     for i in range(0, len(lineList1)):
       if lineList1[i].startswith('</DataArray'): doStringComparison = 1
       if doStringComparison and lineList1[i] != lineList2[i]:
         return False, "Files differ at line %d" % int(i+1)
       if lineList1[i].startswith('<DataArray'): doStringComparison = 0
       if lineList1[i].startswith('<DataArray Name="offsets"'): doStringComparison = 1
       if lineList1[i].startswith('<DataArray Name="types"'):   doStringComparison = 1

     # Find the list of nodes
     nodeMap1 = {}	
     withinTheNodeList = False
     cc=0
     for i in range(0, len(lineList1)):
       if withinTheNodeList and lineList1[i].startswith('</DataArray'): break	# Finished reading nodes
       if withinTheNodeList:
         nodeMap1[cc]=[ float(x) for x in lineList1[i].split() ]
         cc+=1
       if lineList1[i].startswith('<DataArray'): withinTheNodeList = True

     nodeMap2 = {}	
     withinTheNodeList = False
     cc=0
     for i in range(0, len(lineList1)):
       if withinTheNodeList and lineList2[i].startswith('</DataArray'): break	# Finished reading nodes
       if withinTheNodeList:
         nodeMap2[cc]=[ float(x) for x in lineList2[i].split() ]
         cc+=1
       if lineList2[i].startswith('<DataArray'): withinTheNodeList = True

     if len(nodeMap1) != len(nodeMap2):
       return False, "Error: The two files have different numbers of nodes"

     nodeMap1to2 = {}
     for n1 in nodeMap1.keys():
           v=[]
           for n2 in nodeMap2.keys():
             if self.numericCompareL2(nodeMap1[n1], nodeMap2[n2]): v.append(n2)
           if len(v)==0: 
              return False, "Error: no matching node for node %s %s."%(n1,nodeMap1[n1])
           nodeMap1to2[n1]=v


     # Find the list of elements
     elementList1 = []
     withinTheElementList = False
     for i in range(0, len(lineList1)):
       if withinTheElementList and lineList1[i].startswith('</DataArray'): break	# Finished reading elements
       if withinTheElementList:
         elementList1.append([ int(x) for x in lineList1[i].split()])	
       if lineList1[i].startswith('<DataArray Name="connectivity"'): withinTheElementList = True

     # Find the list of elements
     elementList2 = []
     withinTheElementList = False
     for i in range(0, len(lineList2)):
       if withinTheElementList and lineList2[i].startswith('</DataArray'): break	# Finished reading elements
       if withinTheElementList:
         elementList2.append([ int(x) for x in lineList2[i].split()])	
       if lineList2[i].startswith('<DataArray Name="connectivity"'): withinTheElementList = True

     if len(elementList1) != len(elementList2):
       return False, "Error: The two files have different numbers of elements"

     # Compute the element mapping from file1 to file2
     elementMap1to2 = {}
     for n1 in range(0, len(elementList1)):
         v=None
         for n2 in range(0, len(elementList2)):
            if len(elementList1[n1]) == len(elementList2[n2]):
               allmatched=True
               for i in elementList1[n1]:
                   if not max([ nnn in nodeMap1to2[i] for nnn in elementList2[n2]] ): allmatched=False
               if allmatched: 
                    v=n2
                    break
         if v == None:
             return False, "Error: element %s is missing."%elementList1[n1]
         else:
             elementMap1to2[n1]=[v]
     # Find the data sets and compare them
     dataList1 = []
     dataList2 = []
     withinCelldata = False
     withinPointdata = False
     withinDataSet = False
     for i in range(0, len(lineList1)):
       if (withinCelldata or withinPointdata) and withinDataSet and lineList1[i].startswith('</DataArray'):
         withinDataSet = False	# Finished reading one of the data sets
         if withinCelldata and not self.compareDataSetWithMap(dataList1, dataList2, elementMap1to2):
           return False, "Error: element data in '%s' did not match" % dataName
         if withinPointdata and not self.compareDataSetWithMap(dataList1, dataList2, nodeMap1to2):
           return False, "Error: point data in '%s' did not match" % dataName
       if withinDataSet:
         dataList1.append([ float(d) for d in lineList1[i].split()] )	# The two files are guaranteed to have the elements on
         dataList2.append([ float(d) for d in lineList2[i].split()] )	# the same lines at this point
       if (withinCelldata or withinPointdata) and lineList1[i].startswith('<DataArray'):
         dataName = re.sub('" .*', '', lineList1[i])
         dataName = re.sub('.*"', '', dataName)
         withinDataSet = True
         dataList1 = []
         dataList2 = []
       if lineList1[i].startswith('<PointData'):  withinPointdata = True
       if lineList1[i].startswith('</PointData'): withinPointdata = False
       if lineList1[i].startswith('<CellData'):   withinCelldata  = True
       if lineList1[i].startswith('</CellData'):  withinCelldata  = False

     return True, "Your VTK files match"
     # End of method self.saveVtkCompare

   def check_vtk(self,f,reference_f):
      success, reason = self.saveVtkCompare(os.path.join(DUDLEY_WORKDIR_PATH,f), os.path.join(DUDLEY_TEST_MESH_PATH,reference_f))
      self.failUnless(success, reason)

   def check_dx(self,f,reference_f):
      out_string=open(os.path.join(DUDLEY_WORKDIR_PATH,f)).read().splitlines()
      ref_string=open(os.path.join(DUDLEY_TEST_MESH_PATH,reference_f)).read().splitlines()
      c=0
      for l in range(0,len(ref_string)):
         if not ref_string[l].strip()[0]=="#":
	   line=out_string[c].strip()
	   if os.name == "nt":
	       line=line.replace("e+00","e+0").replace("e-00","e-0")
	   line=line.replace("e-00","e+00").replace("-0.000000e+00","0.000000e+00")
           self.failUnlessEqual(line,ref_string[l].strip(),"line %d (%s) in dx file does not match reference (%s)"%(c,line,ref_string[l].strip()))
           c+=1

class Test_VTKFiles(Test_VisualizationInterface):
  #def test_metadata_0(self):
     #fn=os.path.join(DUDLEY_WORKDIR_PATH,"metadata0.xml")
     #dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"hex_2D_order2.msh"),optimize=False)
     #saveVTK(fn,x=dom.getX(), metadata_schema={"gml":"http://www.opengis.net/gml"}, metadata='<dummy>hello world</dummy><timeStamp uom="s">1234</timeStamp>')
     ## testing:
     #dummy=None
     #timeStamp=None
     #unstructured=None
     #dom=minidom.parseString(open(fn,'r').read())
     #for node in dom.childNodes:
        #if isinstance(node, minidom.Element):
           #if node.tagName == 'VTKFile':
              #type = node.getAttribute("type")
              #version = node.getAttribute("version")
              #ns = node.getAttribute("xmlns:gml")
              #self.failUnless(type == "UnstructuredGrid","Type wrong")
              #self.failUnless(version == "0.1", "wrong version")
              #self.failUnless(ns == "http://www.opengis.net/gml", "wrong name space")
              #for vtk_node in node.childNodes:
                 #if isinstance(vtk_node, minidom.Element):
                    #if vtk_node.tagName == 'MetaData':
                       #for meta_node in vtk_node.childNodes:
                           #if isinstance(meta_node, minidom.Element):
                               #if meta_node.tagName == 'dummy':
                                  #for txt_node in meta_node.childNodes:
                                     #if isinstance(txt_node, minidom.Text): 
                                         #dummy=txt_node.nodeValue.strip()
                                         #self.failUnless( dummy == "hello world","dummy is wrong")
                               #if meta_node.tagName == 'timeStamp':
                                  #uom=meta_node.getAttribute("uom")
                                  #self.failUnless( uom == "s","uom is wrong")
                                  #for txt_node in meta_node.childNodes:
                                     #if isinstance(txt_node, minidom.Text): 
                                         #timeStamp=txt_node.nodeValue.strip()
                                         #self.failUnless( timeStamp == "1234","dummy is wrong")
                    #if vtk_node.tagName == 'UnstructuredGrid': unstructured=True
     #self.failUnless( dummy !=None, "dummy is missing.")
     #self.failUnless( timeStamp !=None, "timeStamp is missing.")
     #self.failUnless( unstructured !=None, "dummy is missing.")
  #def test_metadata_1(self):
     #fn=os.path.join(DUDLEY_WORKDIR_PATH,"metadata1.xml")
     #dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"hex_2D_order2.msh"),optimize=False)
     #saveVTK(fn,x=dom.getX(), metadata='<dummy>hello world</dummy><timeStamp uom="s">1234</timeStamp>')
     ## testing:
     #dummy=None
     #timeStamp=None
     #unstructured=None
     #dom=minidom.parseString(open(fn,'r').read())
     #for node in dom.childNodes:
        #if isinstance(node, minidom.Element):
           #if node.tagName == 'VTKFile':
              #type = node.getAttribute("type")
              #version = node.getAttribute("version")
              #self.failUnless(type == "UnstructuredGrid","Type wrong")
              #self.failUnless(version == "0.1", "wrong version")
              #for vtk_node in node.childNodes:
                 #if isinstance(vtk_node, minidom.Element):
                    #if vtk_node.tagName == 'MetaData':
                       #for meta_node in vtk_node.childNodes:
                           #if isinstance(meta_node, minidom.Element):
                               #if meta_node.tagName == 'dummy':
                                  #for txt_node in meta_node.childNodes:
                                     #if isinstance(txt_node, minidom.Text): 
                                         #dummy=txt_node.nodeValue.strip()
                                         #self.failUnless( dummy == "hello world","dummy is wrong")
                               #if meta_node.tagName == 'timeStamp':
                                  #uom=meta_node.getAttribute("uom")
                                  #self.failUnless( uom == "s","uom is wrong")
                                  #for txt_node in meta_node.childNodes:
                                     #if isinstance(txt_node, minidom.Text): 
                                         #timeStamp=txt_node.nodeValue.strip()
                                         #self.failUnless( timeStamp == "1234","dummy is wrong")
                    #if vtk_node.tagName == 'UnstructuredGrid': unstructured=True
     #self.failUnless( dummy !=None, "dummy is missing.")
     #self.failUnless( timeStamp !=None, "timeStamp is missing.")
     #self.failUnless( unstructured !=None, "dummy is missing.")
  #def test_metadata_2(self):
     #fn=os.path.join(DUDLEY_WORKDIR_PATH,"metadata2.xml")
     #dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"hex_2D_order2.msh"),optimize=False)
     #saveVTK(fn,x=dom.getX(), metadata_schema={"gml":"http://www.opengis.net/gml"})
     ## testing:
     #unstructured=None
     #dom=minidom.parseString(open(fn,'r').read())
     #for node in dom.childNodes:
        #if isinstance(node, minidom.Element):
           #if node.tagName == 'VTKFile':
              #type = node.getAttribute("type")
              #version = node.getAttribute("version")
              #ns = node.getAttribute("xmlns:gml")
              #self.failUnless(type == "UnstructuredGrid","Type wrong")
              #self.failUnless(version == "0.1", "wrong version")
              #self.failUnless(ns == "http://www.opengis.net/gml", "wrong name space")
              #for vtk_node in node.childNodes:
                 #if isinstance(vtk_node, minidom.Element):
                    #if vtk_node.tagName == 'UnstructuredGrid': unstructured=True
     #self.failUnless( unstructured !=None, "dummy is missing.")
  #def test_metadata_3(self):
     #fn=os.path.join(DUDLEY_WORKDIR_PATH,"metadata3.xml")
     #dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"hex_2D_order2.msh"),optimize=False)
     #saveVTK(fn,x=dom.getX())
     ## testing:
     #unstructured=None
     #dom=minidom.parseString(open(fn,'r').read())
     #for node in dom.childNodes:
        #if isinstance(node, minidom.Element):
           #if node.tagName == 'VTKFile':
              #type = node.getAttribute("type")
              #version = node.getAttribute("version")
              #self.failUnless(type == "UnstructuredGrid","Type wrong")
              #self.failUnless(version == "0.1", "wrong version")
              #for vtk_node in node.childNodes:
                 #if isinstance(vtk_node, minidom.Element):
                    #if vtk_node.tagName == 'UnstructuredGrid': unstructured=True
     #self.failUnless( unstructured !=None, "dummy is missing.")
  
  
  # ====== TRI 2D order 1 =================================================================================================

  def test_tet_2D_order1_ContinuousFunction_Scalar_vtk(self):
     reference="tet_2D_o1_node_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ContinuousFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ContinuousFunction_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_ContinuousFunction_Scalar.xml",reference)
  def test_tet_2D_order1_ContinuousFunction_Vector_vtk(self):
     reference="tet_2D_o1_node_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ContinuousFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ContinuousFunction_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_ContinuousFunction_Vector.xml",reference)
  def test_tet_2D_order1_ContinuousFunction_Tensor_vtk(self):
     reference="tet_2D_o1_node_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ContinuousFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ContinuousFunction_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_ContinuousFunction_Tensor.xml",reference)
  def test_tet_2D_order1_Solution_Scalar_vtk(self):
     reference="tet_2D_o1_node_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=Solution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_Solution_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_Solution_Scalar.xml",reference)
  def test_tet_2D_order1_Solution_Vector_vtk(self):
     reference="tet_2D_o1_node_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=Solution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_Solution_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_Solution_Vector.xml",reference)
  def test_tet_2D_order1_Solution_Tensor_vtk(self):
     reference="tet_2D_o1_node_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=Solution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_Solution_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_Solution_Tensor.xml",reference)
  def test_tet_2D_order1_ReducedSolution_Scalar_vtk(self):
     reference="tet_2D_o1_node_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedSolution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedSolution_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_ReducedSolution_Scalar.xml",reference)
  def test_tet_2D_order1_ReducedSolution_Vector_vtk(self):
     reference="tet_2D_o1_node_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedSolution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedSolution_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_ReducedSolution_Vector.xml",reference)
  def test_tet_2D_order1_ReducedSolution_Tensor_vtk(self):
     reference="tet_2D_o1_node_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedSolution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedSolution_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_ReducedSolution_Tensor.xml",reference)
  def test_tet_2D_order1_Function_Scalar_vtk(self):
     reference="tet_2D_o1_cell_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=Function(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_Function_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_Function_Scalar.xml",reference)
  def test_tet_2D_order1_Function_Vector_vtk(self):
     reference="tet_2D_o1_cell_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=Function(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_Function_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_Function_Vector.xml",reference)
  def test_tet_2D_order1_Function_Tensor_vtk(self):
     reference="tet_2D_o1_cell_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=Function(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_Function_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_Function_Tensor.xml",reference)
  def test_tet_2D_order1_ReducedFunction_Scalar_vtk(self):
     reference="tet_2D_o1_cell_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedFunction_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_ReducedFunction_Scalar.xml",reference)
  def test_tet_2D_order1_ReducedFunction_Vector_vtk(self):
     reference="tet_2D_o1_cell_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedFunction_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_ReducedFunction_Vector.xml",reference)
  def test_tet_2D_order1_ReducedFunction_Tensor_vtk(self):
     reference="tet_2D_o1_cell_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedFunction_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_ReducedFunction_Tensor.xml",reference)
  def test_tet_2D_order1_FunctionOnBoundary_Scalar_vtk(self):
     reference="tet_2D_o1_boundary_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=FunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_FunctionOnBoundary_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_FunctionOnBoundary_Scalar.xml",reference)
  def test_tet_2D_order1_FunctionOnBoundary_Vector_vtk(self):
     reference="tet_2D_o1_boundary_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=FunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_FunctionOnBoundary_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_FunctionOnBoundary_Vector.xml",reference)
  def test_tet_2D_order1_FunctionOnBoundary_Tensor_vtk(self):
     reference="tet_2D_o1_boundary_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=FunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_FunctionOnBoundary_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_FunctionOnBoundary_Tensor.xml",reference)
  def test_tet_2D_order1_ReducedFunctionOnBoundary_Scalar_vtk(self):
     reference="tet_2D_o1_boundary_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedFunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedFunctionOnBoundary_Scalar.xml"),data=x[0])
     self.check_vtk("tet_2D_order1_ReducedFunctionOnBoundary_Scalar.xml",reference)
  def test_tet_2D_order1_ReducedFunctionOnBoundary_Vector_vtk(self):
     reference="tet_2D_o1_boundary_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedFunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedFunctionOnBoundary_Vector.xml"),data=x[0]*[1.,2.])
     self.check_vtk("tet_2D_order1_ReducedFunctionOnBoundary_Vector.xml",reference)
  def test_tet_2D_order1_ReducedFunctionOnBoundary_Tensor_vtk(self):
     reference="tet_2D_o1_boundary_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_2D_order1.fly"),optimize=False)
     x=ReducedFunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_2D_order1_ReducedFunctionOnBoundary_Tensor.xml"),data=x[0]*[[11.,12.],[21.,22.]])
     self.check_vtk("tet_2D_order1_ReducedFunctionOnBoundary_Tensor.xml",reference)

  # ======================================================================================================================
  def test_tet_3D_order1_ContinuousFunction_Scalar_vtk(self):
     reference="tet_3D_o1_node_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ContinuousFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ContinuousFunction_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_ContinuousFunction_Scalar.xml",reference)
  def test_tet_3D_order1_ContinuousFunction_Vector_vtk(self):
     reference="tet_3D_o1_node_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ContinuousFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ContinuousFunction_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_ContinuousFunction_Vector.xml",reference)
  def test_tet_3D_order1_ContinuousFunction_Tensor_vtk(self):
     reference="tet_3D_o1_node_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ContinuousFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ContinuousFunction_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_ContinuousFunction_Tensor.xml",reference)
  def test_tet_3D_order1_Solution_Scalar_vtk(self):
     reference="tet_3D_o1_node_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=Solution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_Solution_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_Solution_Scalar.xml",reference)
  def test_tet_3D_order1_Solution_Vector_vtk(self):
     reference="tet_3D_o1_node_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=Solution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_Solution_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_Solution_Vector.xml",reference)
  def test_tet_3D_order1_Solution_Tensor_vtk(self):
     reference="tet_3D_o1_node_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=Solution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_Solution_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_Solution_Tensor.xml",reference)
  def test_tet_3D_order1_ReducedSolution_Scalar_vtk(self):
     reference="tet_3D_o1_node_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedSolution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedSolution_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_ReducedSolution_Scalar.xml",reference)
  def test_tet_3D_order1_ReducedSolution_Vector_vtk(self):
     reference="tet_3D_o1_node_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedSolution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedSolution_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_ReducedSolution_Vector.xml",reference)
  def test_tet_3D_order1_ReducedSolution_Tensor_vtk(self):
     reference="tet_3D_o1_node_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedSolution(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedSolution_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_ReducedSolution_Tensor.xml",reference)
  def test_tet_3D_order1_Function_Scalar_vtk(self):
     reference="tet_3D_o1_cell_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=Function(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_Function_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_Function_Scalar.xml",reference)
  def test_tet_3D_order1_Function_Vector_vtk(self):
     reference="tet_3D_o1_cell_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=Function(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_Function_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_Function_Vector.xml",reference)
  def test_tet_3D_order1_Function_Tensor_vtk(self):
     reference="tet_3D_o1_cell_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=Function(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_Function_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_Function_Tensor.xml",reference)
  def test_tet_3D_order1_ReducedFunction_Scalar_vtk(self):
     reference="tet_3D_o1_cell_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedFunction_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_ReducedFunction_Scalar.xml",reference)
  def test_tet_3D_order1_ReducedFunction_Vector_vtk(self):
     reference="tet_3D_o1_cell_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedFunction_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_ReducedFunction_Vector.xml",reference)
  def test_tet_3D_order1_ReducedFunction_Tensor_vtk(self):
     reference="tet_3D_o1_cell_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedFunction(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedFunction_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_ReducedFunction_Tensor.xml",reference)
  def test_tet_3D_order1_FunctionOnBoundary_Scalar_vtk(self):
     reference="tet_3D_o1_boundary_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=FunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_FunctionOnBoundary_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_FunctionOnBoundary_Scalar.xml",reference)
  def test_tet_3D_order1_FunctionOnBoundary_Vector_vtk(self):
     reference="tet_3D_o1_boundary_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=FunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_FunctionOnBoundary_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_FunctionOnBoundary_Vector.xml",reference)
  def test_tet_3D_order1_FunctionOnBoundary_Tensor_vtk(self):
     reference="tet_3D_o1_boundary_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=FunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_FunctionOnBoundary_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_FunctionOnBoundary_Tensor.xml",reference)
  def test_tet_3D_order1_ReducedFunctionOnBoundary_Scalar_vtk(self):
     reference="tet_3D_o1_boundary_s.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedFunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedFunctionOnBoundary_Scalar.xml"),data=x[0])
     self.check_vtk("tet_3D_order1_ReducedFunctionOnBoundary_Scalar.xml",reference)
  def test_tet_3D_order1_ReducedFunctionOnBoundary_Vector_vtk(self):
     reference="tet_3D_o1_boundary_v.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedFunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedFunctionOnBoundary_Vector.xml"),data=x[0]*[1.,2.,3.])
     self.check_vtk("tet_3D_order1_ReducedFunctionOnBoundary_Vector.xml",reference)
  def test_tet_3D_order1_ReducedFunctionOnBoundary_Tensor_vtk(self):
     reference="tet_3D_o1_boundary_t.xml"
     dom=ReadMesh(os.path.join(DUDLEY_TEST_MESH_PATH,"tet_3D_order1.fly"),optimize=False)
     x=ReducedFunctionOnBoundary(dom).getX()
     saveVTK(os.path.join(DUDLEY_WORKDIR_PATH,"tet_3D_order1_ReducedFunctionOnBoundary_Tensor.xml"),data=x[0]*[[11.,12.,13.],[21.,22.,23],[31.,32.,33.]])
     self.check_vtk("tet_3D_order1_ReducedFunctionOnBoundary_Tensor.xml",reference)


if __name__ == '__main__':
   suite = unittest.TestSuite()
   #suite.addTest(Test_VTKFiles("test_metadata_3"))
   suite.addTest(unittest.makeSuite(Test_VTKFiles))
   # suite.addTest(Test_VTKFiles("test_tet_2D_macro_ReducedFunction_Scalar_vtk"))
   # saveDX is not MPI parallel
   #if getMPISizeWorld() == 1: 
   #    suite.addTest(unittest.makeSuite(Test_DXFiles))
   #    pass
   #else:
   #    print "Test_DXFiles is dropped as number of processors >1"
   s=unittest.TextTestRunner(verbosity=2).run(suite)
   if not s.wasSuccessful(): sys.exit(1)
