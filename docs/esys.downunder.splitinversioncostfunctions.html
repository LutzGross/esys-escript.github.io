
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>esys.downunder.splitinversioncostfunctions Package &#8212; esys.escript 5.9 documentation</title>
    <link rel="stylesheet" href="agogo.css" type="text/css" />
    <link rel="stylesheet" href="pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="documentation_options.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="underscore.js"></script>
    <script type="text/javascript" src="doctools.js"></script>
    <script type="text/javascript" src="language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="esys.downunder.splitminimizers Package" href="esys.downunder.splitminimizers.html" />
    <link rel="prev" title="esys.downunder.seismic Package" href="esys.downunder.seismic.html" /> 
  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="index.html">esys.escript 5.9 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="esys.downunder.seismic.html" title="esys.downunder.seismic Package"
             accesskey="P">previous</a> |
          <a href="esys.downunder.splitminimizers.html" title="esys.downunder.splitminimizers Package"
             accesskey="N">next</a> |
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-esys.downunder.splitinversioncostfunctions">
<span id="esys-downunder-splitinversioncostfunctions-package"></span><h1>esys.downunder.splitinversioncostfunctions Package<a class="headerlink" href="#module-esys.downunder.splitinversioncostfunctions" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li></li>
</ul>
<div class="section" id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.ArithmeticTuple" title="esys.downunder.splitinversioncostfunctions.ArithmeticTuple"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ArithmeticTuple</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.ForwardModel" title="esys.downunder.splitinversioncostfunctions.ForwardModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForwardModel</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.FunctionJob" title="esys.downunder.splitinversioncostfunctions.FunctionJob"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionJob</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Job" title="esys.downunder.splitinversioncostfunctions.Job"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Job</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Mapping" title="esys.downunder.splitinversioncostfunctions.Mapping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mapping</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction" title="esys.downunder.splitinversioncostfunctions.MeteredCostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MeteredCostFunction</span></code></a></li>
<li><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction" title="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitInversionCostFunction</span></code></a></li>
</ul>
<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.ArithmeticTuple">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">ArithmeticTuple</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ArithmeticTuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Tuple supporting inplace update x+=y and scaling x=a*y where <code class="docutils literal notranslate"><span class="pre">x,y</span></code> is an
ArithmeticTuple and <code class="docutils literal notranslate"><span class="pre">a</span></code> is a float.</p>
<p>Example of usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">esys.escript</span> <span class="k">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">array</span>
<span class="n">a</span><span class="o">=</span><span class="n">eData</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">b</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="mf">4.</span><span class="p">])</span>
<span class="n">x</span><span class="o">=</span><span class="n">ArithmeticTuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">y</span><span class="o">=</span><span class="mf">5.</span><span class="o">*</span><span class="n">x</span>
</pre></div>
</div>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.ArithmeticTuple.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ArithmeticTuple.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes object with elements <code class="docutils literal notranslate"><span class="pre">args</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> – tuple of objects that support inplace add (x+=y) and
scaling (x=a*y)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.Data">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">Data</code><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<p>Represents a collection of datapoints. It is used to store the values of a function. For more details please consult the c++ class documentation.</p>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>(object)arg1</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1, (object)value [, (object)p2 [, (object)p3 [, (object)p4]]]) -&gt; None</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Data<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.conjugate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(Data)other</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make this object a copy of <code class="docutils literal notranslate"><span class="pre">other</span></code></p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">note:</th><td class="field-body">The two objects will act independently from now on. That is, changing <code class="docutils literal notranslate"><span class="pre">other</span></code> after this call will not change this object and vice versa.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="docutils">
<dt>copy( (Data)arg1) -&gt; Data :</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">note:</th><td class="field-body">In the no argument form, a new object will be returned which is an independent copy of this object.</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.copyWithMask">
<code class="descname">copyWithMask</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(Data)other</em>, <em>(Data)mask</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.copyWithMask" title="Permalink to this definition">¶</a></dt>
<dd><p>Selectively copy values from <code class="docutils literal notranslate"><span class="pre">other</span></code> <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>.Datapoints which correspond to positive values in <code class="docutils literal notranslate"><span class="pre">mask</span></code> will be copied from <code class="docutils literal notranslate"><span class="pre">other</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other</strong> (<a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>) – source of values</li>
<li><strong>mask</strong> (Scalar <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>) – </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.delay">
<code class="descname">delay</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Data :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.delay" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this object into lazy representation</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(str)fileName</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the data as a netCDF file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>fileName</strong> (<code class="docutils literal notranslate"><span class="pre">string</span></code>) – </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data to expanded representation if it is not expanded already.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Domain :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getFunctionSpace">
<code class="descname">getFunctionSpace</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; FunctionSpace :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getFunctionSpace" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FunctionSpace</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getNumberOfDataPoints">
<code class="descname">getNumberOfDataPoints</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; int :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getNumberOfDataPoints" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Number of datapoints in the object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getRank">
<code class="descname">getRank</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; int :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getRank" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the number of indices required to address a component of a datapoint</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">positive <code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getShape">
<code class="descname">getShape</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; tuple :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the shape of the datapoints in this object as a python tuple. Scalar data has the shape <code class="docutils literal notranslate"><span class="pre">()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getTagNumber">
<code class="descname">getTagNumber</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(int)dpno</em><span class="sig-paren">)</span> &#x2192; int :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getTagNumber" title="Permalink to this definition">¶</a></dt>
<dd><p>Return tag number for the specified datapoint</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">int</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dpno</strong> (<em>int</em>) – datapoint number</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getTupleForDataPoint">
<code class="descname">getTupleForDataPoint</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(int)dataPointNo</em><span class="sig-paren">)</span> &#x2192; object :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getTupleForDataPoint" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Value of the specified datapoint</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dataPointNo</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – datapoint to access</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getTupleForGlobalDataPoint">
<code class="descname">getTupleForGlobalDataPoint</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(int)procNo</em>, <em>(int)dataPointNo</em><span class="sig-paren">)</span> &#x2192; object :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getTupleForGlobalDataPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a specific datapoint from a specific process</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>procNo</strong> (positive <code class="docutils literal notranslate"><span class="pre">int</span></code>) – MPI rank of the process</li>
<li><strong>dataPointNo</strong> (<em>int</em>) – datapoint to access</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.getX">
<code class="descname">getX</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Data :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.getX" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the spatial coordinates of the spatial nodes.
:rtype: <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.hasInf">
<code class="descname">hasInf</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.hasInf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns return true if data contains +-Inf.  [Note that for complex values, hasNaN and hasInf are not mutually exclusive.]</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.hasNaN">
<code class="descname">hasNaN</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.hasNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns return true if data contains NaN. [Note that for complex values, hasNaN and hasInf are not mutually exclusive.]</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.imag">
<code class="descname">imag</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Data<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.imag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.internal_maxGlobalDataPoint">
<code class="descname">internal_maxGlobalDataPoint</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; tuple :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.internal_maxGlobalDataPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Please consider using getSupLocator() from pdetools instead.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.internal_minGlobalDataPoint">
<code class="descname">internal_minGlobalDataPoint</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; tuple :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.internal_minGlobalDataPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Please consider using getInfLocator() from pdetools instead.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.interpolate">
<code class="descname">interpolate</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(FunctionSpace)functionspace</em><span class="sig-paren">)</span> &#x2192; Data :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate this object’s values into a new functionspace.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.interpolateTable">
<code class="descname">interpolateTable</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(object)table</em>, <em>(float)Amin</em>, <em>(float)Astep</em>, <em>(Data)B</em>, <em>(float)Bmin</em>, <em>(float)Bstep</em><span class="optional">[</span>, <em>(float)undef=1e+50</em><span class="optional">[</span>, <em>(bool)check_boundaries=False</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; Data :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.interpolateTable" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Creates a new Data object by interpolating using the source data (which are</dt>
<dd><p class="first">looked up in <code class="docutils literal notranslate"><span class="pre">table</span></code>)
<code class="docutils literal notranslate"><span class="pre">A</span></code> must be the outer dimension on the table</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param table:</th><td class="field-body">two dimensional collection of values</td>
</tr>
<tr class="field-even field"><th class="field-name">param Amin:</th><td class="field-body">The base of locations in table</td>
</tr>
<tr class="field-odd field"><th class="field-name">type Amin:</th><td class="field-body">float</td>
</tr>
<tr class="field-even field"><th class="field-name">param Astep:</th><td class="field-body">size of gap between each item in the table</td>
</tr>
<tr class="field-odd field"><th class="field-name">type Astep:</th><td class="field-body">float</td>
</tr>
<tr class="field-even field"><th class="field-name">param undef:</th><td class="field-body">upper bound on interpolated values</td>
</tr>
<tr class="field-odd field"><th class="field-name">type undef:</th><td class="field-body">float</td>
</tr>
<tr class="field-even field"><th class="field-name">param B:</th><td class="field-body">Scalar representing the second coordinate to be mapped into the table</td>
</tr>
<tr class="field-odd field"><th class="field-name">type B:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></td>
</tr>
<tr class="field-even field"><th class="field-name">param Bmin:</th><td class="field-body">The base of locations in table for 2nd dimension</td>
</tr>
<tr class="field-odd field"><th class="field-name">type Bmin:</th><td class="field-body">float</td>
</tr>
<tr class="field-even field"><th class="field-name">param Bstep:</th><td class="field-body">size of gap between each item in the table for 2nd dimension</td>
</tr>
<tr class="field-odd field"><th class="field-name">type Bstep:</th><td class="field-body">float</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">param check_boundaries:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">if true, then values outside the boundaries will be rejected. If false, then boundary values will be used.</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">raise RuntimeError(DataException):</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">if the coordinates do not map into the table or if the interpolated value is above <code class="docutils literal notranslate"><span class="pre">undef</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">rtype:</th><td class="field-body"><a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>interpolateTable( (Data)arg1, (object)table, (float)Amin, (float)Astep [, (float)undef=1e+50 [, (bool)check_boundaries=False]]) -&gt; Data</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isComplex">
<code class="descname">isComplex</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isComplex" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this <code class="docutils literal notranslate"><span class="pre">Data</span></code> stores complex values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isConstant">
<code class="descname">isConstant</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isConstant" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this <code class="docutils literal notranslate"><span class="pre">Data</span></code> is an instance of <code class="docutils literal notranslate"><span class="pre">DataConstant</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This does not mean the data is immutable.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isEmpty">
<code class="descname">isEmpty</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Is this object an instance of <code class="docutils literal notranslate"><span class="pre">DataEmpty</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Note:</th><td class="field-body">This is not the same thing as asking if the object contains datapoints.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isExpanded">
<code class="descname">isExpanded</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isExpanded" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this <code class="docutils literal notranslate"><span class="pre">Data</span></code> is expanded.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isLazy">
<code class="descname">isLazy</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isLazy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this <code class="docutils literal notranslate"><span class="pre">Data</span></code> is lazy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isProtected">
<code class="descname">isProtected</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isProtected" title="Permalink to this definition">¶</a></dt>
<dd><p>Can this instance be modified.
:rtype: <code class="docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isReady">
<code class="descname">isReady</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isReady" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this <code class="docutils literal notranslate"><span class="pre">Data</span></code> is not lazy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.isTagged">
<code class="descname">isTagged</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; bool :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.isTagged" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">bool</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">True if this <code class="docutils literal notranslate"><span class="pre">Data</span></code> is expanded.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.nonuniformInterpolate">
<code class="descname">nonuniformInterpolate</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(object)in</em>, <em>(object)out</em>, <em>(bool)check_boundaries</em><span class="sig-paren">)</span> &#x2192; Data :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.nonuniformInterpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>1D interpolation with non equally spaced points</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.nonuniformSlope">
<code class="descname">nonuniformSlope</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(object)in</em>, <em>(object)out</em>, <em>(bool)check_boundaries</em><span class="sig-paren">)</span> &#x2192; Data :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.nonuniformSlope" title="Permalink to this definition">¶</a></dt>
<dd><p>1D interpolation of slope with non equally spaced points</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.phase">
<code class="descname">phase</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Data<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.phase" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.promote">
<code class="descname">promote</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.promote" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.real">
<code class="descname">real</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; Data<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.real" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.replaceInf">
<code class="descname">replaceInf</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(object)value</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.replaceInf" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces +-Inf values with value. [Note, for complex Data, both real and imaginary components are replaced even if only one part is Inf].</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.replaceNaN">
<code class="descname">replaceNaN</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(object)value</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.replaceNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces NaN values with value. [Note, for complex Data, both real and imaginary components are replaced even if only one part is NaN].</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.resolve">
<code class="descname">resolve</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the data to non-lazy representation.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.setProtection">
<code class="descname">setProtection</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.setProtection" title="Permalink to this definition">¶</a></dt>
<dd><p>Disallow modifications to this data object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">This method does not allow you to undo protection.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.setTaggedValue">
<code class="descname">setTaggedValue</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(int)tagKey</em>, <em>(object)value</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.setTaggedValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the value of tagged Data.</p>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param tagKey:</th><td class="field-body">tag to update</td>
</tr>
<tr class="field-even field"><th class="field-name">type tagKey:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</div></blockquote>
<dl class="docutils">
<dt>setTaggedValue( (Data)arg1, (str)name, (object)value) -&gt; None :</dt>
<dd><table class="first last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">param name:</th><td class="field-body">tag to update</td>
</tr>
<tr class="field-even field"><th class="field-name">type name:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">string</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">param value:</th><td class="field-body">value to set tagged data to</td>
</tr>
<tr class="field-even field"><th class="field-name">type value:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">object</span></code> which acts like an array, <code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.setToZero">
<code class="descname">setToZero</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.setToZero" title="Permalink to this definition">¶</a></dt>
<dd><p>After this call the object will store values of the same shape as before but all components will be zero.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.setValueOfDataPoint">
<code class="descname">setValueOfDataPoint</code><span class="sig-paren">(</span><em>(Data)arg1</em>, <em>(int)dataPointNo</em>, <em>(object)value</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.setValueOfDataPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>setValueOfDataPoint( (Data)arg1, (int)arg2, (object)arg3) -&gt; None</p>
<p>setValueOfDataPoint( (Data)arg1, (int)arg2, (float)arg3) -&gt; None :</p>
<blockquote>
<div><p>Modify the value of a single datapoint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">param dataPointNo:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">type dataPointNo:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">int</td>
</tr>
<tr class="field-odd field"><th class="field-name">param value:</th><td class="field-body"></td>
</tr>
<tr class="field-even field"><th class="field-name">type value:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code> or an object which acts like an array, <code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">warning:</th><td class="field-body">Use of this operation is discouraged. It prevents some optimisations from operating.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.tag">
<code class="descname">tag</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="sig-paren">)</span> &#x2192; None :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.tag" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert data to tagged representation if it is not already tagged or expanded</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Data.toListOfTuples">
<code class="descname">toListOfTuples</code><span class="sig-paren">(</span><em>(Data)arg1</em><span class="optional">[</span>, <em>(bool)scalarastuple=False</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; object :<a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Data.toListOfTuples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the datapoints of this object in a list. Each datapoint is stored as a tuple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>scalarastuple</strong> – if True, scalar data will be wrapped as a tuple. True =&gt; [(0), (1), (2)]; False =&gt; [0, 1, 2]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.ForwardModel">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">ForwardModel</code><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ForwardModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract forward model that can be plugged into a cost function.
Subclasses need to implement <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getDefect" title="esys.downunder.splitinversioncostfunctions.ForwardModel.getDefect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDefect()</span></code></a>, <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getGradient" title="esys.downunder.splitinversioncostfunctions.ForwardModel.getGradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getGradient()</span></code></a>, and possibly
<a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getArguments" title="esys.downunder.splitinversioncostfunctions.ForwardModel.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a> and ‘getCoordinateTransformation’.</p>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.ForwardModel.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.ForwardModel.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getArguments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.ForwardModel.getCoordinateTransformation">
<code class="descname">getCoordinateTransformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getCoordinateTransformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.ForwardModel.getDefect">
<code class="descname">getDefect</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getDefect" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.ForwardModel.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.ForwardModel.getGradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">FunctionJob</code><span class="sig-paren">(</span><em>fn</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.escriptcore.splitworld.Job</span></code></p>
<p>Takes a python function (with only self and keyword params) to be called as the work method</p>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>fn</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>It ignores all of its parameters, except that, it requires the following as keyword arguments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.modellib.geometry.html#esys.modellib.geometry.DomainReader.domain" title="esys.modellib.geometry.DomainReader.domain"><strong>domain</strong></a> – Domain to be used as the basis for all <code class="docutils literal notranslate"><span class="pre">Data</span></code> and PDEs in this Job.</li>
<li><strong>jobid</strong> – sequence number of this job. The first job has id=1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.clearExports">
<code class="descname">clearExports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.clearExports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove exported values from the map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.clearImports">
<code class="descname">clearImports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.clearImports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove imported values from their map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.declareImport">
<code class="descname">declareImport</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.declareImport" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds name to the list of imports</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.exportValue">
<code class="descname">exportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.exportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Make value v available to other Jobs under the label name.
name must have already been registered with the SplitWorld instance.
For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – registered label for exported value</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.importValue">
<code class="descname">importValue</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.importValue" title="Permalink to this definition">¶</a></dt>
<dd><p>For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label for imported value.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.setImportValue">
<code class="descname">setImportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.setImportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Use to make a value available to the job (ie called from outside the job)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label used to identify this import</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.FunctionJob.work">
<code class="descname">work</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.FunctionJob.work" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to be overloaded for the job to actually do anthing.
A return value of True indicates this job thinks it is done.
A return value of False indicates work still to be done</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.Job">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">Job</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Describes a sequence of work to be carried out in a subworld.
The instances of this class used in the subworlds will
be constructed by the system.
To do specific work, this class should be subclassed and the work() 
(and possibly __init__ methods overloaded).
The majority of the work done by the job will be in the <em>overloaded</em> work() method.
The work() method should retrieve values from the outside using importValue() and pass values to
the rest of the system using exportValue().
The rest of the methods should be considered off limits.</p>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>It ignores all of its parameters, except that, it requires the following as keyword arguments</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.modellib.geometry.html#esys.modellib.geometry.DomainReader.domain" title="esys.modellib.geometry.DomainReader.domain"><strong>domain</strong></a> – Domain to be used as the basis for all <code class="docutils literal notranslate"><span class="pre">Data</span></code> and PDEs in this Job.</li>
<li><strong>jobid</strong> – sequence number of this job. The first job has id=1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.clearExports">
<code class="descname">clearExports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.clearExports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove exported values from the map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.clearImports">
<code class="descname">clearImports</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.clearImports" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove imported values from their map</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.declareImport">
<code class="descname">declareImport</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.declareImport" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds name to the list of imports</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.exportValue">
<code class="descname">exportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.exportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Make value v available to other Jobs under the label name.
name must have already been registered with the SplitWorld instance.
For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – registered label for exported value</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.importValue">
<code class="descname">importValue</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.importValue" title="Permalink to this definition">¶</a></dt>
<dd><p>For use inside the work() method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label for imported value.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.setImportValue">
<code class="descname">setImportValue</code><span class="sig-paren">(</span><em>name</em>, <em>v</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.setImportValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Use to make a value available to the job (ie called from outside the job)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference internal" href="esys.downunder.apps.html#esys.downunder.apps.SolverOptions.name" title="esys.downunder.apps.SolverOptions.name"><strong>name</strong></a> – label used to identify this import</li>
<li><strong>v</strong> – value to be imported</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Job.work">
<code class="descname">work</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Job.work" title="Permalink to this definition">¶</a></dt>
<dd><p>Need to be overloaded for the job to actually do anthing.
A return value of True indicates this job thinks it is done.
A return value of False indicates work still to be done</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.Mapping">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An abstract mapping class to map level set functions <em>m</em> to physical
parameters <em>p</em>.</p>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Mapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Mapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Mapping.getDerivative">
<code class="descname">getDerivative</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Mapping.getDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value for the derivative of the mapping for m</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Mapping.getInverse">
<code class="descname">getInverse</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Mapping.getInverse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the inverse of the mapping for physical parameter p</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Mapping.getTypicalDerivative">
<code class="descname">getTypicalDerivative</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Mapping.getTypicalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a typical value for the derivative</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.Mapping.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.Mapping.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value of the mapping for m</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">MeteredCostFunction</code><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.CostFunction</span></code></p>
<p>This an intrumented version of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code> class. The function
calls update statistical information.
The actual work is done by the methods with corresponding name and a
leading underscore. These functions need to be overwritten for a particular
cost function implementation.</p>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>the base constructor initializes the counters so subclasses should
ensure the super class constructor is called.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>returns precalculated values that are shared in the calculation of
<em>f(x)</em> and <em>grad f(x)</em> and the Hessian operator</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tuple returned by this call will be passed back to this <code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code> in other
calls(eg: <code class="docutils literal notranslate"><span class="pre">getGradient</span></code>). Its contents are not specified at this level because no code, other than the <code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code>
which created it, will be interacting with it.
That is, the implementor can put whatever information they find useful in it.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – location of derivative</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>x</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getArguments" title="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculate in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated.</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getArguments" title="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">x-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value <em>f(x)</em> using the precalculated values for <em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – a solution approximation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = False</em><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.resetCounters">
<code class="descname">resetCounters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.resetCounters" title="Permalink to this definition">¶</a></dt>
<dd><p>resets all statistical counters</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.MeteredCostFunction.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.MeteredCostFunction.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class that the Hessian operator needs to be updated.
This method is called by the solver class.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction">
<em class="property">class </em><code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">SplitInversionCostFunction</code><span class="sig-paren">(</span><em>numLevelSets=None</em>, <em>numModels=None</em>, <em>numMappings=None</em>, <em>splitworld=None</em>, <em>worldsinit_fn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">esys.downunder.costfunctions.MeteredCostFunction</span></code></p>
<p>Class to define cost function <em>J(m)</em> for inversion with one or more
forward models based on a multi-valued level set function <em>m</em>:</p>
<p><em>J(m) = J_reg(m) + sum_f mu_f * J_f(p)</em></p>
<p>where <em>J_reg(m)</em> is the regularization and cross gradient component of the
cost function applied to a level set function <em>m</em>, <em>J_f(p)</em> are the data
defect cost functions involving a physical forward model using the
physical parameter(s) <em>p</em> and <em>mu_f</em> is the trade-off factor for model f.</p>
<p>A forward model depends on a set of physical parameters <em>p</em> which are
constructed from components of the level set function <em>m</em> via mappings.</p>
<dl class="docutils">
<dt>Example 1 (single forward model):</dt>
<dd>m=Mapping()
f=ForwardModel()
J=InversionCostFunction(Regularization(), m, f)</dd>
<dt>Example 2 (two forward models on a single valued level set)</dt>
<dd><p class="first">m0=Mapping()
m1=Mapping()
f0=ForwardModel()
f1=ForwardModel()</p>
<p class="last">J=InversionCostFunction(Regularization(), mappings=[m0, m1], forward_models=[(f0, 0), (f1,1)])</p>
</dd>
<dt>Example 3 (two forward models on 2-valued level set)</dt>
<dd><p class="first">m0=Mapping()
m1=Mapping()
f0=ForwardModel()
f1=ForwardModel()</p>
<p class="last">J=InversionCostFunction(Regularization(self.numLevelSets=2), mappings=[(m0,0), (m1,0)], forward_models=[(f0, 0), (f1,1)])</p>
</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Note:</th><td class="field-body">If provides_inverse_Hessian_approximation is true, then the class
provides an approximative inverse of the Hessian operator.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>numLevelSets=None</em>, <em>numModels=None</em>, <em>numMappings=None</em>, <em>splitworld=None</em>, <em>worldsinit_fn=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>fill this in.</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.calculateGradient">
<code class="descname">calculateGradient</code><span class="sig-paren">(</span><em>vnames1</em>, <em>vnames2</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.calculateGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient operation produces two components (designated (Y^,X) in the non-split version).
vnames1 gives the variable name(s) where the first component should be stored.
vnames2 gives the variable name(s) where the second component should be stored.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.calculatePropertiesHelper">
<em class="property">static </em><code class="descname">calculatePropertiesHelper</code><span class="sig-paren">(</span><em>self</em>, <em>m</em>, <em>mappings</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.calculatePropertiesHelper" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the physical properties from a given level set
function <em>m</em> using the mappings of the cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> (<a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>) – level set function</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.calculateValue">
<code class="descname">calculateValue</code><span class="sig-paren">(</span><em>vname</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.calculateValue" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.createLevelSetFunction">
<code class="descname">createLevelSetFunction</code><span class="sig-paren">(</span><em>*props</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.createLevelSetFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an instance of an object used to represent a level set function
initialized with zeros. Components can be overwritten by physical
properties <code class="xref py py-obj docutils literal notranslate"><span class="pre">props</span></code>. If present entries must correspond to the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> arguments in the constructor. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for properties
for which no value is given.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.createLevelSetFunctionHelper">
<em class="property">static </em><code class="descname">createLevelSetFunctionHelper</code><span class="sig-paren">(</span><em>self</em>, <em>regularization</em>, <em>mappings</em>, <em>*props</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.createLevelSetFunctionHelper" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object (init-ed) with 0s.
Components can be overwritten by physical
properties <code class="xref py py-obj docutils literal notranslate"><span class="pre">props</span></code>. If present entries must correspond to the
<code class="xref py py-obj docutils literal notranslate"><span class="pre">mappings</span></code> arguments in the constructor. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for properties
for which no value is given.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.formatMappings">
<em class="property">static </em><code class="descname">formatMappings</code><span class="sig-paren">(</span><em>mappings</em>, <em>numLevelSets</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.formatMappings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.formatModels">
<em class="property">static </em><code class="descname">formatModels</code><span class="sig-paren">(</span><em>forward_models</em>, <em>numMappings</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.formatModels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getArguments">
<code class="descname">getArguments</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getArguments" title="Permalink to this definition">¶</a></dt>
<dd><p>returns precalculated values that are shared in the calculation of
<em>f(x)</em> and <em>grad f(x)</em> and the Hessian operator</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The tuple returned by this call will be passed back to this <code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code> in other
calls(eg: <code class="docutils literal notranslate"><span class="pre">getGradient</span></code>). Its contents are not specified at this level because no code, other than the <code class="xref py py-obj docutils literal notranslate"><span class="pre">CostFunction</span></code>
which created it, will be interacting with it.
That is, the implementor can put whatever information they find useful in it.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – location of derivative</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">tuple</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getComponentValues">
<code class="descname">getComponentValues</code><span class="sig-paren">(</span><em>m</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getComponentValues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getDomain">
<code class="descname">getDomain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getDomain" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the domain of the cost function</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Domain</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getDualProduct">
<code class="descname">getDualProduct</code><span class="sig-paren">(</span><em>x</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getDualProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the dual product of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getForwardModel">
<code class="descname">getForwardModel</code><span class="sig-paren">(</span><em>idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getForwardModel" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <em>idx</em>-th forward model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idx</strong> (<code class="docutils literal notranslate"><span class="pre">int</span></code>) – model index. If cost function contains one model only <code class="xref py py-obj docutils literal notranslate"><span class="pre">idx</span></code>
can be omitted.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getGradient">
<code class="descname">getGradient</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the gradient of <em>f</em> at <em>x</em> using the precalculated values for
<em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of derivative</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getArguments" title="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">r-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getInverseHessianApproximation">
<code class="descname">getInverseHessianApproximation</code><span class="sig-paren">(</span><em>x</em>, <em>r</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getInverseHessianApproximation" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an approximative evaluation <em>p</em> of the inverse of the Hessian
operator of the cost function for a given gradient <em>r</em> at a given
location <em>x</em>: <em>H(x) p = r</em></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general it is assumed that the Hessian <em>H(x)</em> needs to be
calculate in each call for a new location <em>x</em>. However, the
solver may suggest that this is not required, typically when
the iteration is close to completeness.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>x-type</em>) – location of Hessian operator to be evaluated.</li>
<li><strong>r</strong> (<em>r-type</em>) – a given gradient</li>
<li><strong>args</strong> – pre-calculated values for <code class="docutils literal notranslate"><span class="pre">x</span></code> from <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getArguments" title="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getArguments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getArguments()</span></code></a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">x-type</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getModelArgs">
<em class="property">static </em><code class="descname">getModelArgs</code><span class="sig-paren">(</span><em>self</em>, <em>fwdmodels</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getModelArgs" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to import the arguments for forward models, if they are not available, 
Computes and exports them</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getNorm">
<code class="descname">getNorm</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the norm of <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getNumTradeOffFactors">
<code class="descname">getNumTradeOffFactors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getNumTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the number of trade-off factors being used including the
trade-off factors used in the regularization component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getProperties">
<code class="descname">getProperties</code><span class="sig-paren">(</span><em>m</em>, <em>return_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getProperties" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the physical properties from a given level set
function <em>m</em> using the mappings of the cost function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>m</strong> (<a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a>) – level set function</li>
<li><strong>return_list</strong> (<code class="docutils literal notranslate"><span class="pre">bool</span></code>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> a list is returned.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#esys.downunder.splitinversioncostfunctions.Data" title="esys.downunder.splitinversioncostfunctions.Data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getRegularization">
<code class="descname">getRegularization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the regularization</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getTradeOffFactors">
<code class="descname">getTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a list of the trade-off factors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getTradeOffFactorsModels">
<code class="descname">getTradeOffFactorsModels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getTradeOffFactorsModels" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the trade-off factors for the forward models</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getValue">
<code class="descname">getValue</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.getValue" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the value <em>f(x)</em> using the precalculated values for <em>x</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>x-type</em>) – a solution approximation</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.provides_inverse_Hessian_approximation">
<code class="descname">provides_inverse_Hessian_approximation</code><em class="property"> = True</em><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.provides_inverse_Hessian_approximation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.resetCounters">
<code class="descname">resetCounters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.resetCounters" title="Permalink to this definition">¶</a></dt>
<dd><p>resets all statistical counters</p>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setPoint">
<code class="descname">setPoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setPoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setTradeOffFactors">
<code class="descname">setTradeOffFactors</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setTradeOffFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the forward model and regularization
terms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">float</span></code>) – list of trade-off factors.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setTradeOffFactorsModels">
<code class="descname">setTradeOffFactorsModels</code><span class="sig-paren">(</span><em>mu=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setTradeOffFactorsModels" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the forward model components.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mu</strong> (<code class="docutils literal notranslate"><span class="pre">float</span></code> in case of a single model or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of
<code class="docutils literal notranslate"><span class="pre">float</span></code> with the length of the number of models.) – list of the trade-off factors. If not present ones are used.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setTradeOffFactorsRegularization">
<code class="descname">setTradeOffFactorsRegularization</code><span class="sig-paren">(</span><em>mu=None</em>, <em>mu_c=None</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.setTradeOffFactorsRegularization" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the trade-off factors for the regularization component of the
cost function, see <code class="xref py py-obj docutils literal notranslate"><span class="pre">Regularization</span></code> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mu</strong> – trade-off factors for the level-set variation part</li>
<li><strong>mu_c</strong> – trade-off factors for the cross gradient variation part</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.subworld_setMu_model">
<em class="property">static </em><code class="descname">subworld_setMu_model</code><span class="sig-paren">(</span><em>self</em>, <em>**args</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.subworld_setMu_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.updateHessian">
<code class="descname">updateHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.updateHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>notifies the class that the Hessian operator needs to be updated.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.update_point_helper">
<em class="property">static </em><code class="descname">update_point_helper</code><span class="sig-paren">(</span><em>self</em>, <em>newpoint</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.SplitInversionCostFunction.update_point_helper" title="Permalink to this definition">¶</a></dt>
<dd><p>Call within a subworld to set ‘current_point’ to newpoint
and update all the cached args info</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="esys.downunder.splitinversioncostfunctions.inner">
<code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">inner</code><span class="sig-paren">(</span><em>arg0</em>, <em>arg1</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Inner product of the two arguments. The inner product is defined as:</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">out=Sigma_s</span> <span class="pre">arg0[s]*arg1[s]</span></code></p>
<p>where s runs through <code class="docutils literal notranslate"><span class="pre">arg0.Shape</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">arg0</span></code> and <code class="docutils literal notranslate"><span class="pre">arg1</span></code> must have the same shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>arg0</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Data</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>) – first argument</li>
<li><strong>arg1</strong> (<code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Data</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>) – second argument</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the inner product of <code class="docutils literal notranslate"><span class="pre">arg0</span></code> and <code class="docutils literal notranslate"><span class="pre">arg1</span></code> at each data point</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">escript.Data</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Symbol</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>
depending on the input</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><strong>ValueError</strong> – if the shapes of the arguments are not identical</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="esys.downunder.splitinversioncostfunctions.updateHessianWorker">
<code class="descclassname">esys.downunder.splitinversioncostfunctions.</code><code class="descname">updateHessianWorker</code><span class="sig-paren">(</span><em>self</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#esys.downunder.splitinversioncostfunctions.updateHessianWorker" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="others">
<h2>Others<a class="headerlink" href="#others" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="packages">
<h2>Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
</div>
</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table of Contents</h3>
          <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="esys.downunder.html">esys.downunder Package</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.html#classes">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.html#functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="esys.downunder.html#others">Others</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="esys.downunder.html#packages">Packages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="esys.downunder.dcresistivityforwardmodeling.html">esys.downunder.dcresistivityforwardmodeling Package</a></li>
<li class="toctree-l3"><a class="reference internal" href="esys.downunder.domainbuilder.html">esys.downunder.domainbuilder Package</a></li>
<li class="toctree-l3"><a class="reference internal" href="esys.downunder.seismic.html">esys.downunder.seismic Package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">esys.downunder.splitinversioncostfunctions Package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#others">Others</a></li>
<li class="toctree-l4"><a class="reference internal" href="#packages">Packages</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="esys.downunder.splitminimizers.html">esys.downunder.splitminimizers Package</a></li>
<li class="toctree-l3"><a class="reference internal" href="esys.downunder.splitregularizations.html">esys.downunder.splitregularizations Package</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="esys.dudley.html">esys.dudley Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.escript.html">esys.escript Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.finley.html">esys.finley Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.modellib.html">esys.modellib Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.pycad.html">esys.pycad Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.ripley.html">esys.ripley Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.speckley.html">esys.speckley Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="esys.weipa.html">esys.weipa Package</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="esys.downunder.seismic.html" title="esys.downunder.seismic Package"
              >previous</a> |
            <a href="esys.downunder.splitminimizers.html" title="esys.downunder.splitminimizers Package"
              >next</a> |
            <a href="py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2022, Author.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>